// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.4.2 (swiftlang-1205.0.28.2 clang-1205.0.19.57)
// swift-module-flags: -target arm64-apple-ios12.0 -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name SalemoveSDK
import AVFoundation
import CommonCrypto
import CoreFoundation
import CoreGraphics
import Darwin
import Dispatch
import Foundation
import MachO
import MobileCoreServices
import QuartzCore
import ReplayKit
@_exported import SalemoveSDK
import Security
import Swift
import SystemConfiguration
import TwilioVoice
import UIKit.UIImage
import UIKit
import UserNotifications
import WebRTC
import Darwin.POSIX.pthread
import zlib
public protocol Disposable : AnyObject {
  var isDisposed: Swift.Bool { get }
  func dispose()
}
final public class AnyDisposable : SalemoveSDK.Disposable {
  final public var isDisposed: Swift.Bool {
    get
  }
  public init(_ action: @escaping () -> Swift.Void)
  public init()
  public init(_ disposable: SalemoveSDK.Disposable)
  final public func dispose()
  @objc deinit
}
final public class CompositeDisposable : SalemoveSDK.Disposable {
  final public var isDisposed: Swift.Bool {
    get
  }
  public init<S>(_ disposables: S) where S : Swift.Sequence, S.Element == SalemoveSDK.Disposable
  convenience public init<S>(_ disposables: S) where S : Swift.Sequence, S.Element == SalemoveSDK.Disposable?
  convenience public init()
  final public func dispose()
  @discardableResult
  final public func add(_ disposable: SalemoveSDK.Disposable?) -> SalemoveSDK.Disposable?
  @discardableResult
  final public func add(_ action: @escaping () -> Swift.Void) -> SalemoveSDK.Disposable?
  @objc deinit
  @discardableResult
  public static func += (lhs: SalemoveSDK.CompositeDisposable, rhs: SalemoveSDK.Disposable?) -> SalemoveSDK.Disposable?
  @discardableResult
  public static func += (lhs: SalemoveSDK.CompositeDisposable, rhs: @escaping () -> Swift.Void) -> SalemoveSDK.Disposable?
}
final public class ScopedDisposable<Inner> : SalemoveSDK.Disposable where Inner : SalemoveSDK.Disposable {
  final public let inner: Inner
  final public var isDisposed: Swift.Bool {
    get
  }
  public init(_ disposable: Inner)
  @objc deinit
  final public func dispose()
}
extension ScopedDisposable where Inner == SalemoveSDK.AnyDisposable {
  convenience public init(_ disposable: SalemoveSDK.Disposable)
}
extension ScopedDisposable where Inner == SalemoveSDK.CompositeDisposable {
  @discardableResult
  public static func += (lhs: SalemoveSDK.ScopedDisposable<SalemoveSDK.CompositeDisposable>, rhs: SalemoveSDK.Disposable?) -> SalemoveSDK.Disposable?
  @discardableResult
  public static func += (lhs: SalemoveSDK.ScopedDisposable<SalemoveSDK.CompositeDisposable>, rhs: @escaping () -> Swift.Void) -> SalemoveSDK.Disposable?
}
final public class SerialDisposable : SalemoveSDK.Disposable {
  final public var isDisposed: Swift.Bool {
    get
  }
  final public var inner: SalemoveSDK.Disposable? {
    get
    set(disposable)
  }
  public init(_ disposable: SalemoveSDK.Disposable? = nil)
  final public func dispose()
  @objc deinit
}
@_hasMissingDesignatedInitializers open class MacawEvent {
  weak public var node: SalemoveSDK.Node?
  public func consume()
  @objc deinit
}
@objc public enum AttachmentType : Swift.Int {
  case files
  case singleChoice
  case singleChoiceResponse
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc @_hasMissingDesignatedInitializers @objcMembers public class EngagementFileData : ObjectiveC.NSObject {
  @objc final public let data: Foundation.Data
  @objc override dynamic public init()
  @objc deinit
}
@_hasMissingDesignatedInitializers open class SVGParser {
  @available(*, deprecated)
  open class func parse(bundle: Foundation.Bundle, path: Swift.String, ofType: Swift.String = "svg") throws -> SalemoveSDK.Node
  @available(*, deprecated)
  open class func parse(path: Swift.String, ofType: Swift.String = "svg") throws -> SalemoveSDK.Node
  open class func parse(resource: Swift.String, ofType type: Swift.String = "svg", inDirectory directory: Swift.String? = nil, fromBundle bundle: Foundation.Bundle = Bundle.main) throws -> SalemoveSDK.Node
  open class func parse(fullPath: Swift.String) throws -> SalemoveSDK.Node
  open class func parse(text: Swift.String) throws -> SalemoveSDK.Node
  @objc deinit
}
@_hasMissingDesignatedInitializers open class RotateEvent : SalemoveSDK.MacawEvent {
  final public let angle: Swift.Double
  @objc deinit
}
public protocol ShapeInterpolation : SalemoveSDK.Interpolable {
}
extension Shape : SalemoveSDK.ShapeInterpolation {
  public func interpolate(_ endValue: SalemoveSDK.Shape, progress: Swift.Double) -> Self
}
open class Font {
  final public let name: Swift.String
  final public let size: Swift.Int
  final public let weight: Swift.String
  public init(name: Swift.String = "Serif", size: Swift.Int = 12, weight: Swift.String = "normal")
  @objc deinit
}
public protocol URLConvertible {
  func asURL() throws -> Foundation.URL
}
extension String : SalemoveSDK.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
extension URL : SalemoveSDK.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
extension URLComponents : SalemoveSDK.URLConvertible {
  public func asURL() throws -> Foundation.URL
}
public protocol AlamofireURLRequestConvertible {
  func asURLRequest() throws -> Foundation.URLRequest
}
extension AlamofireURLRequestConvertible {
  public var urlRequest: Foundation.URLRequest? {
    get
  }
}
extension URLRequest : SalemoveSDK.AlamofireURLRequestConvertible {
  public func asURLRequest() throws -> Foundation.URLRequest
}
extension URLRequest {
  public init(url: SalemoveSDK.URLConvertible, method: SalemoveSDK.AlamofireHTTPMethod, headers: SalemoveSDK.HTTPHeaders? = nil) throws
}
public protocol AccessTokenAuthorizable {
  var authorizationType: SalemoveSDK.AuthorizationType? { get }
}
public enum AuthorizationType {
  case basic
  case bearer
  case custom(Swift.String)
  public var value: Swift.String {
    get
  }
}
extension AuthorizationType : Swift.Equatable {
  public static func == (lhs: SalemoveSDK.AuthorizationType, rhs: SalemoveSDK.AuthorizationType) -> Swift.Bool
}
public struct AccessTokenPlugin : SalemoveSDK.PluginType {
  public typealias TokenClosure = (SalemoveSDK.AuthorizationType) -> Swift.String
  public let tokenClosure: SalemoveSDK.AccessTokenPlugin.TokenClosure
  public init(tokenClosure: @escaping SalemoveSDK.AccessTokenPlugin.TokenClosure)
  public func prepare(_ request: Foundation.URLRequest, target: SalemoveSDK.TargetType) -> Foundation.URLRequest
}
open class Color : SalemoveSDK.Fill {
  final public let val: Swift.Int
  public static let white: SalemoveSDK.Color
  public static let silver: SalemoveSDK.Color
  public static let gray: SalemoveSDK.Color
  public static let black: SalemoveSDK.Color
  public static let red: SalemoveSDK.Color
  public static let maroon: SalemoveSDK.Color
  public static let yellow: SalemoveSDK.Color
  public static let olive: SalemoveSDK.Color
  public static let lime: SalemoveSDK.Color
  public static let green: SalemoveSDK.Color
  public static let aqua: SalemoveSDK.Color
  public static let teal: SalemoveSDK.Color
  public static let blue: SalemoveSDK.Color
  public static let navy: SalemoveSDK.Color
  public static let fuchsia: SalemoveSDK.Color
  public static let purple: SalemoveSDK.Color
  public static let clear: SalemoveSDK.Color
  public static let aliceBlue: SalemoveSDK.Color
  public static let antiqueWhite: SalemoveSDK.Color
  public static let aquamarine: SalemoveSDK.Color
  public static let azure: SalemoveSDK.Color
  public static let beige: SalemoveSDK.Color
  public static let bisque: SalemoveSDK.Color
  public static let blanchedAlmond: SalemoveSDK.Color
  public static let blueViolet: SalemoveSDK.Color
  public static let brown: SalemoveSDK.Color
  public static let burlywood: SalemoveSDK.Color
  public static let cadetBlue: SalemoveSDK.Color
  public static let chartreuse: SalemoveSDK.Color
  public static let chocolate: SalemoveSDK.Color
  public static let coral: SalemoveSDK.Color
  public static let cornflowerBlue: SalemoveSDK.Color
  public static let cornsilk: SalemoveSDK.Color
  public static let crimson: SalemoveSDK.Color
  public static let cyan: SalemoveSDK.Color
  public static let darkBlue: SalemoveSDK.Color
  public static let darkCyan: SalemoveSDK.Color
  public static let darkGoldenrod: SalemoveSDK.Color
  public static let darkGray: SalemoveSDK.Color
  public static let darkGreen: SalemoveSDK.Color
  public static let darkKhaki: SalemoveSDK.Color
  public static let darkMagenta: SalemoveSDK.Color
  public static let darkOliveGreen: SalemoveSDK.Color
  public static let darkOrange: SalemoveSDK.Color
  public static let darkOrchid: SalemoveSDK.Color
  public static let darkRed: SalemoveSDK.Color
  public static let darkSalmon: SalemoveSDK.Color
  public static let darkSeaGreen: SalemoveSDK.Color
  public static let darkSlateBlue: SalemoveSDK.Color
  public static let darkSlateGray: SalemoveSDK.Color
  public static let darkTurquoise: SalemoveSDK.Color
  public static let darkViolet: SalemoveSDK.Color
  public static let deepPink: SalemoveSDK.Color
  public static let deepSkyBlue: SalemoveSDK.Color
  public static let dimGray: SalemoveSDK.Color
  public static let dodgerBlue: SalemoveSDK.Color
  public static let firebrick: SalemoveSDK.Color
  public static let floralWhite: SalemoveSDK.Color
  public static let forestGreen: SalemoveSDK.Color
  public static let gainsboro: SalemoveSDK.Color
  public static let ghostWhite: SalemoveSDK.Color
  public static let gold: SalemoveSDK.Color
  public static let goldenrod: SalemoveSDK.Color
  public static let greenYellow: SalemoveSDK.Color
  public static let honeydew: SalemoveSDK.Color
  public static let hotPink: SalemoveSDK.Color
  public static let indianRed: SalemoveSDK.Color
  public static let indigo: SalemoveSDK.Color
  public static let ivory: SalemoveSDK.Color
  public static let khaki: SalemoveSDK.Color
  public static let lavender: SalemoveSDK.Color
  public static let lavenderBlush: SalemoveSDK.Color
  public static let lawnGreen: SalemoveSDK.Color
  public static let lemonChiffon: SalemoveSDK.Color
  public static let lightBlue: SalemoveSDK.Color
  public static let lightCoral: SalemoveSDK.Color
  public static let lightCyan: SalemoveSDK.Color
  public static let lightGoldenrodYellow: SalemoveSDK.Color
  public static let lightGray: SalemoveSDK.Color
  public static let lightGreen: SalemoveSDK.Color
  public static let lightPink: SalemoveSDK.Color
  public static let lightSalmon: SalemoveSDK.Color
  public static let lightSeaGreen: SalemoveSDK.Color
  public static let lightSkyBlue: SalemoveSDK.Color
  public static let lightSlateGray: SalemoveSDK.Color
  public static let lightSteelBlue: SalemoveSDK.Color
  public static let lightYellow: SalemoveSDK.Color
  public static let limeGreen: SalemoveSDK.Color
  public static let linen: SalemoveSDK.Color
  public static let mediumAquamarine: SalemoveSDK.Color
  public static let mediumBlue: SalemoveSDK.Color
  public static let mediumOrchid: SalemoveSDK.Color
  public static let mediumPurple: SalemoveSDK.Color
  public static let mediumSeaGreen: SalemoveSDK.Color
  public static let mediumSlateBlue: SalemoveSDK.Color
  public static let mediumSpringGreen: SalemoveSDK.Color
  public static let mediumTurquoise: SalemoveSDK.Color
  public static let mediumVioletRed: SalemoveSDK.Color
  public static let midnightBlue: SalemoveSDK.Color
  public static let mintCream: SalemoveSDK.Color
  public static let mistyRose: SalemoveSDK.Color
  public static let moccasin: SalemoveSDK.Color
  public static let navajoWhite: SalemoveSDK.Color
  public static let oldLace: SalemoveSDK.Color
  public static let oliveDrab: SalemoveSDK.Color
  public static let orange: SalemoveSDK.Color
  public static let orangeRed: SalemoveSDK.Color
  public static let orchid: SalemoveSDK.Color
  public static let paleGoldenrod: SalemoveSDK.Color
  public static let paleGreen: SalemoveSDK.Color
  public static let paleTurquoise: SalemoveSDK.Color
  public static let paleVioletRed: SalemoveSDK.Color
  public static let papayaWhip: SalemoveSDK.Color
  public static let peachPuff: SalemoveSDK.Color
  public static let peru: SalemoveSDK.Color
  public static let pink: SalemoveSDK.Color
  public static let plum: SalemoveSDK.Color
  public static let powderBlue: SalemoveSDK.Color
  public static let rebeccaPurple: SalemoveSDK.Color
  public static let rosyBrown: SalemoveSDK.Color
  public static let royalBlue: SalemoveSDK.Color
  public static let saddleBrown: SalemoveSDK.Color
  public static let salmon: SalemoveSDK.Color
  public static let sandyBrown: SalemoveSDK.Color
  public static let seaGreen: SalemoveSDK.Color
  public static let seashell: SalemoveSDK.Color
  public static let sienna: SalemoveSDK.Color
  public static let skyBlue: SalemoveSDK.Color
  public static let slateBlue: SalemoveSDK.Color
  public static let slateGray: SalemoveSDK.Color
  public static let snow: SalemoveSDK.Color
  public static let springGreen: SalemoveSDK.Color
  public static let steelBlue: SalemoveSDK.Color
  public static let tan: SalemoveSDK.Color
  public static let thistle: SalemoveSDK.Color
  public static let tomato: SalemoveSDK.Color
  public static let turquoise: SalemoveSDK.Color
  public static let violet: SalemoveSDK.Color
  public static let wheat: SalemoveSDK.Color
  public static let whiteSmoke: SalemoveSDK.Color
  public static let yellowGreen: SalemoveSDK.Color
  public init(_ val: Swift.Int = 0)
  public init(val: Swift.Int = 0)
  open func r() -> Swift.Int
  open func g() -> Swift.Int
  open func b() -> Swift.Int
  open func a() -> Swift.Int
  public func with(a: Swift.Double) -> SalemoveSDK.Color
  open class func rgbt(r: Swift.Int, g: Swift.Int, b: Swift.Int, t: Swift.Int) -> SalemoveSDK.Color
  open class func rgba(r: Swift.Int, g: Swift.Int, b: Swift.Int, a: Swift.Double) -> SalemoveSDK.Color
  open class func rgb(r: Swift.Int, g: Swift.Int, b: Swift.Int) -> SalemoveSDK.Color
  override public init()
  @objc deinit
}
extension CAAnimation {
  public var start: (() -> Swift.Void)? {
    get
    set
  }
  public var completion: ((Swift.Bool) -> Swift.Void)? {
    get
    set
  }
  public var animating: ((CoreGraphics.CGFloat) -> Swift.Void)? {
    get
    set
  }
  public var progress: ((CoreGraphics.CGFloat) -> Swift.Void)? {
    get
    set
  }
}
extension CALayer {
  public func addAnimation(_ anim: QuartzCore.CAAnimation, forKey key: Swift.String?, withCompletion completion: ((Swift.Bool) -> Swift.Void)?)
}
extension AlamofireRequest {
  public static let didResumeNotification: Foundation.Notification.Name
  public static let didSuspendNotification: Foundation.Notification.Name
  public static let didCancelNotification: Foundation.Notification.Name
  public static let didFinishNotification: Foundation.Notification.Name
  public static let didResumeTaskNotification: Foundation.Notification.Name
  public static let didSuspendTaskNotification: Foundation.Notification.Name
  public static let didCancelTaskNotification: Foundation.Notification.Name
  public static let didCompleteTaskNotification: Foundation.Notification.Name
}
extension Notification {
  public var request: SalemoveSDK.AlamofireRequest? {
    get
  }
}
@_hasMissingDesignatedInitializers final public class AlamofireNotifications : SalemoveSDK.EventMonitor {
  final public func requestDidResume(_ request: SalemoveSDK.AlamofireRequest)
  final public func requestDidSuspend(_ request: SalemoveSDK.AlamofireRequest)
  final public func requestDidCancel(_ request: SalemoveSDK.AlamofireRequest)
  final public func requestDidFinish(_ request: SalemoveSDK.AlamofireRequest)
  final public func request(_ request: SalemoveSDK.AlamofireRequest, didResumeTask task: Foundation.URLSessionTask)
  final public func request(_ request: SalemoveSDK.AlamofireRequest, didSuspendTask task: Foundation.URLSessionTask)
  final public func request(_ request: SalemoveSDK.AlamofireRequest, didCancelTask task: Foundation.URLSessionTask)
  final public func request(_ request: SalemoveSDK.AlamofireRequest, didCompleteTask task: Foundation.URLSessionTask, with error: SalemoveSDK.AFError?)
  @objc deinit
}
open class Circle : SalemoveSDK.Locus {
  final public let cx: Swift.Double
  final public let cy: Swift.Double
  final public let r: Swift.Double
  public init(cx: Swift.Double = 0, cy: Swift.Double = 0, r: Swift.Double = 0)
  override open func bounds() -> SalemoveSDK.Rect
  open func arc(shift: Swift.Double, extent: Swift.Double) -> SalemoveSDK.Arc
  override open func toPath() -> SalemoveSDK.Path
  override public init()
  @objc deinit
}
open class Effect {
  final public let input: SalemoveSDK.Effect?
  public init(input: SalemoveSDK.Effect?)
  public static func dropShadow(dx: Swift.Double = 0, dy: Swift.Double = -3, r: Swift.Double = 3, color: SalemoveSDK.Color = .black) -> SalemoveSDK.Effect?
  public func offset(dx: Swift.Double, dy: Swift.Double) -> SalemoveSDK.Effect
  public func mapColor(with matrix: SalemoveSDK.ColorMatrix) -> SalemoveSDK.Effect
  public func setColor(to color: SalemoveSDK.Color) -> SalemoveSDK.Effect
  public func blur(r: Swift.Double) -> SalemoveSDK.Effect
  public func blend() -> SalemoveSDK.Effect
  @objc deinit
}
public protocol SocketData {
  func socketRepresentation() throws -> SalemoveSDK.SocketData
}
extension SocketData {
  public func socketRepresentation() -> SalemoveSDK.SocketData
}
extension Array : SalemoveSDK.SocketData {
}
extension Bool : SalemoveSDK.SocketData {
}
extension Dictionary : SalemoveSDK.SocketData {
}
extension Double : SalemoveSDK.SocketData {
}
extension Int : SalemoveSDK.SocketData {
}
extension NSArray : SalemoveSDK.SocketData {
}
extension Data : SalemoveSDK.SocketData {
}
extension NSData : SalemoveSDK.SocketData {
}
extension NSDictionary : SalemoveSDK.SocketData {
}
extension NSString : SalemoveSDK.SocketData {
}
extension NSNull : SalemoveSDK.SocketData {
}
extension String : SalemoveSDK.SocketData {
}
public typealias AckCallback = ([Any]) -> Swift.Void
public typealias NormalCallback = ([Any], SalemoveSDK.SocketAckEmitter) -> Swift.Void
extension Salemove {
  @objc final public func uploadFileToEngagement(_ file: SalemoveSDK.EngagementFile, progress: SalemoveSDK.EngagementFileProgressBlock?, completion: @escaping SalemoveSDK.EngagementFileCompletionBlock)
  @objc final public func fetchFile(engagementFile: SalemoveSDK.EngagementFile, progress: SalemoveSDK.EngagementFileProgressBlock?, completion: @escaping SalemoveSDK.EngagementFileFetchCompletionBlock)
}
@_hasMissingDesignatedInitializers open class GroupDisposable {
  open func dispose()
  open func add(_ item: SalemoveSDK.MacawDisposable)
  @objc deinit
}
extension MacawDisposable {
  public func addTo(_ group: SalemoveSDK.GroupDisposable)
}
@_hasMissingDesignatedInitializers @objc public class Attachment : ObjectiveC.NSObject {
  final public let type: SalemoveSDK.AttachmentType?
  final public let selectedOption: Swift.String?
  final public let options: [SalemoveSDK.SingleChoiceOption]?
  final public let imageUrl: Swift.String?
  final public let files: [SalemoveSDK.EngagementFile]?
  public init(file: SalemoveSDK.EngagementFile)
  public init(files: [SalemoveSDK.EngagementFile])
  @objc override dynamic public init()
  @objc deinit
}
final public class URLEncodedFormEncoder {
  public enum ArrayEncoding {
    case brackets
    case noBrackets
    public static func == (a: SalemoveSDK.URLEncodedFormEncoder.ArrayEncoding, b: SalemoveSDK.URLEncodedFormEncoder.ArrayEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum BoolEncoding {
    case numeric
    case literal
    public static func == (a: SalemoveSDK.URLEncodedFormEncoder.BoolEncoding, b: SalemoveSDK.URLEncodedFormEncoder.BoolEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum DataEncoding {
    case deferredToData
    case base64
    case custom((Foundation.Data) throws -> Swift.String)
  }
  public enum DateEncoding {
    case deferredToDate
    case secondsSince1970
    case millisecondsSince1970
    case iso8601
    case formatted(Foundation.DateFormatter)
    case custom((Foundation.Date) throws -> Swift.String)
  }
  public enum KeyEncoding {
    case useDefaultKeys
    case convertToSnakeCase
    case convertToKebabCase
    case capitalized
    case uppercased
    case lowercased
    case custom((Swift.String) -> Swift.String)
  }
  public enum SpaceEncoding {
    case percentEscaped
    case plusReplaced
    public static func == (a: SalemoveSDK.URLEncodedFormEncoder.SpaceEncoding, b: SalemoveSDK.URLEncodedFormEncoder.SpaceEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum Error : Swift.Error {
    case invalidRootObject(Swift.String)
  }
  final public let alphabetizeKeyValuePairs: Swift.Bool
  final public let arrayEncoding: SalemoveSDK.URLEncodedFormEncoder.ArrayEncoding
  final public let boolEncoding: SalemoveSDK.URLEncodedFormEncoder.BoolEncoding
  final public let dataEncoding: SalemoveSDK.URLEncodedFormEncoder.DataEncoding
  final public let dateEncoding: SalemoveSDK.URLEncodedFormEncoder.DateEncoding
  final public let keyEncoding: SalemoveSDK.URLEncodedFormEncoder.KeyEncoding
  final public let spaceEncoding: SalemoveSDK.URLEncodedFormEncoder.SpaceEncoding
  final public var allowedCharacters: Foundation.CharacterSet
  public init(alphabetizeKeyValuePairs: Swift.Bool = true, arrayEncoding: SalemoveSDK.URLEncodedFormEncoder.ArrayEncoding = .brackets, boolEncoding: SalemoveSDK.URLEncodedFormEncoder.BoolEncoding = .numeric, dataEncoding: SalemoveSDK.URLEncodedFormEncoder.DataEncoding = .base64, dateEncoding: SalemoveSDK.URLEncodedFormEncoder.DateEncoding = .deferredToDate, keyEncoding: SalemoveSDK.URLEncodedFormEncoder.KeyEncoding = .useDefaultKeys, spaceEncoding: SalemoveSDK.URLEncodedFormEncoder.SpaceEncoding = .percentEscaped, allowedCharacters: Foundation.CharacterSet = .afURLQueryAllowed)
  final public func encode(_ value: Swift.Encodable) throws -> Swift.String
  final public func encode(_ value: Swift.Encodable) throws -> Foundation.Data
  @objc deinit
}
extension CharacterSet {
  public static let afURLQueryAllowed: Foundation.CharacterSet
}
@objc open class Node : SalemoveSDK.Drawable {
  final public let placeVar: SalemoveSDK.AnimatableVariable<SalemoveSDK.Transform>
  open var place: SalemoveSDK.Transform {
    get
    set(val)
  }
  final public let opaqueVar: SalemoveSDK.Variable<Swift.Bool>
  open var opaque: Swift.Bool {
    get
    set(val)
  }
  final public let opacityVar: SalemoveSDK.AnimatableVariable<Swift.Double>
  open var opacity: Swift.Double {
    get
    set(val)
  }
  final public let clipVar: SalemoveSDK.Variable<SalemoveSDK.Locus?>
  open var clip: SalemoveSDK.Locus? {
    get
    set(val)
  }
  final public let maskVar: SalemoveSDK.Variable<SalemoveSDK.Node?>
  open var mask: SalemoveSDK.Node? {
    get
    set(val)
  }
  final public let effectVar: SalemoveSDK.Variable<SalemoveSDK.Effect?>
  open var effect: SalemoveSDK.Effect? {
    get
    set(val)
  }
  public func nodeBy(tag: Swift.String) -> SalemoveSDK.Node?
  public func nodesBy(tag: Swift.String) -> [SalemoveSDK.Node]
  public func nodeBy(predicate: (SalemoveSDK.Node) -> Swift.Bool) -> SalemoveSDK.Node?
  public func nodesBy(predicate: (SalemoveSDK.Node) -> Swift.Bool) -> [SalemoveSDK.Node]
  @discardableResult
  public func onTouchPressed(_ f: @escaping (SalemoveSDK.TouchEvent) -> Swift.Void) -> SalemoveSDK.MacawDisposable
  @discardableResult
  public func onTouchMoved(_ f: @escaping (SalemoveSDK.TouchEvent) -> Swift.Void) -> SalemoveSDK.MacawDisposable
  @discardableResult
  public func onTouchReleased(_ f: @escaping (SalemoveSDK.TouchEvent) -> Swift.Void) -> SalemoveSDK.MacawDisposable
  @discardableResult
  public func onTap(tapCount: Swift.Int = 1, f: @escaping (SalemoveSDK.TapEvent) -> Swift.Void) -> SalemoveSDK.MacawDisposable
  @discardableResult
  public func onLongTap(_ f: @escaping (SalemoveSDK.TapEvent) -> Swift.Void) -> SalemoveSDK.MacawDisposable
  @discardableResult
  public func onPan(_ f: @escaping (SalemoveSDK.PanEvent) -> Swift.Void) -> SalemoveSDK.MacawDisposable
  @discardableResult
  public func onRotate(_ f: @escaping (SalemoveSDK.RotateEvent) -> Swift.Void) -> SalemoveSDK.MacawDisposable
  @discardableResult
  public func onPinch(_ f: @escaping (SalemoveSDK.PinchEvent) -> Swift.Void) -> SalemoveSDK.MacawDisposable
  public init(place: SalemoveSDK.Transform = Transform.identity, opaque: Swift.Bool = true, opacity: Swift.Double = 1, clip: SalemoveSDK.Locus? = nil, mask: SalemoveSDK.Node? = nil, effect: SalemoveSDK.Effect? = nil, visible: Swift.Bool = true, tag: [Swift.String] = [])
  open var bounds: SalemoveSDK.Rect? {
    get
  }
  @objc override dynamic open var hash: Swift.Int {
    @objc get
  }
  @objc override dynamic open func isEqual(_ object: Any?) -> Swift.Bool
  override public init(visible: Swift.Bool = super, tag: [Swift.String] = super)
  @objc deinit
}
public typealias MWindow = UIKit.UIWindow
public typealias MRectCorner = UIKit.UIRectCorner
public typealias MFont = UIKit.UIFont
public typealias MFontDescriptor = UIKit.UIFontDescriptor
public typealias MColor = UIKit.UIColor
public typealias MEvent = UIKit.UIEvent
public typealias MTouch = UIKit.UITouch
public typealias MImage = UIKit.UIImage
public typealias MBezierPath = UIKit.UIBezierPath
public typealias MGestureRecognizer = UIKit.UIGestureRecognizer
public typealias MGestureRecognizerState = UIKit.UIGestureRecognizer.State
public typealias MGestureRecognizerDelegate = UIKit.UIGestureRecognizerDelegate
public typealias MTapGestureRecognizer = UIKit.UITapGestureRecognizer
public typealias MLongPressGestureRecognizer = UIKit.UILongPressGestureRecognizer
public typealias MPanGestureRecognizer = UIKit.UIPanGestureRecognizer
public typealias MPinchGestureRecognizer = UIKit.UIPinchGestureRecognizer
public typealias MRotationGestureRecognizer = UIKit.UIRotationGestureRecognizer
public typealias MScreen = UIKit.UIScreen
public typealias MViewContentMode = UIKit.UIView.ContentMode
extension Signal {
  @_hasMissingDesignatedInitializers final public class Observer {
    public typealias Action = (SalemoveSDK.Signal<Value, Error>.Event) -> Swift.Void
    public init(_ action: @escaping SalemoveSDK.Signal<Value, Error>.Observer.Action)
    convenience public init(value: ((Value) -> Swift.Void)? = nil, failed: ((Error) -> Swift.Void)? = nil, completed: (() -> Swift.Void)? = nil, interrupted: (() -> Swift.Void)? = nil)
    @objc deinit
    final public func send(_ event: SalemoveSDK.Signal<Value, Error>.Event)
    final public func send(value: Value)
    final public func send(error: Error)
    final public func sendCompleted()
    final public func sendInterrupted()
  }
}
extension Signal.Observer {
  @available(*, unavailable, renamed: "send(_:)")
  final public var action: SalemoveSDK.Signal<Value, Error>.Observer.Action {
    get
  }
}
open class ContentLayout {
  public static let none: SalemoveSDK.ContentLayout
  public static func of(scaling: SalemoveSDK.AspectRatio = .meet, xAlign: SalemoveSDK.Align = .mid, yAlign: SalemoveSDK.Align = .mid) -> SalemoveSDK.ContentLayout
  public static func of(contentMode: SalemoveSDK.MViewContentMode) -> SalemoveSDK.ContentLayout
  public init()
  open func layout(size: SalemoveSDK.Size, into sizeToFitIn: SalemoveSDK.Size) -> SalemoveSDK.Transform
  open func layout(rect: SalemoveSDK.Rect, into sizeToFitIn: SalemoveSDK.Size) -> SalemoveSDK.Transform
  @objc deinit
}
open class Locus {
  public init()
  open func bounds() -> SalemoveSDK.Rect
  open func stroke(with: SalemoveSDK.Stroke) -> SalemoveSDK.Shape
  open func fill(with: SalemoveSDK.Fill) -> SalemoveSDK.Shape
  open func fill(_ hex: Swift.Int) -> SalemoveSDK.Shape
  open func fill(_ fill: SalemoveSDK.Fill) -> SalemoveSDK.Shape
  open func stroke(fill: SalemoveSDK.Fill = Color.black, width: Swift.Double = 1, cap: SalemoveSDK.LineCap = .butt, join: SalemoveSDK.LineJoin = .miter, dashes: [Swift.Double] = []) -> SalemoveSDK.Shape
  open func stroke(color: SalemoveSDK.Color, width: Swift.Double = 1, cap: SalemoveSDK.LineCap = .butt, join: SalemoveSDK.LineJoin = .miter, dashes: [Swift.Double] = []) -> SalemoveSDK.Shape
  open func stroke(color: Swift.Int, width: Swift.Double = 1, cap: SalemoveSDK.LineCap = .butt, join: SalemoveSDK.LineJoin = .miter, dashes: [Swift.Double] = []) -> SalemoveSDK.Shape
  open func toPath() -> SalemoveSDK.Path
  @objc deinit
}
final public class Atomic<Value> {
  final public var value: Value {
    get
    set(newValue)
  }
  public init(_ value: Value)
  @discardableResult
  final public func modify<Result>(_ action: (inout Value) throws -> Result) rethrows -> Result
  @discardableResult
  final public func withValue<Result>(_ action: (Value) throws -> Result) rethrows -> Result
  @discardableResult
  final public func swap(_ newValue: Value) -> Value
  @objc deinit
}
public struct MCAShapeLayerLineJoin {
}
public func >> (a: Swift.Double, b: Swift.Double) -> SalemoveSDK.OpacityAnimationDescription
public func >> (a: SalemoveSDK.Transform, b: SalemoveSDK.Transform) -> SalemoveSDK.TransformAnimationDescription
public func >> (a: SalemoveSDK.Locus, b: SalemoveSDK.Locus) -> SalemoveSDK.MorphingAnimationDescription
public protocol CachedResponseHandler {
  func dataTask(_ task: Foundation.URLSessionDataTask, willCacheResponse response: Foundation.CachedURLResponse, completion: @escaping (Foundation.CachedURLResponse?) -> Swift.Void)
}
public struct ResponseCacher {
  public enum Behavior {
    case cache
    case doNotCache
    case modify((Foundation.URLSessionDataTask, Foundation.CachedURLResponse) -> Foundation.CachedURLResponse?)
  }
  public static let cache: SalemoveSDK.ResponseCacher
  public static let doNotCache: SalemoveSDK.ResponseCacher
  public let behavior: SalemoveSDK.ResponseCacher.Behavior
  public init(behavior: SalemoveSDK.ResponseCacher.Behavior)
}
extension ResponseCacher : SalemoveSDK.CachedResponseHandler {
  public func dataTask(_ task: Foundation.URLSessionDataTask, willCacheResponse response: Foundation.CachedURLResponse, completion: @escaping (Foundation.CachedURLResponse?) -> Swift.Void)
}
@objc @_hasMissingDesignatedInitializers @objcMembers public class SingleChoiceOption : ObjectiveC.NSObject, Swift.Codable {
  @objc public var text: Swift.String?
  @objc public var value: Swift.String?
  @objc override dynamic public init()
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
public protocol PushNotificationConfigurable {
  func configurePushNotifications(_ notifications: [SalemoveSDK.PushNotificationType])
}
@objc public enum PushNotificationType : Swift.Int {
  case start
  case end
  case failed
  case message
  case transfer
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public struct AlamofireHTTPMethod : Swift.RawRepresentable, Swift.Equatable, Swift.Hashable {
  public static let connect: SalemoveSDK.AlamofireHTTPMethod
  public static let delete: SalemoveSDK.AlamofireHTTPMethod
  public static let get: SalemoveSDK.AlamofireHTTPMethod
  public static let head: SalemoveSDK.AlamofireHTTPMethod
  public static let options: SalemoveSDK.AlamofireHTTPMethod
  public static let patch: SalemoveSDK.AlamofireHTTPMethod
  public static let post: SalemoveSDK.AlamofireHTTPMethod
  public static let put: SalemoveSDK.AlamofireHTTPMethod
  public static let trace: SalemoveSDK.AlamofireHTTPMethod
  public let rawValue: Swift.String
  public init(rawValue: Swift.String)
  public typealias RawValue = Swift.String
}
public enum Relativity {
  case parent
  case scene
  case view
  public static func == (a: SalemoveSDK.Relativity, b: SalemoveSDK.Relativity) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct TouchPoint {
  public let id: Swift.Int
  @available(*, deprecated)
  public var location: SalemoveSDK.Point {
    get
  }
  public func location(in relativity: SalemoveSDK.Relativity = .parent) -> SalemoveSDK.Point
}
@_hasMissingDesignatedInitializers public class TouchEvent : SalemoveSDK.MacawEvent {
  final public let points: [SalemoveSDK.TouchPoint]
  public init(node: SalemoveSDK.Node, points: [SalemoveSDK.TouchPoint])
  @objc deinit
}
extension AlamofireHTTPMethod {
  public var supportsMultipart: Swift.Bool {
    get
  }
}
extension MoyaProvider {
  public func requestNormal(_ target: Target, callbackQueue: Dispatch.DispatchQueue?, progress: SalemoveSDK.MoyaProgressBlock?, completion: @escaping SalemoveSDK.MoyaCompletion) -> SalemoveSDK.Cancellable
  public func cancelCompletion(_ completion: (Swift.Result<SalemoveSDK.MoyaResponse, SalemoveSDK.MoyaError>) -> Swift.Void, target: Target)
  final public func createStubFunction(_ token: SalemoveSDK.CancellableToken, forTarget target: Target, withCompletion completion: @escaping SalemoveSDK.MoyaCompletion, endpoint: SalemoveSDK.Endpoint, plugins: [SalemoveSDK.PluginType], request: Foundation.URLRequest) -> (() -> Swift.Void)
  final public func notifyPluginsOfImpendingStub(for request: Foundation.URLRequest, target: Target) -> Foundation.URLRequest
}
public protocol RequestAdapter {
  func adapt(_ urlRequest: Foundation.URLRequest, for session: SalemoveSDK.AlamofireSession, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
}
public enum RetryResult {
  case retry
  case retryWithDelay(Foundation.TimeInterval)
  case doNotRetry
  case doNotRetryWithError(Swift.Error)
}
public protocol RequestRetrier {
  func retry(_ request: SalemoveSDK.AlamofireRequest, for session: SalemoveSDK.AlamofireSession, dueTo error: Swift.Error, completion: @escaping (SalemoveSDK.RetryResult) -> Swift.Void)
}
public protocol AlamofireRequestInterceptor : SalemoveSDK.RequestAdapter, SalemoveSDK.RequestRetrier {
}
extension AlamofireRequestInterceptor {
  public func adapt(_ urlRequest: Foundation.URLRequest, for session: SalemoveSDK.AlamofireSession, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  public func retry(_ request: SalemoveSDK.AlamofireRequest, for session: SalemoveSDK.AlamofireSession, dueTo error: Swift.Error, completion: @escaping (SalemoveSDK.RetryResult) -> Swift.Void)
}
public typealias AdaptHandler = (Foundation.URLRequest, SalemoveSDK.AlamofireSession, @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void) -> Swift.Void
public typealias RetryHandler = (SalemoveSDK.AlamofireRequest, SalemoveSDK.AlamofireSession, Swift.Error, @escaping (SalemoveSDK.RetryResult) -> Swift.Void) -> Swift.Void
open class Adapter : SalemoveSDK.AlamofireRequestInterceptor {
  public init(_ adaptHandler: @escaping SalemoveSDK.AdaptHandler)
  open func adapt(_ urlRequest: Foundation.URLRequest, for session: SalemoveSDK.AlamofireSession, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  @objc deinit
}
open class Retrier : SalemoveSDK.AlamofireRequestInterceptor {
  public init(_ retryHandler: @escaping SalemoveSDK.RetryHandler)
  open func retry(_ request: SalemoveSDK.AlamofireRequest, for session: SalemoveSDK.AlamofireSession, dueTo error: Swift.Error, completion: @escaping (SalemoveSDK.RetryResult) -> Swift.Void)
  @objc deinit
}
open class Interceptor : SalemoveSDK.AlamofireRequestInterceptor {
  final public let adapters: [SalemoveSDK.RequestAdapter]
  final public let retriers: [SalemoveSDK.RequestRetrier]
  public init(adaptHandler: @escaping SalemoveSDK.AdaptHandler, retryHandler: @escaping SalemoveSDK.RetryHandler)
  public init(adapter: SalemoveSDK.RequestAdapter, retrier: SalemoveSDK.RequestRetrier)
  public init(adapters: [SalemoveSDK.RequestAdapter] = [], retriers: [SalemoveSDK.RequestRetrier] = [], interceptors: [SalemoveSDK.AlamofireRequestInterceptor] = [])
  open func adapt(_ urlRequest: Foundation.URLRequest, for session: SalemoveSDK.AlamofireSession, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  open func retry(_ request: SalemoveSDK.AlamofireRequest, for session: SalemoveSDK.AlamofireSession, dueTo error: Swift.Error, completion: @escaping (SalemoveSDK.RetryResult) -> Swift.Void)
  @objc deinit
}
public typealias MoyaCompletion = (Swift.Result<SalemoveSDK.MoyaResponse, SalemoveSDK.MoyaError>) -> Swift.Void
public typealias MoyaProgressBlock = (SalemoveSDK.ProgressResponse) -> Swift.Void
public struct ProgressResponse {
  public let response: SalemoveSDK.MoyaResponse?
  public let progressObject: Foundation.Progress?
  public init(progress: Foundation.Progress? = nil, response: SalemoveSDK.MoyaResponse? = nil)
  public var progress: Swift.Double {
    get
  }
  public var completed: Swift.Bool {
    get
  }
}
public protocol MoyaProviderType : AnyObject {
  associatedtype Target : SalemoveSDK.TargetType
  func request(_ target: Self.Target, callbackQueue: Dispatch.DispatchQueue?, progress: SalemoveSDK.MoyaProgressBlock?, completion: @escaping SalemoveSDK.MoyaCompletion) -> SalemoveSDK.Cancellable
}
open class MoyaProvider<Target> : SalemoveSDK.MoyaProviderType where Target : SalemoveSDK.TargetType {
  public typealias EndpointClosure = (Target) -> SalemoveSDK.Endpoint
  public typealias RequestResultClosure = (Swift.Result<Foundation.URLRequest, SalemoveSDK.MoyaError>) -> Swift.Void
  public typealias RequestClosure = (SalemoveSDK.Endpoint, @escaping SalemoveSDK.MoyaProvider<Target>.RequestResultClosure) -> Swift.Void
  public typealias StubClosure = (Target) -> SalemoveSDK.MoyaStubBehavior
  final public let endpointClosure: SalemoveSDK.MoyaProvider<Target>.EndpointClosure
  final public let requestClosure: SalemoveSDK.MoyaProvider<Target>.RequestClosure
  final public let stubClosure: SalemoveSDK.MoyaProvider<Target>.StubClosure
  final public let session: SalemoveSDK.AlamofireSession
  final public let plugins: [SalemoveSDK.PluginType]
  final public let trackInflights: Swift.Bool
  open var inflightRequests: [SalemoveSDK.Endpoint : [SalemoveSDK.MoyaCompletion]] {
    get
  }
  public init(endpointClosure: @escaping SalemoveSDK.MoyaProvider<Target>.EndpointClosure = MoyaProvider.defaultEndpointMapping, requestClosure: @escaping SalemoveSDK.MoyaProvider<Target>.RequestClosure = MoyaProvider.defaultRequestMapping, stubClosure: @escaping SalemoveSDK.MoyaProvider<Target>.StubClosure = MoyaProvider.neverStub, callbackQueue: Dispatch.DispatchQueue? = nil, session: SalemoveSDK.AlamofireSession = MoyaProvider<Target>.defaultAlamofireSession(), plugins: [SalemoveSDK.PluginType] = [], trackInflights: Swift.Bool = false)
  open func endpoint(_ token: Target) -> SalemoveSDK.Endpoint
  @discardableResult
  open func request(_ target: Target, callbackQueue: Dispatch.DispatchQueue? = .none, progress: SalemoveSDK.MoyaProgressBlock? = .none, completion: @escaping SalemoveSDK.MoyaCompletion) -> SalemoveSDK.Cancellable
  @discardableResult
  open func stubRequest(_ target: Target, request: Foundation.URLRequest, callbackQueue: Dispatch.DispatchQueue?, completion: @escaping SalemoveSDK.MoyaCompletion, endpoint: SalemoveSDK.Endpoint, stubBehavior: SalemoveSDK.MoyaStubBehavior) -> SalemoveSDK.CancellableToken
  @objc deinit
}
public enum MoyaStubBehavior {
  case never
  case immediate
  case delayed(seconds: Foundation.TimeInterval)
}
extension MoyaProvider {
  final public class func neverStub(_: Target) -> SalemoveSDK.MoyaStubBehavior
  final public class func immediatelyStub(_: Target) -> SalemoveSDK.MoyaStubBehavior
  final public class func delayedStub(_ seconds: Foundation.TimeInterval) -> (Target) -> SalemoveSDK.MoyaStubBehavior
}
public func convertResponseToResult(_ response: Foundation.HTTPURLResponse?, request: Foundation.URLRequest?, data: Foundation.Data?, error: Swift.Error?) -> Swift.Result<SalemoveSDK.MoyaResponse, SalemoveSDK.MoyaError>
final public class Presence {
  public struct Options {
    public static let defaults: SalemoveSDK.Presence.Options
  }
  public enum Events : Swift.String {
    case state
    case diff
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public typealias Meta = [Swift.String : Any]
  public typealias Map = [Swift.String : [SalemoveSDK.Presence.Meta]]
  public typealias State = [Swift.String : SalemoveSDK.Presence.Map]
  public typealias Diff = [Swift.String : SalemoveSDK.Presence.State]
  public typealias OnJoin = (Swift.String, SalemoveSDK.Presence.Map?, SalemoveSDK.Presence.Map) -> Swift.Void
  public typealias OnLeave = (Swift.String, SalemoveSDK.Presence.Map, SalemoveSDK.Presence.Map) -> Swift.Void
  public typealias OnSync = () -> Swift.Void
  final public var state: SalemoveSDK.Presence.State {
    get
  }
  final public var pendingDiffs: [SalemoveSDK.Presence.Diff] {
    get
  }
  final public var joinRef: Swift.String? {
    get
  }
  final public var isPendingSyncState: Swift.Bool {
    get
  }
  final public var onJoin: SalemoveSDK.Presence.OnJoin {
    get
    set
  }
  final public func onJoin(_ callback: @escaping SalemoveSDK.Presence.OnJoin)
  final public var onLeave: SalemoveSDK.Presence.OnLeave {
    get
    set
  }
  final public func onLeave(_ callback: @escaping SalemoveSDK.Presence.OnLeave)
  final public var onSync: SalemoveSDK.Presence.OnSync {
    get
    set
  }
  final public func onSync(_ callback: @escaping SalemoveSDK.Presence.OnSync)
  public init(channel: SalemoveSDK.SwiftPhoenixClientChannel, opts: SalemoveSDK.Presence.Options = Options.defaults)
  final public func list() -> [SalemoveSDK.Presence.Map]
  final public func list<T>(by transformer: (Swift.String, SalemoveSDK.Presence.Map) -> T) -> [T]
  final public func filter(by filter: ((Swift.String, SalemoveSDK.Presence.Map) -> Swift.Bool)?) -> SalemoveSDK.Presence.State
  @discardableResult
  public static func syncState(_ currentState: SalemoveSDK.Presence.State, newState: SalemoveSDK.Presence.State, onJoin: (Swift.String, SalemoveSDK.Presence.Map?, SalemoveSDK.Presence.Map) -> Swift.Void = {_,_,_ in }, onLeave: (Swift.String, SalemoveSDK.Presence.Map, SalemoveSDK.Presence.Map) -> Swift.Void = {_,_,_ in }) -> SalemoveSDK.Presence.State
  @discardableResult
  public static func syncDiff(_ currentState: SalemoveSDK.Presence.State, diff: SalemoveSDK.Presence.Diff, onJoin: (Swift.String, SalemoveSDK.Presence.Map?, SalemoveSDK.Presence.Map) -> Swift.Void = {_,_,_ in }, onLeave: (Swift.String, SalemoveSDK.Presence.Map, SalemoveSDK.Presence.Map) -> Swift.Void = {_,_,_ in }) -> SalemoveSDK.Presence.State
  public static func filter(_ presences: SalemoveSDK.Presence.State, by filter: ((Swift.String, SalemoveSDK.Presence.Map) -> Swift.Bool)?) -> SalemoveSDK.Presence.State
  public static func listBy<T>(_ presences: SalemoveSDK.Presence.State, transformer: (Swift.String, SalemoveSDK.Presence.Map) -> T) -> [T]
  @objc deinit
}
@_hasMissingDesignatedInitializers @objc public class QueueTicket : ObjectiveC.NSObject {
  @objc override dynamic public init()
  @objc deinit
}
@objc public protocol EngagementHandling {
  @objc func start()
  @objc func end()
  @objc var onEngagementRequest: SalemoveSDK.RequestOfferBlock { get }
  @objc var onEngagementTransfer: SalemoveSDK.EngagementTransferBlock { get }
}
@objc public protocol MessageHandling {
  @objc func receive(message: SalemoveSDK.Message)
  @objc var onOperatorTypingStatusUpdate: SalemoveSDK.OperatorTypingStatusUpdate { get }
  @objc var onMessagesUpdated: SalemoveSDK.MessagesUpdateBlock { get }
}
@objc public protocol MediaHandling {
  @objc var onMediaUpgradeOffer: SalemoveSDK.MediaUgradeOfferBlock { get }
  @objc var onScreenSharingOffer: SalemoveSDK.ScreenshareOfferBlock { get }
  @objc var onVideoStreamAdded: SalemoveSDK.VideoStreamAddedBlock { get }
  @objc var onAudioStreamAdded: SalemoveSDK.AudioStreamAddedBlock { get }
  @objc var onVisitorScreenSharingStateChange: SalemoveSDK.VisitorScreenSharingStateChange { get }
}
@objc public protocol ErrorHandling {
  @objc func fail(error: SalemoveSDK.SalemoveError)
}
@objc public protocol Interactable : SalemoveSDK.EngagementHandling, SalemoveSDK.ErrorHandling, SalemoveSDK.MediaHandling, SalemoveSDK.MessageHandling {
}
@objc @_hasMissingDesignatedInitializers final public class SocketAnyEvent : ObjectiveC.NSObject {
  final public let event: Swift.String
  final public let items: [Any]?
  @objc override final public var description: Swift.String {
    @objc get
  }
  @objc override dynamic public init()
  @objc deinit
}
public struct AlamofireExtension<ExtendedType> {
  public var type: ExtendedType {
    get
  }
  public init(_ type: ExtendedType)
}
public protocol AlamofireExtended {
  associatedtype ExtendedType
  static var af: SalemoveSDK.AlamofireExtension<Self.ExtendedType>.Type { get set }
  var af: SalemoveSDK.AlamofireExtension<Self.ExtendedType> { get set }
}
extension AlamofireExtended {
  public static var af: SalemoveSDK.AlamofireExtension<Self>.Type {
    get
    set
  }
  public var af: SalemoveSDK.AlamofireExtension<Self> {
    get
    set
  }
}
public enum LineJoin {
  case miter
  case round
  case bevel
  public static func == (a: SalemoveSDK.LineJoin, b: SalemoveSDK.LineJoin) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
open class AlamofireMultipartFormData {
  public static let encodingMemoryThreshold: Swift.UInt64
  open var contentType: Swift.String {
    get
    set
  }
  public var contentLength: Swift.UInt64 {
    get
  }
  final public let boundary: Swift.String
  public init(fileManager: Foundation.FileManager = .default, boundary: Swift.String? = nil)
  public func append(_ data: Foundation.Data, withName name: Swift.String, fileName: Swift.String? = nil, mimeType: Swift.String? = nil)
  public func append(_ fileURL: Foundation.URL, withName name: Swift.String)
  public func append(_ fileURL: Foundation.URL, withName name: Swift.String, fileName: Swift.String, mimeType: Swift.String)
  public func append(_ stream: Foundation.InputStream, withLength length: Swift.UInt64, name: Swift.String, fileName: Swift.String, mimeType: Swift.String)
  public func append(_ stream: Foundation.InputStream, withLength length: Swift.UInt64, headers: SalemoveSDK.HTTPHeaders)
  public func encode() throws -> Foundation.Data
  public func writeEncodedData(to fileURL: Foundation.URL) throws
  @objc deinit
}
final public class Action<Input, Output, Error> where Error : Swift.Error {
  final public let lifetime: SalemoveSDK.Lifetime
  final public let events: SalemoveSDK.Signal<SalemoveSDK.Signal<Output, Error>.Event, Swift.Never>
  final public let values: SalemoveSDK.Signal<Output, Swift.Never>
  final public let errors: SalemoveSDK.Signal<Error, Swift.Never>
  final public let disabledErrors: SalemoveSDK.Signal<(), Swift.Never>
  final public let completed: SalemoveSDK.Signal<(), Swift.Never>
  final public let isExecuting: SalemoveSDK.Property<Swift.Bool>
  final public let isEnabled: SalemoveSDK.Property<Swift.Bool>
  public init<State>(state: State, enabledIf isEnabled: @escaping (State.Value) -> Swift.Bool, execute: @escaping (State.Value, Input) -> SalemoveSDK.SignalProducer<Output, Error>) where State : SalemoveSDK.PropertyProtocol
  convenience public init<P>(state: P, execute: @escaping (P.Value, Input) -> SalemoveSDK.SignalProducer<Output, Error>) where P : SalemoveSDK.PropertyProtocol
  convenience public init<P>(enabledIf isEnabled: P, execute: @escaping (Input) -> SalemoveSDK.SignalProducer<Output, Error>) where P : SalemoveSDK.PropertyProtocol, P.Value == Swift.Bool
  convenience public init<P, T>(unwrapping state: P, execute: @escaping (T, Input) -> SalemoveSDK.SignalProducer<Output, Error>) where P : SalemoveSDK.PropertyProtocol, P.Value == T?
  convenience public init<T, E>(validated state: SalemoveSDK.ValidatingProperty<T, E>, execute: @escaping (T, Input) -> SalemoveSDK.SignalProducer<Output, Error>) where E : Swift.Error
  convenience public init(execute: @escaping (Input) -> SalemoveSDK.SignalProducer<Output, Error>)
  @objc deinit
  final public func apply(_ input: Input) -> SalemoveSDK.SignalProducer<Output, SalemoveSDK.ActionError<Error>>
}
extension Action : SalemoveSDK.BindingTargetProvider {
  final public var bindingTarget: SalemoveSDK.BindingTarget<Input> {
    get
  }
  public typealias Value = Input
}
extension Action where Input == Swift.Void {
  final public func apply() -> SalemoveSDK.SignalProducer<Output, SalemoveSDK.ActionError<Error>>
  convenience public init<P, T>(unwrapping state: P, execute: @escaping (T) -> SalemoveSDK.SignalProducer<Output, Error>) where P : SalemoveSDK.PropertyProtocol, P.Value == T?
  convenience public init<T, E>(validated state: SalemoveSDK.ValidatingProperty<T, E>, execute: @escaping (T) -> SalemoveSDK.SignalProducer<Output, Error>) where E : Swift.Error
  convenience public init<P, T>(state: P, execute: @escaping (T) -> SalemoveSDK.SignalProducer<Output, Error>) where P : SalemoveSDK.PropertyProtocol, T == P.Value
}
public enum ActionError<Error> : Swift.Error where Error : Swift.Error {
  case disabled
  case producerFailed(Error)
}
extension ActionError where Error : Swift.Equatable {
  public static func == (lhs: SalemoveSDK.ActionError<Error>, rhs: SalemoveSDK.ActionError<Error>) -> Swift.Bool
}
extension ActionError : Swift.Equatable where Error : Swift.Equatable {
}
public protocol SocketEnginePollable : SalemoveSDK.SocketEngineSpec {
  var invalidated: Swift.Bool { get }
  var postWait: [Swift.String] { get set }
  var session: Foundation.URLSession? { get }
  var waitingForPoll: Swift.Bool { get set }
  var waitingForPost: Swift.Bool { get set }
  func doPoll()
  func sendPollMessage(_ message: Swift.String, withType type: SalemoveSDK.SocketEnginePacketType, withData datas: [Foundation.Data])
  func stopPolling()
}
extension SocketEnginePollable {
  public func doPoll()
  public func sendPollMessage(_ message: Swift.String, withType type: SalemoveSDK.SocketEnginePacketType, withData datas: [Foundation.Data])
  public func stopPolling()
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers open class AnimatableVariable<T> : SalemoveSDK.Variable<T> {
  @objc deinit
}
public protocol Interpolable {
  func interpolate(_ endValue: Self, progress: Swift.Double) -> Self
}
@_hasMissingDesignatedInitializers @objc public class Message : ObjectiveC.NSObject {
  @objc public var id: Swift.String {
    get
  }
  @objc public var content: Swift.String {
    get
  }
  @objc public var attachment: SalemoveSDK.Attachment? {
    get
  }
  public var sender: SalemoveSDK.MessageSender {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
public enum MessageSender {
  case visitor
  case `operator`
  case omniguide
  case system
  public static func == (a: SalemoveSDK.MessageSender, b: SalemoveSDK.MessageSender) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol SocketLogger : AnyObject {
  var log: Swift.Bool { get set }
  func log(_ message: Swift.String, type: Swift.String, args: Any...)
  func error(_ message: Swift.String, type: Swift.String, args: Any...)
}
extension SocketLogger {
  public func log(_ message: Swift.String, type: Swift.String, args: Any...)
  public func error(_ message: Swift.String, type: Swift.String, args: Any...)
}
final public class Signal<Value, Error> where Error : Swift.Error {
  public init(_ generator: (SalemoveSDK.Signal<Value, Error>.Observer, SalemoveSDK.Lifetime) -> Swift.Void)
  @discardableResult
  final public func observe(_ observer: SalemoveSDK.Signal<Value, Error>.Observer) -> SalemoveSDK.Disposable?
  @objc deinit
}
extension Signal {
  public static var never: SalemoveSDK.Signal<Value, Error> {
    get
  }
  public static var empty: SalemoveSDK.Signal<Value, Error> {
    get
  }
  public static func pipe(disposable: SalemoveSDK.Disposable? = nil) -> (output: SalemoveSDK.Signal<Value, Error>, input: SalemoveSDK.Signal<Value, Error>.Observer)
}
public protocol SignalProtocol : AnyObject {
  associatedtype Value
  associatedtype Error : Swift.Error
  var signal: SalemoveSDK.Signal<Self.Value, Self.Error> { get }
}
extension Signal : SalemoveSDK.SignalProtocol {
  final public var signal: SalemoveSDK.Signal<Value, Error> {
    get
  }
}
extension Signal : SalemoveSDK.SignalProducerConvertible {
  final public var producer: SalemoveSDK.SignalProducer<Value, Error> {
    get
  }
}
extension Signal {
  @discardableResult
  final public func observe(_ action: @escaping SalemoveSDK.Signal<Value, Error>.Observer.Action) -> SalemoveSDK.Disposable?
  @discardableResult
  final public func observeResult(_ action: @escaping (Swift.Result<Value, Error>) -> Swift.Void) -> SalemoveSDK.Disposable?
  @discardableResult
  final public func observeCompleted(_ action: @escaping () -> Swift.Void) -> SalemoveSDK.Disposable?
  @discardableResult
  final public func observeFailed(_ action: @escaping (Error) -> Swift.Void) -> SalemoveSDK.Disposable?
  @discardableResult
  final public func observeInterrupted(_ action: @escaping () -> Swift.Void) -> SalemoveSDK.Disposable?
}
extension Signal where Error == Swift.Never {
  @discardableResult
  final public func observeValues(_ action: @escaping (Value) -> Swift.Void) -> SalemoveSDK.Disposable?
}
extension Signal {
  final public func map<U>(_ transform: @escaping (Value) -> U) -> SalemoveSDK.Signal<U, Error>
  final public func map<U>(value: U) -> SalemoveSDK.Signal<U, Error>
  final public func map<U>(_ keyPath: Swift.KeyPath<Value, U>) -> SalemoveSDK.Signal<U, Error>
  final public func mapError<F>(_ transform: @escaping (Error) -> F) -> SalemoveSDK.Signal<Value, F> where F : Swift.Error
  final public func lazyMap<U>(on scheduler: SalemoveSDK.Scheduler, transform: @escaping (Value) -> U) -> SalemoveSDK.Signal<U, Error>
  final public func filter(_ isIncluded: @escaping (Value) -> Swift.Bool) -> SalemoveSDK.Signal<Value, Error>
  final public func compactMap<U>(_ transform: @escaping (Value) -> U?) -> SalemoveSDK.Signal<U, Error>
  @available(*, deprecated, renamed: "compactMap")
  final public func filterMap<U>(_ transform: @escaping (Value) -> U?) -> SalemoveSDK.Signal<U, Error>
}
extension Signal where Value : SalemoveSDK.OptionalProtocol {
  final public func skipNil() -> SalemoveSDK.Signal<Value.Wrapped, Error>
}
extension Signal {
  final public func take(first count: Swift.Int) -> SalemoveSDK.Signal<Value, Error>
  final public func collect() -> SalemoveSDK.Signal<[Value], Error>
  final public func collect(count: Swift.Int) -> SalemoveSDK.Signal<[Value], Error>
  final public func collect(_ shouldEmit: @escaping ([Value]) -> Swift.Bool) -> SalemoveSDK.Signal<[Value], Error>
  final public func collect(_ shouldEmit: @escaping ([Value], Value) -> Swift.Bool) -> SalemoveSDK.Signal<[Value], Error>
  final public func collect(every interval: Dispatch.DispatchTimeInterval, on scheduler: SalemoveSDK.DateScheduler, skipEmpty: Swift.Bool = false, discardWhenCompleted: Swift.Bool = true) -> SalemoveSDK.Signal<[Value], Error>
  final public func observe(on scheduler: SalemoveSDK.Scheduler) -> SalemoveSDK.Signal<Value, Error>
}
extension Signal {
  final public func combineLatest<U>(with other: SalemoveSDK.Signal<U, Error>) -> SalemoveSDK.Signal<(Value, U), Error>
  final public func merge(with other: SalemoveSDK.Signal<Value, Error>) -> SalemoveSDK.Signal<Value, Error>
  final public func delay(_ interval: Foundation.TimeInterval, on scheduler: SalemoveSDK.DateScheduler) -> SalemoveSDK.Signal<Value, Error>
  final public func skip(first count: Swift.Int) -> SalemoveSDK.Signal<Value, Error>
  final public func materialize() -> SalemoveSDK.Signal<SalemoveSDK.Signal<Value, Error>.Event, Swift.Never>
  final public func materializeResults() -> SalemoveSDK.Signal<Swift.Result<Value, Error>, Swift.Never>
}
extension Signal where Value : SalemoveSDK.EventProtocol, Error == Swift.Never {
  final public func dematerialize() -> SalemoveSDK.Signal<Value.Value, Value.Error>
}
extension Signal where Error == Swift.Never {
  final public func dematerializeResults<Success, Failure>() -> SalemoveSDK.Signal<Success, Failure> where Value == Swift.Result<Success, Failure>, Failure : Swift.Error
}
extension Signal {
  final public func on(event: ((SalemoveSDK.Signal<Value, Error>.Event) -> Swift.Void)? = nil, failed: ((Error) -> Swift.Void)? = nil, completed: (() -> Swift.Void)? = nil, interrupted: (() -> Swift.Void)? = nil, terminated: (() -> Swift.Void)? = nil, disposed: (() -> Swift.Void)? = nil, value: ((Value) -> Swift.Void)? = nil) -> SalemoveSDK.Signal<Value, Error>
}
extension Signal {
  final public func sample<T>(with sampler: SalemoveSDK.Signal<T, Swift.Never>) -> SalemoveSDK.Signal<(Value, T), Error>
  final public func sample(on sampler: SalemoveSDK.Signal<(), Swift.Never>) -> SalemoveSDK.Signal<Value, Error>
  final public func withLatest<U>(from samplee: SalemoveSDK.Signal<U, Swift.Never>) -> SalemoveSDK.Signal<(Value, U), Error>
  final public func withLatest<U>(from samplee: SalemoveSDK.SignalProducer<U, Swift.Never>) -> SalemoveSDK.Signal<(Value, U), Error>
  final public func withLatest<Samplee>(from samplee: Samplee) -> SalemoveSDK.Signal<(Value, Samplee.Value), Error> where Samplee : SalemoveSDK.SignalProducerConvertible, Samplee.Error == Swift.Never
}
extension Signal {
  final public func take(during lifetime: SalemoveSDK.Lifetime) -> SalemoveSDK.Signal<Value, Error>
  final public func take(until trigger: SalemoveSDK.Signal<(), Swift.Never>) -> SalemoveSDK.Signal<Value, Error>
  final public func skip(until trigger: SalemoveSDK.Signal<(), Swift.Never>) -> SalemoveSDK.Signal<Value, Error>
  final public func combinePrevious(_ initial: Value) -> SalemoveSDK.Signal<(Value, Value), Error>
  final public func combinePrevious() -> SalemoveSDK.Signal<(Value, Value), Error>
  final public func reduce<U>(_ initialResult: U, _ nextPartialResult: @escaping (U, Value) -> U) -> SalemoveSDK.Signal<U, Error>
  final public func reduce<U>(into initialResult: U, _ nextPartialResult: @escaping (inout U, Value) -> Swift.Void) -> SalemoveSDK.Signal<U, Error>
  final public func scan<U>(_ initialResult: U, _ nextPartialResult: @escaping (U, Value) -> U) -> SalemoveSDK.Signal<U, Error>
  final public func scan<U>(into initialResult: U, _ nextPartialResult: @escaping (inout U, Value) -> Swift.Void) -> SalemoveSDK.Signal<U, Error>
  final public func scanMap<State, U>(_ initialState: State, _ next: @escaping (State, Value) -> (State, U)) -> SalemoveSDK.Signal<U, Error>
  final public func scanMap<State, U>(into initialState: State, _ next: @escaping (inout State, Value) -> U) -> SalemoveSDK.Signal<U, Error>
}
extension Signal where Value : Swift.Equatable {
  final public func skipRepeats() -> SalemoveSDK.Signal<Value, Error>
}
extension Signal {
  final public func skipRepeats(_ isEquivalent: @escaping (Value, Value) -> Swift.Bool) -> SalemoveSDK.Signal<Value, Error>
  final public func skip(while shouldContinue: @escaping (Value) -> Swift.Bool) -> SalemoveSDK.Signal<Value, Error>
  final public func take(untilReplacement signal: SalemoveSDK.Signal<Value, Error>) -> SalemoveSDK.Signal<Value, Error>
  final public func take(last count: Swift.Int) -> SalemoveSDK.Signal<Value, Error>
  final public func take(while shouldContinue: @escaping (Value) -> Swift.Bool) -> SalemoveSDK.Signal<Value, Error>
}
extension Signal {
  final public func zip<U>(with other: SalemoveSDK.Signal<U, Error>) -> SalemoveSDK.Signal<(Value, U), Error>
  final public func throttle(_ interval: Foundation.TimeInterval, on scheduler: SalemoveSDK.DateScheduler) -> SalemoveSDK.Signal<Value, Error>
  final public func throttle<P>(while shouldThrottle: P, on scheduler: SalemoveSDK.Scheduler) -> SalemoveSDK.Signal<Value, Error> where P : SalemoveSDK.PropertyProtocol, P.Value == Swift.Bool
  final public func debounce(_ interval: Foundation.TimeInterval, on scheduler: SalemoveSDK.DateScheduler, discardWhenCompleted: Swift.Bool = true) -> SalemoveSDK.Signal<Value, Error>
}
extension Signal {
  final public func uniqueValues<Identity>(_ transform: @escaping (Value) -> Identity) -> SalemoveSDK.Signal<Value, Error> where Identity : Swift.Hashable
}
extension Signal where Value : Swift.Hashable {
  final public func uniqueValues() -> SalemoveSDK.Signal<Value, Error>
}
extension Signal {
  public static func combineLatest<B>(_ a: SalemoveSDK.Signal<Value, Error>, _ b: SalemoveSDK.Signal<B, Error>) -> SalemoveSDK.Signal<(Value, B), Error>
  public static func combineLatest<B, C>(_ a: SalemoveSDK.Signal<Value, Error>, _ b: SalemoveSDK.Signal<B, Error>, _ c: SalemoveSDK.Signal<C, Error>) -> SalemoveSDK.Signal<(Value, B, C), Error>
  public static func combineLatest<B, C, D>(_ a: SalemoveSDK.Signal<Value, Error>, _ b: SalemoveSDK.Signal<B, Error>, _ c: SalemoveSDK.Signal<C, Error>, _ d: SalemoveSDK.Signal<D, Error>) -> SalemoveSDK.Signal<(Value, B, C, D), Error>
  public static func combineLatest<B, C, D, E>(_ a: SalemoveSDK.Signal<Value, Error>, _ b: SalemoveSDK.Signal<B, Error>, _ c: SalemoveSDK.Signal<C, Error>, _ d: SalemoveSDK.Signal<D, Error>, _ e: SalemoveSDK.Signal<E, Error>) -> SalemoveSDK.Signal<(Value, B, C, D, E), Error>
  public static func combineLatest<B, C, D, E, F>(_ a: SalemoveSDK.Signal<Value, Error>, _ b: SalemoveSDK.Signal<B, Error>, _ c: SalemoveSDK.Signal<C, Error>, _ d: SalemoveSDK.Signal<D, Error>, _ e: SalemoveSDK.Signal<E, Error>, _ f: SalemoveSDK.Signal<F, Error>) -> SalemoveSDK.Signal<(Value, B, C, D, E, F), Error>
  public static func combineLatest<B, C, D, E, F, G>(_ a: SalemoveSDK.Signal<Value, Error>, _ b: SalemoveSDK.Signal<B, Error>, _ c: SalemoveSDK.Signal<C, Error>, _ d: SalemoveSDK.Signal<D, Error>, _ e: SalemoveSDK.Signal<E, Error>, _ f: SalemoveSDK.Signal<F, Error>, _ g: SalemoveSDK.Signal<G, Error>) -> SalemoveSDK.Signal<(Value, B, C, D, E, F, G), Error>
  public static func combineLatest<B, C, D, E, F, G, H>(_ a: SalemoveSDK.Signal<Value, Error>, _ b: SalemoveSDK.Signal<B, Error>, _ c: SalemoveSDK.Signal<C, Error>, _ d: SalemoveSDK.Signal<D, Error>, _ e: SalemoveSDK.Signal<E, Error>, _ f: SalemoveSDK.Signal<F, Error>, _ g: SalemoveSDK.Signal<G, Error>, _ h: SalemoveSDK.Signal<H, Error>) -> SalemoveSDK.Signal<(Value, B, C, D, E, F, G, H), Error>
  public static func combineLatest<B, C, D, E, F, G, H, I>(_ a: SalemoveSDK.Signal<Value, Error>, _ b: SalemoveSDK.Signal<B, Error>, _ c: SalemoveSDK.Signal<C, Error>, _ d: SalemoveSDK.Signal<D, Error>, _ e: SalemoveSDK.Signal<E, Error>, _ f: SalemoveSDK.Signal<F, Error>, _ g: SalemoveSDK.Signal<G, Error>, _ h: SalemoveSDK.Signal<H, Error>, _ i: SalemoveSDK.Signal<I, Error>) -> SalemoveSDK.Signal<(Value, B, C, D, E, F, G, H, I), Error>
  public static func combineLatest<B, C, D, E, F, G, H, I, J>(_ a: SalemoveSDK.Signal<Value, Error>, _ b: SalemoveSDK.Signal<B, Error>, _ c: SalemoveSDK.Signal<C, Error>, _ d: SalemoveSDK.Signal<D, Error>, _ e: SalemoveSDK.Signal<E, Error>, _ f: SalemoveSDK.Signal<F, Error>, _ g: SalemoveSDK.Signal<G, Error>, _ h: SalemoveSDK.Signal<H, Error>, _ i: SalemoveSDK.Signal<I, Error>, _ j: SalemoveSDK.Signal<J, Error>) -> SalemoveSDK.Signal<(Value, B, C, D, E, F, G, H, I, J), Error>
  public static func combineLatest<S>(_ signals: S) -> SalemoveSDK.Signal<[Value], Error> where S : Swift.Sequence, S.Element == SalemoveSDK.Signal<Value, Error>
  public static func zip<B>(_ a: SalemoveSDK.Signal<Value, Error>, _ b: SalemoveSDK.Signal<B, Error>) -> SalemoveSDK.Signal<(Value, B), Error>
  public static func zip<B, C>(_ a: SalemoveSDK.Signal<Value, Error>, _ b: SalemoveSDK.Signal<B, Error>, _ c: SalemoveSDK.Signal<C, Error>) -> SalemoveSDK.Signal<(Value, B, C), Error>
  public static func zip<B, C, D>(_ a: SalemoveSDK.Signal<Value, Error>, _ b: SalemoveSDK.Signal<B, Error>, _ c: SalemoveSDK.Signal<C, Error>, _ d: SalemoveSDK.Signal<D, Error>) -> SalemoveSDK.Signal<(Value, B, C, D), Error>
  public static func zip<B, C, D, E>(_ a: SalemoveSDK.Signal<Value, Error>, _ b: SalemoveSDK.Signal<B, Error>, _ c: SalemoveSDK.Signal<C, Error>, _ d: SalemoveSDK.Signal<D, Error>, _ e: SalemoveSDK.Signal<E, Error>) -> SalemoveSDK.Signal<(Value, B, C, D, E), Error>
  public static func zip<B, C, D, E, F>(_ a: SalemoveSDK.Signal<Value, Error>, _ b: SalemoveSDK.Signal<B, Error>, _ c: SalemoveSDK.Signal<C, Error>, _ d: SalemoveSDK.Signal<D, Error>, _ e: SalemoveSDK.Signal<E, Error>, _ f: SalemoveSDK.Signal<F, Error>) -> SalemoveSDK.Signal<(Value, B, C, D, E, F), Error>
  public static func zip<B, C, D, E, F, G>(_ a: SalemoveSDK.Signal<Value, Error>, _ b: SalemoveSDK.Signal<B, Error>, _ c: SalemoveSDK.Signal<C, Error>, _ d: SalemoveSDK.Signal<D, Error>, _ e: SalemoveSDK.Signal<E, Error>, _ f: SalemoveSDK.Signal<F, Error>, _ g: SalemoveSDK.Signal<G, Error>) -> SalemoveSDK.Signal<(Value, B, C, D, E, F, G), Error>
  public static func zip<B, C, D, E, F, G, H>(_ a: SalemoveSDK.Signal<Value, Error>, _ b: SalemoveSDK.Signal<B, Error>, _ c: SalemoveSDK.Signal<C, Error>, _ d: SalemoveSDK.Signal<D, Error>, _ e: SalemoveSDK.Signal<E, Error>, _ f: SalemoveSDK.Signal<F, Error>, _ g: SalemoveSDK.Signal<G, Error>, _ h: SalemoveSDK.Signal<H, Error>) -> SalemoveSDK.Signal<(Value, B, C, D, E, F, G, H), Error>
  public static func zip<B, C, D, E, F, G, H, I>(_ a: SalemoveSDK.Signal<Value, Error>, _ b: SalemoveSDK.Signal<B, Error>, _ c: SalemoveSDK.Signal<C, Error>, _ d: SalemoveSDK.Signal<D, Error>, _ e: SalemoveSDK.Signal<E, Error>, _ f: SalemoveSDK.Signal<F, Error>, _ g: SalemoveSDK.Signal<G, Error>, _ h: SalemoveSDK.Signal<H, Error>, _ i: SalemoveSDK.Signal<I, Error>) -> SalemoveSDK.Signal<(Value, B, C, D, E, F, G, H, I), Error>
  public static func zip<B, C, D, E, F, G, H, I, J>(_ a: SalemoveSDK.Signal<Value, Error>, _ b: SalemoveSDK.Signal<B, Error>, _ c: SalemoveSDK.Signal<C, Error>, _ d: SalemoveSDK.Signal<D, Error>, _ e: SalemoveSDK.Signal<E, Error>, _ f: SalemoveSDK.Signal<F, Error>, _ g: SalemoveSDK.Signal<G, Error>, _ h: SalemoveSDK.Signal<H, Error>, _ i: SalemoveSDK.Signal<I, Error>, _ j: SalemoveSDK.Signal<J, Error>) -> SalemoveSDK.Signal<(Value, B, C, D, E, F, G, H, I, J), Error>
  public static func zip<S>(_ signals: S) -> SalemoveSDK.Signal<[Value], Error> where S : Swift.Sequence, S.Element == SalemoveSDK.Signal<Value, Error>
}
extension Signal {
  final public func timeout(after interval: Foundation.TimeInterval, raising error: Error, on scheduler: SalemoveSDK.DateScheduler) -> SalemoveSDK.Signal<Value, Error>
}
extension Signal where Error == Swift.Never {
  final public func promoteError<F>(_: F.Type = F.self) -> SalemoveSDK.Signal<Value, F> where F : Swift.Error
  final public func promoteError(_: Error.Type = Error.self) -> SalemoveSDK.Signal<Value, Error>
  final public func timeout<NewError>(after interval: Foundation.TimeInterval, raising error: NewError, on scheduler: SalemoveSDK.DateScheduler) -> SalemoveSDK.Signal<Value, NewError> where NewError : Swift.Error
}
extension Signal where Value == Swift.Never {
  final public func promoteValue<U>(_: U.Type = U.self) -> SalemoveSDK.Signal<U, Error>
  final public func promoteValue(_: Value.Type = Value.self) -> SalemoveSDK.Signal<Value, Error>
}
extension Signal where Value == Swift.Bool {
  final public func negate() -> SalemoveSDK.Signal<Value, Error>
  final public func and(_ signal: SalemoveSDK.Signal<Value, Error>) -> SalemoveSDK.Signal<Value, Error>
  public static func all<BooleansCollection>(_ booleans: BooleansCollection) -> SalemoveSDK.Signal<Value, Error> where BooleansCollection : Swift.Collection, BooleansCollection.Element == SalemoveSDK.Signal<Swift.Bool, Error>
  public static func all(_ booleans: SalemoveSDK.Signal<Value, Error>...) -> SalemoveSDK.Signal<Value, Error>
  final public func or(_ signal: SalemoveSDK.Signal<Value, Error>) -> SalemoveSDK.Signal<Value, Error>
  public static func any<BooleansCollection>(_ booleans: BooleansCollection) -> SalemoveSDK.Signal<Value, Error> where BooleansCollection : Swift.Collection, BooleansCollection.Element == SalemoveSDK.Signal<Swift.Bool, Error>
  public static func any(_ booleans: SalemoveSDK.Signal<Value, Error>...) -> SalemoveSDK.Signal<Value, Error>
}
extension Signal {
  final public func attempt(_ action: @escaping (Value) -> Swift.Result<(), Error>) -> SalemoveSDK.Signal<Value, Error>
  final public func attemptMap<U>(_ transform: @escaping (Value) -> Swift.Result<U, Error>) -> SalemoveSDK.Signal<U, Error>
}
extension Signal where Error == Swift.Never {
  final public func attempt(_ action: @escaping (Value) throws -> Swift.Void) -> SalemoveSDK.Signal<Value, Swift.Error>
  final public func attemptMap<U>(_ transform: @escaping (Value) throws -> U) -> SalemoveSDK.Signal<U, Swift.Error>
}
extension Signal where Error == Swift.Error {
  final public func attempt(_ action: @escaping (Value) throws -> Swift.Void) -> SalemoveSDK.Signal<Value, Error>
  final public func attemptMap<U>(_ transform: @escaping (Value) throws -> U) -> SalemoveSDK.Signal<U, Error>
}
public protocol RedirectHandler {
  func task(_ task: Foundation.URLSessionTask, willBeRedirectedTo request: Foundation.URLRequest, for response: Foundation.HTTPURLResponse, completion: @escaping (Foundation.URLRequest?) -> Swift.Void)
}
public struct Redirector {
  public enum Behavior {
    case follow
    case doNotFollow
    case modify((Foundation.URLSessionTask, Foundation.URLRequest, Foundation.HTTPURLResponse) -> Foundation.URLRequest?)
  }
  public static let follow: SalemoveSDK.Redirector
  public static let doNotFollow: SalemoveSDK.Redirector
  public let behavior: SalemoveSDK.Redirector.Behavior
  public init(behavior: SalemoveSDK.Redirector.Behavior)
}
extension Redirector : SalemoveSDK.RedirectHandler {
  public func task(_ task: Foundation.URLSessionTask, willBeRedirectedTo request: Foundation.URLRequest, for response: Foundation.HTTPURLResponse, completion: @escaping (Foundation.URLRequest?) -> Swift.Void)
}
public struct MCAShapeLayerLineCap {
}
public typealias EngagementSessionBlock = (SalemoveSDK.EngagementRequest?, SalemoveSDK.SalemoveError?) -> Swift.Void
public typealias OperatorBlock = ([SalemoveSDK.Operator]?, SalemoveSDK.SalemoveError?) -> Swift.Void
public typealias QueueTicketBlock = (SalemoveSDK.QueueTicket?, SalemoveSDK.SalemoveError?) -> Swift.Void
public typealias QueueRequestBlock = ([SalemoveSDK.Queue]?, SalemoveSDK.SalemoveError?) -> Swift.Void
public typealias QueueUpdateBlock = (SalemoveSDK.Queue) -> Swift.Void
public typealias MessageBlock = (SalemoveSDK.Message?, SalemoveSDK.SalemoveError?) -> Swift.Void
public typealias EngagementBlock = (SalemoveSDK.Engagement?, SalemoveSDK.SalemoveError?) -> Swift.Void
public typealias SuccessBlock = (Swift.Bool, SalemoveSDK.SalemoveError?) -> Swift.Void
public typealias AnswerBlock = (Swift.Bool) -> Swift.Void
public typealias ErrorBlock = (SalemoveSDK.SalemoveError) -> Swift.Void
public typealias AnswerWithSuccessBlock = (Swift.Bool, SalemoveSDK.SuccessBlock?) -> Swift.Void
public typealias RequestAnswerBlock = (SalemoveSDK.VisitorContext, Swift.Bool, @escaping SalemoveSDK.SuccessBlock) -> Swift.Void
public typealias VisitorCodeBlock = (Swift.String?, SalemoveSDK.SalemoveError?) -> Swift.Void
public typealias RequestOfferBlock = (@escaping SalemoveSDK.RequestAnswerBlock) -> Swift.Void
public typealias MediaUgradeOfferBlock = (SalemoveSDK.MediaUpgradeOffer, @escaping SalemoveSDK.AnswerWithSuccessBlock) -> Swift.Void
public typealias ScreenshareOfferBlock = (@escaping SalemoveSDK.AnswerBlock) -> Swift.Void
public typealias VisitorScreenSharingStateChange = (SalemoveSDK.VisitorScreenSharingState, SalemoveSDK.SalemoveError?) -> Swift.Void
public typealias AudioStreamAddedBlock = (SalemoveSDK.AudioStreamable?, SalemoveSDK.SalemoveError?) -> Swift.Void
public typealias VideoStreamAddedBlock = (SalemoveSDK.VideoStreamable?, SalemoveSDK.SalemoveError?) -> Swift.Void
public typealias MessagesUpdateBlock = ([SalemoveSDK.Message]) -> Swift.Void
public typealias EngagementTransferBlock = ([SalemoveSDK.Operator]?) -> Swift.Void
public typealias PushActionBlock = (SalemoveSDK.Push) -> Swift.Void
public typealias OperatorTypingStatusUpdate = (SalemoveSDK.OperatorTypingStatus) -> Swift.Void
public typealias EngagementFileProgressBlock = (SalemoveSDK.EngagementFileProgress) -> Swift.Void
public typealias EngagementFileCompletionBlock = (SalemoveSDK.EngagementFileInformation?, SalemoveSDK.SalemoveError?) -> Swift.Void
public typealias EngagementFileFetchCompletionBlock = (SalemoveSDK.EngagementFileData?, SalemoveSDK.SalemoveError?) -> Swift.Void
@objc public protocol PushNotificationHandling {
  @objc func userNotificationCenter(_ center: UserNotifications.UNUserNotificationCenter, willPresent notification: UserNotifications.UNNotification, withCompletionHandler completionHandler: @escaping (UserNotifications.UNNotificationPresentationOptions) -> Swift.Void)
  @objc func userNotificationCenter(_ center: UserNotifications.UNUserNotificationCenter, didReceive response: UserNotifications.UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -> Swift.Void)
}
open class Stroke {
  final public let fill: SalemoveSDK.Fill
  final public let width: Swift.Double
  final public let cap: SalemoveSDK.LineCap
  final public let join: SalemoveSDK.LineJoin
  final public let miterLimit: Swift.Double
  final public let dashes: [Swift.Double]
  final public let offset: Swift.Double
  public init(fill: SalemoveSDK.Fill = Color.black, width: Swift.Double = 1, cap: SalemoveSDK.LineCap = .butt, join: SalemoveSDK.LineJoin = .miter, miterLimit: Swift.Double = 10, dashes: [Swift.Double] = [], offset: Swift.Double = 0.0)
  @objc deinit
}
public struct MoyaMultipartFormData {
  public enum FormDataProvider {
    case data(Foundation.Data)
    case file(Foundation.URL)
    case stream(Foundation.InputStream, Swift.UInt64)
  }
  public init(provider: SalemoveSDK.MoyaMultipartFormData.FormDataProvider, name: Swift.String, fileName: Swift.String? = nil, mimeType: Swift.String? = nil)
  public let provider: SalemoveSDK.MoyaMultipartFormData.FormDataProvider
  public let name: Swift.String
  public let fileName: Swift.String?
  public let mimeType: Swift.String?
}
public typealias MorphingAnimationDescription = SalemoveSDK.AnimationDescription<SalemoveSDK.Locus>
extension AnimatableVariable where T : SalemoveSDK.LocusInterpolation {
  public func animate(_ desc: SalemoveSDK.MorphingAnimationDescription)
  public func animation(_ desc: SalemoveSDK.MorphingAnimationDescription) -> SalemoveSDK.Animation
  public func animate(from: SalemoveSDK.Locus? = nil, to: SalemoveSDK.Locus, during: Swift.Double = 1.0, delay: Swift.Double = 0.0)
  public func animation(from: SalemoveSDK.Locus? = nil, to: SalemoveSDK.Locus, during: Swift.Double = 1.0, delay: Swift.Double = 0.0) -> SalemoveSDK.Animation
  public func animation(_ f: @escaping (Swift.Double) -> SalemoveSDK.Locus, during: Swift.Double, delay: Swift.Double = 0.0) -> SalemoveSDK.Animation
}
extension AnimatableVariable where T : SalemoveSDK.ContentsInterpolation {
  public func animation(from: SalemoveSDK.Group? = nil, to: [SalemoveSDK.Node], during: Swift.Double = 1.0, delay: Swift.Double = 0.0) -> SalemoveSDK.Animation
  public func animate(from: SalemoveSDK.Group? = nil, to: [SalemoveSDK.Node], during: Swift.Double = 1.0, delay: Swift.Double = 0.0)
}
public struct SignalProducer<Value, Error> where Error : Swift.Error {
  public typealias ProducedSignal = SalemoveSDK.Signal<Value, Error>
  public init<T>(_ base: T) where Value == T.Value, Error == T.Error, T : SalemoveSDK.SignalProducerConvertible
  public init(_ signal: SalemoveSDK.Signal<Value, Error>)
  public init(_ startHandler: @escaping (SalemoveSDK.Signal<Value, Error>.Observer, SalemoveSDK.Lifetime) -> Swift.Void)
  public init(value: Value)
  public init(_ action: @escaping () -> Value)
  public init(_ action: @escaping () -> Swift.Result<Value, Error>)
  public init(error: Error)
  public init(result: Swift.Result<Value, Error>)
  public init<S>(_ values: S) where Value == S.Element, S : Swift.Sequence
  public init(values first: Value, _ second: Value, _ tail: Value...)
  public static var empty: SalemoveSDK.SignalProducer<Value, Error> {
    get
  }
  public static var never: SalemoveSDK.SignalProducer<Value, Error> {
    get
  }
  @discardableResult
  public func startWithSignal<Result>(_ setup: (SalemoveSDK.Signal<Value, Error>, SalemoveSDK.Disposable) -> Result) -> Result
}
extension SignalProducer where Error == Swift.Never {
  public init(value: Value)
  public init<S>(_ values: S) where Value == S.Element, S : Swift.Sequence
  public init(values first: Value, _ second: Value, _ tail: Value...)
}
extension SignalProducer where Error == Swift.Error {
  public init(_ action: @escaping () throws -> Value)
}
public protocol SignalProducerConvertible {
  associatedtype Value
  associatedtype Error : Swift.Error
  var producer: SalemoveSDK.SignalProducer<Self.Value, Self.Error> { get }
}
public protocol SignalProducerProtocol {
  associatedtype Value
  associatedtype Error : Swift.Error
  var producer: SalemoveSDK.SignalProducer<Self.Value, Self.Error> { get }
}
extension SignalProducer : SalemoveSDK.SignalProducerConvertible, SalemoveSDK.SignalProducerProtocol {
  public var producer: SalemoveSDK.SignalProducer<Value, Error> {
    get
  }
}
extension SignalProducer {
  @discardableResult
  public func start(_ observer: SalemoveSDK.Signal<Value, Error>.Observer = .init()) -> SalemoveSDK.Disposable
  @discardableResult
  public func start(_ action: @escaping SalemoveSDK.Signal<Value, Error>.Observer.Action) -> SalemoveSDK.Disposable
  @discardableResult
  public func startWithResult(_ action: @escaping (Swift.Result<Value, Error>) -> Swift.Void) -> SalemoveSDK.Disposable
  @discardableResult
  public func startWithCompleted(_ action: @escaping () -> Swift.Void) -> SalemoveSDK.Disposable
  @discardableResult
  public func startWithFailed(_ action: @escaping (Error) -> Swift.Void) -> SalemoveSDK.Disposable
  @discardableResult
  public func startWithInterrupted(_ action: @escaping () -> Swift.Void) -> SalemoveSDK.Disposable
}
extension SignalProducer where Error == Swift.Never {
  @discardableResult
  public func startWithValues(_ action: @escaping (Value) -> Swift.Void) -> SalemoveSDK.Disposable
}
extension SignalProducer {
  public func lift<U, F>(_ transform: @escaping (SalemoveSDK.Signal<Value, Error>) -> SalemoveSDK.Signal<U, F>) -> SalemoveSDK.SignalProducer<U, F> where F : Swift.Error
  public func lift<U, F, V, G>(_ transform: @escaping (SalemoveSDK.Signal<Value, Error>) -> (SalemoveSDK.Signal<U, F>) -> SalemoveSDK.Signal<V, G>) -> (SalemoveSDK.SignalProducer<U, F>) -> SalemoveSDK.SignalProducer<V, G> where F : Swift.Error, G : Swift.Error
}
extension SignalProducer {
  public func map<U>(_ transform: @escaping (Value) -> U) -> SalemoveSDK.SignalProducer<U, Error>
  public func map<U>(value: U) -> SalemoveSDK.SignalProducer<U, Error>
  public func map<U>(_ keyPath: Swift.KeyPath<Value, U>) -> SalemoveSDK.SignalProducer<U, Error>
  public func mapError<F>(_ transform: @escaping (Error) -> F) -> SalemoveSDK.SignalProducer<Value, F> where F : Swift.Error
  public func lazyMap<U>(on scheduler: SalemoveSDK.Scheduler, transform: @escaping (Value) -> U) -> SalemoveSDK.SignalProducer<U, Error>
  public func filter(_ isIncluded: @escaping (Value) -> Swift.Bool) -> SalemoveSDK.SignalProducer<Value, Error>
  public func compactMap<U>(_ transform: @escaping (Value) -> U?) -> SalemoveSDK.SignalProducer<U, Error>
  @available(*, deprecated, renamed: "compactMap")
  public func filterMap<U>(_ transform: @escaping (Value) -> U?) -> SalemoveSDK.SignalProducer<U, Error>
  public func take(first count: Swift.Int) -> SalemoveSDK.SignalProducer<Value, Error>
  public func collect() -> SalemoveSDK.SignalProducer<[Value], Error>
  public func collect(count: Swift.Int) -> SalemoveSDK.SignalProducer<[Value], Error>
  public func collect(_ shouldEmit: @escaping ([Value]) -> Swift.Bool) -> SalemoveSDK.SignalProducer<[Value], Error>
  public func collect(_ shouldEmit: @escaping ([Value], Value) -> Swift.Bool) -> SalemoveSDK.SignalProducer<[Value], Error>
  public func collect(every interval: Dispatch.DispatchTimeInterval, on scheduler: SalemoveSDK.DateScheduler, skipEmpty: Swift.Bool = false, discardWhenCompleted: Swift.Bool = true) -> SalemoveSDK.SignalProducer<[Value], Error>
  public func observe(on scheduler: SalemoveSDK.Scheduler) -> SalemoveSDK.SignalProducer<Value, Error>
  public func combineLatest<U>(with other: SalemoveSDK.SignalProducer<U, Error>) -> SalemoveSDK.SignalProducer<(Value, U), Error>
  public func combineLatest<Other>(with other: Other) -> SalemoveSDK.SignalProducer<(Value, Other.Value), Error> where Error == Other.Error, Other : SalemoveSDK.SignalProducerConvertible
  public func merge(with other: SalemoveSDK.SignalProducer<Value, Error>) -> SalemoveSDK.SignalProducer<Value, Error>
  public func merge<Other>(with other: Other) -> SalemoveSDK.SignalProducer<Value, Error> where Value == Other.Value, Error == Other.Error, Other : SalemoveSDK.SignalProducerConvertible
  public func delay(_ interval: Foundation.TimeInterval, on scheduler: SalemoveSDK.DateScheduler) -> SalemoveSDK.SignalProducer<Value, Error>
  public func skip(first count: Swift.Int) -> SalemoveSDK.SignalProducer<Value, Error>
  public func materialize() -> SalemoveSDK.SignalProducer<SalemoveSDK.SignalProducer<Value, Error>.ProducedSignal.Event, Swift.Never>
  public func materializeResults() -> SalemoveSDK.SignalProducer<Swift.Result<Value, Error>, Swift.Never>
  public func sample<U>(with sampler: SalemoveSDK.SignalProducer<U, Swift.Never>) -> SalemoveSDK.SignalProducer<(Value, U), Error>
  public func sample<Sampler>(with sampler: Sampler) -> SalemoveSDK.SignalProducer<(Value, Sampler.Value), Error> where Sampler : SalemoveSDK.SignalProducerConvertible, Sampler.Error == Swift.Never
  public func sample(on sampler: SalemoveSDK.SignalProducer<(), Swift.Never>) -> SalemoveSDK.SignalProducer<Value, Error>
  public func sample<Sampler>(on sampler: Sampler) -> SalemoveSDK.SignalProducer<Value, Error> where Sampler : SalemoveSDK.SignalProducerConvertible, Sampler.Error == Swift.Never, Sampler.Value == ()
  public func withLatest<U>(from samplee: SalemoveSDK.SignalProducer<U, Swift.Never>) -> SalemoveSDK.SignalProducer<(Value, U), Error>
  public func withLatest<Samplee>(from samplee: Samplee) -> SalemoveSDK.SignalProducer<(Value, Samplee.Value), Error> where Samplee : SalemoveSDK.SignalProducerConvertible, Samplee.Error == Swift.Never
  public func take(during lifetime: SalemoveSDK.Lifetime) -> SalemoveSDK.SignalProducer<Value, Error>
  public func take(until trigger: SalemoveSDK.SignalProducer<(), Swift.Never>) -> SalemoveSDK.SignalProducer<Value, Error>
  public func take<Trigger>(until trigger: Trigger) -> SalemoveSDK.SignalProducer<Value, Error> where Trigger : SalemoveSDK.SignalProducerConvertible, Trigger.Error == Swift.Never, Trigger.Value == ()
  public func skip(until trigger: SalemoveSDK.SignalProducer<(), Swift.Never>) -> SalemoveSDK.SignalProducer<Value, Error>
  public func skip<Trigger>(until trigger: Trigger) -> SalemoveSDK.SignalProducer<Value, Error> where Trigger : SalemoveSDK.SignalProducerConvertible, Trigger.Error == Swift.Never, Trigger.Value == ()
  public func combinePrevious(_ initial: Value) -> SalemoveSDK.SignalProducer<(Value, Value), Error>
  public func combinePrevious() -> SalemoveSDK.SignalProducer<(Value, Value), Error>
  public func reduce<U>(_ initialResult: U, _ nextPartialResult: @escaping (U, Value) -> U) -> SalemoveSDK.SignalProducer<U, Error>
  public func reduce<U>(into initialResult: U, _ nextPartialResult: @escaping (inout U, Value) -> Swift.Void) -> SalemoveSDK.SignalProducer<U, Error>
  public func scan<U>(_ initialResult: U, _ nextPartialResult: @escaping (U, Value) -> U) -> SalemoveSDK.SignalProducer<U, Error>
  public func scan<U>(into initialResult: U, _ nextPartialResult: @escaping (inout U, Value) -> Swift.Void) -> SalemoveSDK.SignalProducer<U, Error>
  public func scanMap<State, U>(_ initialState: State, _ next: @escaping (State, Value) -> (State, U)) -> SalemoveSDK.SignalProducer<U, Error>
  public func scanMap<State, U>(into initialState: State, _ next: @escaping (inout State, Value) -> U) -> SalemoveSDK.SignalProducer<U, Error>
  public func skipRepeats(_ isEquivalent: @escaping (Value, Value) -> Swift.Bool) -> SalemoveSDK.SignalProducer<Value, Error>
  public func skip(while shouldContinue: @escaping (Value) -> Swift.Bool) -> SalemoveSDK.SignalProducer<Value, Error>
  public func take(untilReplacement replacement: SalemoveSDK.SignalProducer<Value, Error>) -> SalemoveSDK.SignalProducer<Value, Error>
  public func take<Replacement>(untilReplacement replacement: Replacement) -> SalemoveSDK.SignalProducer<Value, Error> where Value == Replacement.Value, Error == Replacement.Error, Replacement : SalemoveSDK.SignalProducerConvertible
  public func take(last count: Swift.Int) -> SalemoveSDK.SignalProducer<Value, Error>
  public func take(while shouldContinue: @escaping (Value) -> Swift.Bool) -> SalemoveSDK.SignalProducer<Value, Error>
  public func zip<U>(with other: SalemoveSDK.SignalProducer<U, Error>) -> SalemoveSDK.SignalProducer<(Value, U), Error>
  public func zip<Other>(with other: Other) -> SalemoveSDK.SignalProducer<(Value, Other.Value), Error> where Error == Other.Error, Other : SalemoveSDK.SignalProducerConvertible
  public func attempt(_ action: @escaping (Value) -> Swift.Result<(), Error>) -> SalemoveSDK.SignalProducer<Value, Error>
  public func attemptMap<U>(_ action: @escaping (Value) -> Swift.Result<U, Error>) -> SalemoveSDK.SignalProducer<U, Error>
  public func throttle(_ interval: Foundation.TimeInterval, on scheduler: SalemoveSDK.DateScheduler) -> SalemoveSDK.SignalProducer<Value, Error>
  public func throttle<P>(while shouldThrottle: P, on scheduler: SalemoveSDK.Scheduler) -> SalemoveSDK.SignalProducer<Value, Error> where P : SalemoveSDK.PropertyProtocol, P.Value == Swift.Bool
  public func debounce(_ interval: Foundation.TimeInterval, on scheduler: SalemoveSDK.DateScheduler, discardWhenCompleted: Swift.Bool = true) -> SalemoveSDK.SignalProducer<Value, Error>
  public func timeout(after interval: Foundation.TimeInterval, raising error: Error, on scheduler: SalemoveSDK.DateScheduler) -> SalemoveSDK.SignalProducer<Value, Error>
}
extension SignalProducer where Value : SalemoveSDK.OptionalProtocol {
  public func skipNil() -> SalemoveSDK.SignalProducer<Value.Wrapped, Error>
}
extension SignalProducer where Value : SalemoveSDK.EventProtocol, Error == Swift.Never {
  public func dematerialize() -> SalemoveSDK.SignalProducer<Value.Value, Value.Error>
}
extension SignalProducer where Error == Swift.Never {
  public func dematerializeResults<Success, Failure>() -> SalemoveSDK.SignalProducer<Success, Failure> where Value == Swift.Result<Success, Failure>, Failure : Swift.Error
}
extension SignalProducer where Error == Swift.Never {
  public func promoteError<F>(_: F.Type = F.self) -> SalemoveSDK.SignalProducer<Value, F> where F : Swift.Error
  public func promoteError(_: Error.Type = Error.self) -> SalemoveSDK.SignalProducer<Value, Error>
  public func timeout<NewError>(after interval: Foundation.TimeInterval, raising error: NewError, on scheduler: SalemoveSDK.DateScheduler) -> SalemoveSDK.SignalProducer<Value, NewError> where NewError : Swift.Error
  public func attempt(_ action: @escaping (Value) throws -> Swift.Void) -> SalemoveSDK.SignalProducer<Value, Swift.Error>
  public func attemptMap<U>(_ action: @escaping (Value) throws -> U) -> SalemoveSDK.SignalProducer<U, Swift.Error>
}
extension SignalProducer where Error == Swift.Error {
  public func attempt(_ action: @escaping (Value) throws -> Swift.Void) -> SalemoveSDK.SignalProducer<Value, Error>
  public func attemptMap<U>(_ transform: @escaping (Value) throws -> U) -> SalemoveSDK.SignalProducer<U, Error>
}
extension SignalProducer where Value == Swift.Never {
  public func promoteValue<U>(_: U.Type = U.self) -> SalemoveSDK.SignalProducer<U, Error>
  public func promoteValue(_: Value.Type = Value.self) -> SalemoveSDK.SignalProducer<Value, Error>
}
extension SignalProducer where Value : Swift.Equatable {
  public func skipRepeats() -> SalemoveSDK.SignalProducer<Value, Error>
}
extension SignalProducer {
  public func uniqueValues<Identity>(_ transform: @escaping (Value) -> Identity) -> SalemoveSDK.SignalProducer<Value, Error> where Identity : Swift.Hashable
}
extension SignalProducer where Value : Swift.Hashable {
  public func uniqueValues() -> SalemoveSDK.SignalProducer<Value, Error>
}
extension SignalProducer {
  public func on(starting: (() -> Swift.Void)? = nil, started: (() -> Swift.Void)? = nil, event: ((SalemoveSDK.SignalProducer<Value, Error>.ProducedSignal.Event) -> Swift.Void)? = nil, failed: ((Error) -> Swift.Void)? = nil, completed: (() -> Swift.Void)? = nil, interrupted: (() -> Swift.Void)? = nil, terminated: (() -> Swift.Void)? = nil, disposed: (() -> Swift.Void)? = nil, value: ((Value) -> Swift.Void)? = nil) -> SalemoveSDK.SignalProducer<Value, Error>
  public func start(on scheduler: SalemoveSDK.Scheduler) -> SalemoveSDK.SignalProducer<Value, Error>
}
extension SignalProducer {
  public static func combineLatest<A, B>(_ a: A, _ b: B) -> SalemoveSDK.SignalProducer<(Value, B.Value), Error> where Value == A.Value, Error == A.Error, A : SalemoveSDK.SignalProducerConvertible, B : SalemoveSDK.SignalProducerConvertible, A.Error == B.Error
  public static func combineLatest<A, B, C>(_ a: A, _ b: B, _ c: C) -> SalemoveSDK.SignalProducer<(Value, B.Value, C.Value), Error> where Value == A.Value, Error == A.Error, A : SalemoveSDK.SignalProducerConvertible, B : SalemoveSDK.SignalProducerConvertible, C : SalemoveSDK.SignalProducerConvertible, A.Error == B.Error, B.Error == C.Error
  public static func combineLatest<A, B, C, D>(_ a: A, _ b: B, _ c: C, _ d: D) -> SalemoveSDK.SignalProducer<(Value, B.Value, C.Value, D.Value), Error> where Value == A.Value, Error == A.Error, A : SalemoveSDK.SignalProducerConvertible, B : SalemoveSDK.SignalProducerConvertible, C : SalemoveSDK.SignalProducerConvertible, D : SalemoveSDK.SignalProducerConvertible, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error
  public static func combineLatest<A, B, C, D, E>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E) -> SalemoveSDK.SignalProducer<(Value, B.Value, C.Value, D.Value, E.Value), Error> where Value == A.Value, Error == A.Error, A : SalemoveSDK.SignalProducerConvertible, B : SalemoveSDK.SignalProducerConvertible, C : SalemoveSDK.SignalProducerConvertible, D : SalemoveSDK.SignalProducerConvertible, E : SalemoveSDK.SignalProducerConvertible, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error, D.Error == E.Error
  public static func combineLatest<A, B, C, D, E, F>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F) -> SalemoveSDK.SignalProducer<(Value, B.Value, C.Value, D.Value, E.Value, F.Value), Error> where Value == A.Value, Error == A.Error, A : SalemoveSDK.SignalProducerConvertible, B : SalemoveSDK.SignalProducerConvertible, C : SalemoveSDK.SignalProducerConvertible, D : SalemoveSDK.SignalProducerConvertible, E : SalemoveSDK.SignalProducerConvertible, F : SalemoveSDK.SignalProducerConvertible, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error, D.Error == E.Error, E.Error == F.Error
  public static func combineLatest<A, B, C, D, E, F, G>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F, _ g: G) -> SalemoveSDK.SignalProducer<(Value, B.Value, C.Value, D.Value, E.Value, F.Value, G.Value), Error> where Value == A.Value, Error == A.Error, A : SalemoveSDK.SignalProducerConvertible, B : SalemoveSDK.SignalProducerConvertible, C : SalemoveSDK.SignalProducerConvertible, D : SalemoveSDK.SignalProducerConvertible, E : SalemoveSDK.SignalProducerConvertible, F : SalemoveSDK.SignalProducerConvertible, G : SalemoveSDK.SignalProducerConvertible, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error, D.Error == E.Error, E.Error == F.Error, F.Error == G.Error
  public static func combineLatest<A, B, C, D, E, F, G, H>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F, _ g: G, _ h: H) -> SalemoveSDK.SignalProducer<(Value, B.Value, C.Value, D.Value, E.Value, F.Value, G.Value, H.Value), Error> where Value == A.Value, Error == A.Error, A : SalemoveSDK.SignalProducerConvertible, B : SalemoveSDK.SignalProducerConvertible, C : SalemoveSDK.SignalProducerConvertible, D : SalemoveSDK.SignalProducerConvertible, E : SalemoveSDK.SignalProducerConvertible, F : SalemoveSDK.SignalProducerConvertible, G : SalemoveSDK.SignalProducerConvertible, H : SalemoveSDK.SignalProducerConvertible, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error, D.Error == E.Error, E.Error == F.Error, F.Error == G.Error, G.Error == H.Error
  public static func combineLatest<A, B, C, D, E, F, G, H, I>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F, _ g: G, _ h: H, _ i: I) -> SalemoveSDK.SignalProducer<(Value, B.Value, C.Value, D.Value, E.Value, F.Value, G.Value, H.Value, I.Value), Error> where Value == A.Value, Error == A.Error, A : SalemoveSDK.SignalProducerConvertible, B : SalemoveSDK.SignalProducerConvertible, C : SalemoveSDK.SignalProducerConvertible, D : SalemoveSDK.SignalProducerConvertible, E : SalemoveSDK.SignalProducerConvertible, F : SalemoveSDK.SignalProducerConvertible, G : SalemoveSDK.SignalProducerConvertible, H : SalemoveSDK.SignalProducerConvertible, I : SalemoveSDK.SignalProducerConvertible, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error, D.Error == E.Error, E.Error == F.Error, F.Error == G.Error, G.Error == H.Error, H.Error == I.Error
  public static func combineLatest<A, B, C, D, E, F, G, H, I, J>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F, _ g: G, _ h: H, _ i: I, _ j: J) -> SalemoveSDK.SignalProducer<(Value, B.Value, C.Value, D.Value, E.Value, F.Value, G.Value, H.Value, I.Value, J.Value), Error> where Value == A.Value, Error == A.Error, A : SalemoveSDK.SignalProducerConvertible, B : SalemoveSDK.SignalProducerConvertible, C : SalemoveSDK.SignalProducerConvertible, D : SalemoveSDK.SignalProducerConvertible, E : SalemoveSDK.SignalProducerConvertible, F : SalemoveSDK.SignalProducerConvertible, G : SalemoveSDK.SignalProducerConvertible, H : SalemoveSDK.SignalProducerConvertible, I : SalemoveSDK.SignalProducerConvertible, J : SalemoveSDK.SignalProducerConvertible, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error, D.Error == E.Error, E.Error == F.Error, F.Error == G.Error, G.Error == H.Error, H.Error == I.Error, I.Error == J.Error
  public static func combineLatest<S>(_ producers: S) -> SalemoveSDK.SignalProducer<[Value], Error> where Value == S.Element.Value, Error == S.Element.Error, S : Swift.Sequence, S.Element : SalemoveSDK.SignalProducerConvertible
  public static func combineLatest<S>(_ producers: S, emptySentinel: [S.Iterator.Element.Value]) -> SalemoveSDK.SignalProducer<[Value], Error> where Value == S.Element.Value, Error == S.Element.Error, S : Swift.Sequence, S.Element : SalemoveSDK.SignalProducerConvertible
  public static func zip<A, B>(_ a: A, _ b: B) -> SalemoveSDK.SignalProducer<(Value, B.Value), Error> where Value == A.Value, Error == A.Error, A : SalemoveSDK.SignalProducerConvertible, B : SalemoveSDK.SignalProducerConvertible, A.Error == B.Error
  public static func zip<A, B, C>(_ a: A, _ b: B, _ c: C) -> SalemoveSDK.SignalProducer<(Value, B.Value, C.Value), Error> where Value == A.Value, Error == A.Error, A : SalemoveSDK.SignalProducerConvertible, B : SalemoveSDK.SignalProducerConvertible, C : SalemoveSDK.SignalProducerConvertible, A.Error == B.Error, B.Error == C.Error
  public static func zip<A, B, C, D>(_ a: A, _ b: B, _ c: C, _ d: D) -> SalemoveSDK.SignalProducer<(Value, B.Value, C.Value, D.Value), Error> where Value == A.Value, Error == A.Error, A : SalemoveSDK.SignalProducerConvertible, B : SalemoveSDK.SignalProducerConvertible, C : SalemoveSDK.SignalProducerConvertible, D : SalemoveSDK.SignalProducerConvertible, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error
  public static func zip<A, B, C, D, E>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E) -> SalemoveSDK.SignalProducer<(Value, B.Value, C.Value, D.Value, E.Value), Error> where Value == A.Value, Error == A.Error, A : SalemoveSDK.SignalProducerConvertible, B : SalemoveSDK.SignalProducerConvertible, C : SalemoveSDK.SignalProducerConvertible, D : SalemoveSDK.SignalProducerConvertible, E : SalemoveSDK.SignalProducerConvertible, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error, D.Error == E.Error
  public static func zip<A, B, C, D, E, F>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F) -> SalemoveSDK.SignalProducer<(Value, B.Value, C.Value, D.Value, E.Value, F.Value), Error> where Value == A.Value, Error == A.Error, A : SalemoveSDK.SignalProducerConvertible, B : SalemoveSDK.SignalProducerConvertible, C : SalemoveSDK.SignalProducerConvertible, D : SalemoveSDK.SignalProducerConvertible, E : SalemoveSDK.SignalProducerConvertible, F : SalemoveSDK.SignalProducerConvertible, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error, D.Error == E.Error, E.Error == F.Error
  public static func zip<A, B, C, D, E, F, G>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F, _ g: G) -> SalemoveSDK.SignalProducer<(Value, B.Value, C.Value, D.Value, E.Value, F.Value, G.Value), Error> where Value == A.Value, Error == A.Error, A : SalemoveSDK.SignalProducerConvertible, B : SalemoveSDK.SignalProducerConvertible, C : SalemoveSDK.SignalProducerConvertible, D : SalemoveSDK.SignalProducerConvertible, E : SalemoveSDK.SignalProducerConvertible, F : SalemoveSDK.SignalProducerConvertible, G : SalemoveSDK.SignalProducerConvertible, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error, D.Error == E.Error, E.Error == F.Error, F.Error == G.Error
  public static func zip<A, B, C, D, E, F, G, H>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F, _ g: G, _ h: H) -> SalemoveSDK.SignalProducer<(Value, B.Value, C.Value, D.Value, E.Value, F.Value, G.Value, H.Value), Error> where Value == A.Value, Error == A.Error, A : SalemoveSDK.SignalProducerConvertible, B : SalemoveSDK.SignalProducerConvertible, C : SalemoveSDK.SignalProducerConvertible, D : SalemoveSDK.SignalProducerConvertible, E : SalemoveSDK.SignalProducerConvertible, F : SalemoveSDK.SignalProducerConvertible, G : SalemoveSDK.SignalProducerConvertible, H : SalemoveSDK.SignalProducerConvertible, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error, D.Error == E.Error, E.Error == F.Error, F.Error == G.Error, G.Error == H.Error
  public static func zip<A, B, C, D, E, F, G, H, I>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F, _ g: G, _ h: H, _ i: I) -> SalemoveSDK.SignalProducer<(Value, B.Value, C.Value, D.Value, E.Value, F.Value, G.Value, H.Value, I.Value), Error> where Value == A.Value, Error == A.Error, A : SalemoveSDK.SignalProducerConvertible, B : SalemoveSDK.SignalProducerConvertible, C : SalemoveSDK.SignalProducerConvertible, D : SalemoveSDK.SignalProducerConvertible, E : SalemoveSDK.SignalProducerConvertible, F : SalemoveSDK.SignalProducerConvertible, G : SalemoveSDK.SignalProducerConvertible, H : SalemoveSDK.SignalProducerConvertible, I : SalemoveSDK.SignalProducerConvertible, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error, D.Error == E.Error, E.Error == F.Error, F.Error == G.Error, G.Error == H.Error, H.Error == I.Error
  public static func zip<A, B, C, D, E, F, G, H, I, J>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F, _ g: G, _ h: H, _ i: I, _ j: J) -> SalemoveSDK.SignalProducer<(Value, B.Value, C.Value, D.Value, E.Value, F.Value, G.Value, H.Value, I.Value, J.Value), Error> where Value == A.Value, Error == A.Error, A : SalemoveSDK.SignalProducerConvertible, B : SalemoveSDK.SignalProducerConvertible, C : SalemoveSDK.SignalProducerConvertible, D : SalemoveSDK.SignalProducerConvertible, E : SalemoveSDK.SignalProducerConvertible, F : SalemoveSDK.SignalProducerConvertible, G : SalemoveSDK.SignalProducerConvertible, H : SalemoveSDK.SignalProducerConvertible, I : SalemoveSDK.SignalProducerConvertible, J : SalemoveSDK.SignalProducerConvertible, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error, D.Error == E.Error, E.Error == F.Error, F.Error == G.Error, G.Error == H.Error, H.Error == I.Error, I.Error == J.Error
  public static func zip<S>(_ producers: S) -> SalemoveSDK.SignalProducer<[Value], Error> where Value == S.Element.Value, Error == S.Element.Error, S : Swift.Sequence, S.Element : SalemoveSDK.SignalProducerConvertible
  public static func zip<S>(_ producers: S, emptySentinel: [S.Iterator.Element.Value]) -> SalemoveSDK.SignalProducer<[Value], Error> where Value == S.Element.Value, Error == S.Element.Error, S : Swift.Sequence, S.Element : SalemoveSDK.SignalProducerConvertible
}
extension SignalProducer {
  public func `repeat`(_ count: Swift.Int) -> SalemoveSDK.SignalProducer<Value, Error>
  public func retry(upTo count: Swift.Int) -> SalemoveSDK.SignalProducer<Value, Error>
  public func retry(upTo count: Swift.Int, interval: Foundation.TimeInterval, on scheduler: SalemoveSDK.DateScheduler) -> SalemoveSDK.SignalProducer<Value, Error>
  public func then<U>(_ replacement: SalemoveSDK.SignalProducer<U, Swift.Never>) -> SalemoveSDK.SignalProducer<U, Error>
  public func then<Replacement>(_ replacement: Replacement) -> SalemoveSDK.SignalProducer<Replacement.Value, Error> where Replacement : SalemoveSDK.SignalProducerConvertible, Replacement.Error == Swift.Never
  public func then<U>(_ replacement: SalemoveSDK.SignalProducer<U, Error>) -> SalemoveSDK.SignalProducer<U, Error>
  public func then<Replacement>(_ replacement: Replacement) -> SalemoveSDK.SignalProducer<Replacement.Value, Error> where Error == Replacement.Error, Replacement : SalemoveSDK.SignalProducerConvertible
  public func then(_ replacement: SalemoveSDK.SignalProducer<Value, Error>) -> SalemoveSDK.SignalProducer<Value, Error>
  public func then<Replacement>(_ replacement: Replacement) -> SalemoveSDK.SignalProducer<Value, Error> where Value == Replacement.Value, Error == Replacement.Error, Replacement : SalemoveSDK.SignalProducerConvertible
}
extension SignalProducer where Error == Swift.Never {
  public func then<U, F>(_ replacement: SalemoveSDK.SignalProducer<U, F>) -> SalemoveSDK.SignalProducer<U, F> where F : Swift.Error
  public func then<Replacement>(_ replacement: Replacement) -> SalemoveSDK.SignalProducer<Replacement.Value, Replacement.Error> where Replacement : SalemoveSDK.SignalProducerConvertible
  public func then<U>(_ replacement: SalemoveSDK.SignalProducer<U, Swift.Never>) -> SalemoveSDK.SignalProducer<U, Swift.Never>
  public func then<Replacement>(_ replacement: Replacement) -> SalemoveSDK.SignalProducer<Replacement.Value, Swift.Never> where Replacement : SalemoveSDK.SignalProducerConvertible, Replacement.Error == Swift.Never
  public func then(_ replacement: SalemoveSDK.SignalProducer<Value, Swift.Never>) -> SalemoveSDK.SignalProducer<Value, Swift.Never>
  public func then<Replacement>(_ replacement: Replacement) -> SalemoveSDK.SignalProducer<Value, Swift.Never> where Value == Replacement.Value, Replacement : SalemoveSDK.SignalProducerConvertible, Replacement.Error == Swift.Never
}
extension SignalProducer {
  public func first() -> Swift.Result<Value, Error>?
  public func single() -> Swift.Result<Value, Error>?
  public func last() -> Swift.Result<Value, Error>?
  public func wait() -> Swift.Result<(), Error>
  public func replayLazily(upTo capacity: Swift.Int) -> SalemoveSDK.SignalProducer<Value, Error>
}
extension SignalProducer where Value == Swift.Bool {
  public func negate() -> SalemoveSDK.SignalProducer<Value, Error>
  public func and(_ booleans: SalemoveSDK.SignalProducer<Value, Error>) -> SalemoveSDK.SignalProducer<Value, Error>
  public func and<Booleans>(_ booleans: Booleans) -> SalemoveSDK.SignalProducer<Value, Error> where Error == Booleans.Error, Booleans : SalemoveSDK.SignalProducerConvertible, Booleans.Value == Swift.Bool
  public static func all<BooleansCollection>(_ booleans: BooleansCollection) -> SalemoveSDK.SignalProducer<Value, Error> where BooleansCollection : Swift.Collection, BooleansCollection.Element == SalemoveSDK.SignalProducer<Swift.Bool, Error>
  public static func all(_ booleans: SalemoveSDK.SignalProducer<Value, Error>...) -> SalemoveSDK.SignalProducer<Value, Error>
  public static func all<Booleans, BooleansCollection>(_ booleans: BooleansCollection) -> SalemoveSDK.SignalProducer<Value, Error> where Error == Booleans.Error, Booleans : SalemoveSDK.SignalProducerConvertible, Booleans == BooleansCollection.Element, BooleansCollection : Swift.Collection, Booleans.Value == Swift.Bool
  public func or(_ booleans: SalemoveSDK.SignalProducer<Value, Error>) -> SalemoveSDK.SignalProducer<Value, Error>
  public func or<Booleans>(_ booleans: Booleans) -> SalemoveSDK.SignalProducer<Value, Error> where Error == Booleans.Error, Booleans : SalemoveSDK.SignalProducerConvertible, Booleans.Value == Swift.Bool
  public static func any<BooleansCollection>(_ booleans: BooleansCollection) -> SalemoveSDK.SignalProducer<Value, Error> where BooleansCollection : Swift.Collection, BooleansCollection.Element == SalemoveSDK.SignalProducer<Swift.Bool, Error>
  public static func any(_ booleans: SalemoveSDK.SignalProducer<Value, Error>...) -> SalemoveSDK.SignalProducer<Value, Error>
  public static func any<Booleans, BooleansCollection>(_ booleans: BooleansCollection) -> SalemoveSDK.SignalProducer<Value, Error> where Error == Booleans.Error, Booleans : SalemoveSDK.SignalProducerConvertible, Booleans == BooleansCollection.Element, BooleansCollection : Swift.Collection, Booleans.Value == Swift.Bool
}
extension SignalProducer where Value == Foundation.Date, Error == Swift.Never {
  public static func timer(interval: Dispatch.DispatchTimeInterval, on scheduler: SalemoveSDK.DateScheduler) -> SalemoveSDK.SignalProducer<Value, Error>
  public static func timer(interval: Dispatch.DispatchTimeInterval, on scheduler: SalemoveSDK.DateScheduler, leeway: Dispatch.DispatchTimeInterval) -> SalemoveSDK.SignalProducer<Value, Error>
}
public struct MCAMediaTimingFillMode {
  public static let forwards: QuartzCore.CAMediaTimingFillMode
  public static let backwards: QuartzCore.CAMediaTimingFillMode
  public static let both: QuartzCore.CAMediaTimingFillMode
  public static let removed: QuartzCore.CAMediaTimingFillMode
}
public typealias TransformAnimationDescription = SalemoveSDK.AnimationDescription<SalemoveSDK.Transform>
extension AnimatableVariable where T : SalemoveSDK.TransformInterpolation {
  public func animate(_ desc: SalemoveSDK.TransformAnimationDescription)
  public func animation(_ desc: SalemoveSDK.TransformAnimationDescription) -> SalemoveSDK.Animation
  public func animate(from: SalemoveSDK.Transform? = nil, to: SalemoveSDK.Transform, during: Swift.Double = 1.0, delay: Swift.Double = 0.0)
  public func animate(angle: Swift.Double, x: Swift.Double? = .none, y: Swift.Double? = .none, during: Swift.Double = 1.0, delay: Swift.Double = 0.0)
  public func animate(along path: SalemoveSDK.Path, during: Swift.Double = 1.0, delay: Swift.Double = 0.0)
  public func animation(from: SalemoveSDK.Transform? = nil, to: SalemoveSDK.Transform, during: Swift.Double = 1.0, delay: Swift.Double = 0.0) -> SalemoveSDK.Animation
  public func animation(_ f: @escaping ((Swift.Double) -> SalemoveSDK.Transform), during: Swift.Double = 1.0, delay: Swift.Double = 0.0) -> SalemoveSDK.Animation
  public func animation(angle: Swift.Double, x: Swift.Double? = .none, y: Swift.Double? = .none, during: Swift.Double = 1.0, delay: Swift.Double = 0.0) -> SalemoveSDK.Animation
  public func animation(along path: SalemoveSDK.Path, during: Swift.Double = 1.0, delay: Swift.Double = 0.0) -> SalemoveSDK.Animation
}
public protocol DataResponseSerializerProtocol {
  associatedtype SerializedObject
  func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) throws -> Self.SerializedObject
}
public protocol DownloadResponseSerializerProtocol {
  associatedtype SerializedObject
  func serializeDownload(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, fileURL: Foundation.URL?, error: Swift.Error?) throws -> Self.SerializedObject
}
public protocol ResponseSerializer : SalemoveSDK.DataResponseSerializerProtocol, SalemoveSDK.DownloadResponseSerializerProtocol {
  var dataPreprocessor: SalemoveSDK.DataPreprocessor { get }
  var emptyRequestMethods: Swift.Set<SalemoveSDK.AlamofireHTTPMethod> { get }
  var emptyResponseCodes: Swift.Set<Swift.Int> { get }
}
public protocol DataPreprocessor {
  func preprocess(_ data: Foundation.Data) throws -> Foundation.Data
}
public struct PassthroughPreprocessor : SalemoveSDK.DataPreprocessor {
  public init()
  public func preprocess(_ data: Foundation.Data) throws -> Foundation.Data
}
public struct GoogleXSSIPreprocessor : SalemoveSDK.DataPreprocessor {
  public init()
  public func preprocess(_ data: Foundation.Data) throws -> Foundation.Data
}
extension ResponseSerializer {
  public static var defaultDataPreprocessor: SalemoveSDK.DataPreprocessor {
    get
  }
  public static var defaultEmptyRequestMethods: Swift.Set<SalemoveSDK.AlamofireHTTPMethod> {
    get
  }
  public static var defaultEmptyResponseCodes: Swift.Set<Swift.Int> {
    get
  }
  public var dataPreprocessor: SalemoveSDK.DataPreprocessor {
    get
  }
  public var emptyRequestMethods: Swift.Set<SalemoveSDK.AlamofireHTTPMethod> {
    get
  }
  public var emptyResponseCodes: Swift.Set<Swift.Int> {
    get
  }
  public func requestAllowsEmptyResponseData(_ request: Foundation.URLRequest?) -> Swift.Bool?
  public func responseAllowsEmptyResponseData(_ response: Foundation.HTTPURLResponse?) -> Swift.Bool?
  public func emptyResponseAllowed(forRequest request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?) -> Swift.Bool
}
extension DownloadResponseSerializerProtocol where Self : SalemoveSDK.DataResponseSerializerProtocol {
  public func serializeDownload(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, fileURL: Foundation.URL?, error: Swift.Error?) throws -> Self.SerializedObject
}
extension AlamofireDataRequest {
  @discardableResult
  public func response(queue: Dispatch.DispatchQueue = .main, completionHandler: @escaping (SalemoveSDK.AFDataResponse<Foundation.Data?>) -> Swift.Void) -> Self
  @discardableResult
  public func response<Serializer>(queue: Dispatch.DispatchQueue = .main, responseSerializer: Serializer, completionHandler: @escaping (SalemoveSDK.AFDataResponse<Serializer.SerializedObject>) -> Swift.Void) -> Self where Serializer : SalemoveSDK.DataResponseSerializerProtocol
}
extension AlamofireDownloadRequest {
  @discardableResult
  public func response(queue: Dispatch.DispatchQueue = .main, completionHandler: @escaping (SalemoveSDK.AFDownloadResponse<Foundation.URL?>) -> Swift.Void) -> Self
  @discardableResult
  public func response<Serializer>(queue: Dispatch.DispatchQueue = .main, responseSerializer: Serializer, completionHandler: @escaping (SalemoveSDK.AFDownloadResponse<Serializer.SerializedObject>) -> Swift.Void) -> Self where Serializer : SalemoveSDK.DownloadResponseSerializerProtocol
}
public struct URLResponseSerializer : SalemoveSDK.DownloadResponseSerializerProtocol {
  public init()
  public func serializeDownload(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, fileURL: Foundation.URL?, error: Swift.Error?) throws -> Foundation.URL
  public typealias SerializedObject = Foundation.URL
}
extension AlamofireDownloadRequest {
  @discardableResult
  public func responseURL(queue: Dispatch.DispatchQueue = .main, completionHandler: @escaping (SalemoveSDK.AFDownloadResponse<Foundation.URL>) -> Swift.Void) -> Self
}
final public class DataResponseSerializer : SalemoveSDK.ResponseSerializer {
  final public let dataPreprocessor: SalemoveSDK.DataPreprocessor
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<SalemoveSDK.AlamofireHTTPMethod>
  public init(dataPreprocessor: SalemoveSDK.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SalemoveSDK.AlamofireHTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods)
  final public func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) throws -> Foundation.Data
  public typealias SerializedObject = Foundation.Data
  @objc deinit
}
extension AlamofireDataRequest {
  @discardableResult
  public func responseData(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: SalemoveSDK.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SalemoveSDK.AlamofireHTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods, completionHandler: @escaping (SalemoveSDK.AFDataResponse<Foundation.Data>) -> Swift.Void) -> Self
}
extension AlamofireDownloadRequest {
  @discardableResult
  public func responseData(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: SalemoveSDK.DataPreprocessor = DataResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = DataResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SalemoveSDK.AlamofireHTTPMethod> = DataResponseSerializer.defaultEmptyRequestMethods, completionHandler: @escaping (SalemoveSDK.AFDownloadResponse<Foundation.Data>) -> Swift.Void) -> Self
}
final public class StringResponseSerializer : SalemoveSDK.ResponseSerializer {
  final public let dataPreprocessor: SalemoveSDK.DataPreprocessor
  final public let encoding: Swift.String.Encoding?
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<SalemoveSDK.AlamofireHTTPMethod>
  public init(dataPreprocessor: SalemoveSDK.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SalemoveSDK.AlamofireHTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods)
  final public func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) throws -> Swift.String
  public typealias SerializedObject = Swift.String
  @objc deinit
}
extension AlamofireDataRequest {
  @discardableResult
  public func responseString(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: SalemoveSDK.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SalemoveSDK.AlamofireHTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods, completionHandler: @escaping (SalemoveSDK.AFDataResponse<Swift.String>) -> Swift.Void) -> Self
}
extension AlamofireDownloadRequest {
  @discardableResult
  public func responseString(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: SalemoveSDK.DataPreprocessor = StringResponseSerializer.defaultDataPreprocessor, encoding: Swift.String.Encoding? = nil, emptyResponseCodes: Swift.Set<Swift.Int> = StringResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SalemoveSDK.AlamofireHTTPMethod> = StringResponseSerializer.defaultEmptyRequestMethods, completionHandler: @escaping (SalemoveSDK.AFDownloadResponse<Swift.String>) -> Swift.Void) -> Self
}
final public class JSONResponseSerializer : SalemoveSDK.ResponseSerializer {
  final public let dataPreprocessor: SalemoveSDK.DataPreprocessor
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<SalemoveSDK.AlamofireHTTPMethod>
  final public let options: Foundation.JSONSerialization.ReadingOptions
  public init(dataPreprocessor: SalemoveSDK.DataPreprocessor = JSONResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = JSONResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SalemoveSDK.AlamofireHTTPMethod> = JSONResponseSerializer.defaultEmptyRequestMethods, options: Foundation.JSONSerialization.ReadingOptions = .allowFragments)
  final public func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) throws -> Any
  public typealias SerializedObject = Any
  @objc deinit
}
extension AlamofireDataRequest {
  @discardableResult
  public func responseJSON(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: SalemoveSDK.DataPreprocessor = JSONResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = JSONResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SalemoveSDK.AlamofireHTTPMethod> = JSONResponseSerializer.defaultEmptyRequestMethods, options: Foundation.JSONSerialization.ReadingOptions = .allowFragments, completionHandler: @escaping (SalemoveSDK.AFDataResponse<Any>) -> Swift.Void) -> Self
}
extension AlamofireDownloadRequest {
  @discardableResult
  public func responseJSON(queue: Dispatch.DispatchQueue = .main, dataPreprocessor: SalemoveSDK.DataPreprocessor = JSONResponseSerializer.defaultDataPreprocessor, emptyResponseCodes: Swift.Set<Swift.Int> = JSONResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SalemoveSDK.AlamofireHTTPMethod> = JSONResponseSerializer.defaultEmptyRequestMethods, options: Foundation.JSONSerialization.ReadingOptions = .allowFragments, completionHandler: @escaping (SalemoveSDK.AFDownloadResponse<Any>) -> Swift.Void) -> Self
}
public protocol EmptyResponse {
  static func emptyValue() -> Self
}
public struct Empty : Swift.Codable {
  public static let value: SalemoveSDK.Empty
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension Empty : SalemoveSDK.EmptyResponse {
  public static func emptyValue() -> SalemoveSDK.Empty
}
public protocol DataDecoder {
  func decode<D>(_ type: D.Type, from data: Foundation.Data) throws -> D where D : Swift.Decodable
}
extension JSONDecoder : SalemoveSDK.DataDecoder {
}
extension PropertyListDecoder : SalemoveSDK.DataDecoder {
}
final public class DecodableResponseSerializer<T> : SalemoveSDK.ResponseSerializer where T : Swift.Decodable {
  final public let dataPreprocessor: SalemoveSDK.DataPreprocessor
  final public let decoder: SalemoveSDK.DataDecoder
  final public let emptyResponseCodes: Swift.Set<Swift.Int>
  final public let emptyRequestMethods: Swift.Set<SalemoveSDK.AlamofireHTTPMethod>
  public init(dataPreprocessor: SalemoveSDK.DataPreprocessor = DecodableResponseSerializer.defaultDataPreprocessor, decoder: SalemoveSDK.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SalemoveSDK.AlamofireHTTPMethod> = DecodableResponseSerializer.defaultEmptyRequestMethods)
  final public func serialize(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, error: Swift.Error?) throws -> T
  public typealias SerializedObject = T
  @objc deinit
}
extension AlamofireDataRequest {
  @discardableResult
  public func responseDecodable<T>(of type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, dataPreprocessor: SalemoveSDK.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: SalemoveSDK.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SalemoveSDK.AlamofireHTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods, completionHandler: @escaping (SalemoveSDK.AFDataResponse<T>) -> Swift.Void) -> Self where T : Swift.Decodable
}
extension AlamofireDownloadRequest {
  @discardableResult
  public func responseDecodable<T>(of type: T.Type = T.self, queue: Dispatch.DispatchQueue = .main, dataPreprocessor: SalemoveSDK.DataPreprocessor = DecodableResponseSerializer<T>.defaultDataPreprocessor, decoder: SalemoveSDK.DataDecoder = JSONDecoder(), emptyResponseCodes: Swift.Set<Swift.Int> = DecodableResponseSerializer<T>.defaultEmptyResponseCodes, emptyRequestMethods: Swift.Set<SalemoveSDK.AlamofireHTTPMethod> = DecodableResponseSerializer<T>.defaultEmptyRequestMethods, completionHandler: @escaping (SalemoveSDK.AFDownloadResponse<T>) -> Swift.Void) -> Self where T : Swift.Decodable
}
public protocol DataStreamSerializer {
  associatedtype SerializedObject
  func serialize(_ data: Foundation.Data) throws -> Self.SerializedObject
}
public struct DecodableStreamSerializer<T> : SalemoveSDK.DataStreamSerializer where T : Swift.Decodable {
  public let decoder: SalemoveSDK.DataDecoder
  public let dataPreprocessor: SalemoveSDK.DataPreprocessor
  public init(decoder: SalemoveSDK.DataDecoder = JSONDecoder(), dataPreprocessor: SalemoveSDK.DataPreprocessor = PassthroughPreprocessor())
  public func serialize(_ data: Foundation.Data) throws -> T
  public typealias SerializedObject = T
}
public struct PassthroughStreamSerializer : SalemoveSDK.DataStreamSerializer {
  public func serialize(_ data: Foundation.Data) throws -> Foundation.Data
  public typealias SerializedObject = Foundation.Data
}
public struct StringStreamSerializer : SalemoveSDK.DataStreamSerializer {
  public func serialize(_ data: Foundation.Data) throws -> Swift.String
  public typealias SerializedObject = Swift.String
}
extension DataStreamRequest {
  @discardableResult
  final public func responseStream(on queue: Dispatch.DispatchQueue = .main, stream: @escaping SalemoveSDK.DataStreamRequest.Handler<Foundation.Data, Swift.Never>) -> Self
  @discardableResult
  final public func responseStream<Serializer>(using serializer: Serializer, on queue: Dispatch.DispatchQueue = .main, stream: @escaping SalemoveSDK.DataStreamRequest.Handler<Serializer.SerializedObject, SalemoveSDK.AFError>) -> Self where Serializer : SalemoveSDK.DataStreamSerializer
  @discardableResult
  final public func responseStreamString(on queue: Dispatch.DispatchQueue = .main, stream: @escaping SalemoveSDK.DataStreamRequest.Handler<Swift.String, Swift.Never>) -> Self
  @discardableResult
  final public func responseStreamDecodable<T>(of type: T.Type = T.self, on queue: Dispatch.DispatchQueue = .main, using decoder: SalemoveSDK.DataDecoder = JSONDecoder(), preprocessor: SalemoveSDK.DataPreprocessor = PassthroughPreprocessor(), stream: @escaping SalemoveSDK.DataStreamRequest.Handler<T, SalemoveSDK.AFError>) -> Self where T : Swift.Decodable
}
extension SignalProducer {
  @available(*, unavailable, message: "Transform the error to `Never` beforehand, or use `startWithResult` instead")
  @discardableResult
  public func startWithValues(_ action: @escaping (Value) -> Swift.Void) -> SalemoveSDK.Disposable
}
extension Signal {
  @available(*, unavailable, message: "Transform the error to `Never` beforehand, or use `observeResult` instead")
  @discardableResult
  final public func observeValues(_ action: @escaping (Value) -> Swift.Void) -> SalemoveSDK.Disposable?
}
extension SignalProducer where Value == Swift.Never {
  @discardableResult
  @available(*, deprecated, message: "`Result.success` is never delivered - value type `Never` is uninstantiable (Use at runtime would trap)")
  public func startWithResult(_ action: @escaping (Swift.Result<Value, Error>) -> Swift.Void) -> SalemoveSDK.Disposable
}
extension SignalProducer where Value == Swift.Never, Error == Swift.Never {
  @discardableResult
  @available(*, deprecated, message: "Observer is never called - value type `Never` and error type `Never` are uninstantiable (Use at runtime would trap)")
  public func startWithResult(_ action: @escaping (Swift.Result<Value, Error>) -> Swift.Void) -> SalemoveSDK.Disposable
  @discardableResult
  @available(*, deprecated, message: "Observer is never called - value type `Never` is uninstantiable (Use at runtime would trap)")
  public func startWithValues(_ action: @escaping (Value) -> Swift.Void) -> SalemoveSDK.Disposable
}
extension SignalProducer where Error == Swift.Never {
  @discardableResult
  @available(*, deprecated, message: "Observer is never called - error type `Never` is uninstantiable (Use at runtime would trap)")
  public func startWithFailed(_ action: @escaping (Error) -> Swift.Void) -> SalemoveSDK.Disposable
}
extension Signal where Value == Swift.Never {
  @discardableResult
  @available(*, deprecated, message: "`Result.success` is never delivered - value type `Never` is uninstantiable (Use at runtime would trap)")
  final public func observeResult(_ action: @escaping (Swift.Result<Value, Error>) -> Swift.Void) -> SalemoveSDK.Disposable?
}
extension Signal where Value == Swift.Never, Error == Swift.Never {
  @discardableResult
  @available(*, deprecated, message: "Observer is never called - value type `Never` and error type `Never` are uninstantiable (Use at runtime would trap)")
  final public func observeResult(_ action: @escaping (Swift.Result<Value, Error>) -> Swift.Void) -> SalemoveSDK.Disposable?
  @discardableResult
  @available(*, deprecated, message: "Observer is never called - value type `Never` is uninstantiable (Use at runtime would trap)")
  final public func observeValues(_ action: @escaping (Value) -> Swift.Void) -> SalemoveSDK.Disposable?
}
extension Signal where Error == Swift.Never {
  @discardableResult
  @available(*, deprecated, message: "Observer is never invoked - error type `Never` is uninstantiable (Use at runtime would trap)")
  final public func observeFailed(_ action: @escaping (Error) -> Swift.Void) -> SalemoveSDK.Disposable?
}
extension SignalProducer where Value == Swift.Never {
  @discardableResult
  @available(*, deprecated, message: "Use `promoteValue` instead - value type `Never` is uninstantiable (Use at runtime would trap)")
  public func flatMap<Inner>(_ strategy: SalemoveSDK.FlattenStrategy, _ transform: @escaping (Value) -> Inner) -> SalemoveSDK.SignalProducer<Inner.Value, Error> where Error == Inner.Error, Inner : SalemoveSDK.SignalProducerConvertible
  @discardableResult
  @available(*, deprecated, message: "Use `promoteValue` instead - value type `Never` is uninstantiable (Use at runtime would trap)")
  public func flatMap<Inner>(_ strategy: SalemoveSDK.FlattenStrategy, _ transform: @escaping (Value) -> Inner) -> SalemoveSDK.SignalProducer<Inner.Value, Error> where Inner : SalemoveSDK.SignalProducerConvertible, Inner.Error == Swift.Never
}
extension SignalProducer where Value == Swift.Never, Error == Swift.Never {
  @discardableResult
  @available(*, deprecated, message: "Use `promoteValue` instead - value type `Never` and error type `Never` are uninstantiable (Use at runtime would trap)")
  public func flatMap<Inner>(_ strategy: SalemoveSDK.FlattenStrategy, _ transform: @escaping (Value) -> Inner) -> SalemoveSDK.SignalProducer<Inner.Value, Inner.Error> where Inner : SalemoveSDK.SignalProducerConvertible
  @discardableResult
  @available(*, deprecated, message: "Use `promoteValue` instead - value type `Never` and error type `Never` are uninstantiable (Use at runtime would trap)")
  public func flatMap<Inner>(_ strategy: SalemoveSDK.FlattenStrategy, _ transform: @escaping (Value) -> Inner) -> SalemoveSDK.SignalProducer<Inner.Value, Inner.Error> where Inner : SalemoveSDK.SignalProducerConvertible, Inner.Error == Swift.Never
}
extension SignalProducer where Error == Swift.Never {
  @discardableResult
  @available(*, deprecated, message: "Use `promoteError` instead - error type `Never` is uninstantiable (Use at runtime would trap)")
  public func flatMapError<NewError>(_ transform: @escaping (Error) -> SalemoveSDK.SignalProducer<Value, NewError>) -> SalemoveSDK.SignalProducer<Value, NewError> where NewError : Swift.Error
}
extension Signal where Value == Swift.Never {
  @discardableResult
  @available(*, deprecated, message: "Use `promoteValue` instead - value type `Never` is uninstantiable (Use at runtime would trap)")
  final public func flatMap<Inner>(_ strategy: SalemoveSDK.FlattenStrategy, _ transform: @escaping (Value) -> Inner) -> SalemoveSDK.Signal<Inner.Value, Error> where Error == Inner.Error, Inner : SalemoveSDK.SignalProducerConvertible
  @discardableResult
  @available(*, deprecated, message: "Use `promoteValue` instead - value type `Never` is uninstantiable (Use at runtime would trap)")
  final public func flatMap<Inner>(_ strategy: SalemoveSDK.FlattenStrategy, _ transform: @escaping (Value) -> Inner) -> SalemoveSDK.Signal<Inner.Value, Error> where Inner : SalemoveSDK.SignalProducerConvertible, Inner.Error == Swift.Never
}
extension Signal where Value == Swift.Never, Error == Swift.Never {
  @discardableResult
  @available(*, deprecated, message: "Use `promoteValue` instead - value type `Never` and error type `Never` are uninstantiable (Use at runtime would trap)")
  final public func flatMap<Inner>(_ strategy: SalemoveSDK.FlattenStrategy, _ transform: @escaping (Value) -> Inner) -> SalemoveSDK.Signal<Inner.Value, Inner.Error> where Inner : SalemoveSDK.SignalProducerConvertible
  @discardableResult
  @available(*, deprecated, message: "Use `promoteValue` instead - value type `Never` and error type `Never` are uninstantiable (Use at runtime would trap)")
  final public func flatMap<Inner>(_ strategy: SalemoveSDK.FlattenStrategy, _ transform: @escaping (Value) -> Inner) -> SalemoveSDK.Signal<Inner.Value, Inner.Error> where Inner : SalemoveSDK.SignalProducerConvertible, Inner.Error == Swift.Never
}
extension Signal where Error == Swift.Never {
  @discardableResult
  @available(*, deprecated, message: "Use `promoteError` instead - error type `Never` is uninstantiable (Use at runtime would trap)")
  final public func flatMapError<NewError>(_ transform: @escaping (Error) -> SalemoveSDK.SignalProducer<Value, NewError>) -> SalemoveSDK.Signal<Value, NewError> where NewError : Swift.Error
}
extension MoyaProvider : SalemoveSDK.ReactiveExtensionsProvider {
}
public protocol OptionalProtocol : Swift.ExpressibleByNilLiteral {
  associatedtype Wrapped
  init(reconstructing value: Self.Wrapped?)
  var optional: Self.Wrapped? { get }
}
extension Optional : SalemoveSDK.OptionalProtocol {
  public var optional: Wrapped? {
    get
  }
  public init(reconstructing value: Wrapped?)
}
@objc open class Text : SalemoveSDK.Node {
  final public let textVar: SalemoveSDK.Variable<Swift.String>
  open var text: Swift.String {
    get
    set(val)
  }
  final public let fontVar: SalemoveSDK.Variable<SalemoveSDK.Font?>
  open var font: SalemoveSDK.Font? {
    get
    set(val)
  }
  final public let fillVar: SalemoveSDK.Variable<SalemoveSDK.Fill?>
  open var fill: SalemoveSDK.Fill? {
    get
    set(val)
  }
  final public let strokeVar: SalemoveSDK.Variable<SalemoveSDK.Stroke?>
  open var stroke: SalemoveSDK.Stroke? {
    get
    set(val)
  }
  final public let alignVar: SalemoveSDK.Variable<SalemoveSDK.Align>
  open var align: SalemoveSDK.Align {
    get
    set(val)
  }
  final public let baselineVar: SalemoveSDK.Variable<SalemoveSDK.Baseline>
  open var baseline: SalemoveSDK.Baseline {
    get
    set(val)
  }
  final public let kerningVar: SalemoveSDK.Variable<Swift.Float>
  open var kerning: Swift.Float {
    get
    set(val)
  }
  public init(text: Swift.String, font: SalemoveSDK.Font? = nil, fill: SalemoveSDK.Fill? = Color.black, stroke: SalemoveSDK.Stroke? = nil, align: SalemoveSDK.Align = .min, baseline: SalemoveSDK.Baseline = .top, kerning: Swift.Float = 0.0, place: SalemoveSDK.Transform = Transform.identity, opaque: Swift.Bool = true, opacity: Swift.Double = 1, clip: SalemoveSDK.Locus? = nil, mask: SalemoveSDK.Node? = nil, effect: SalemoveSDK.Effect? = nil, visible: Swift.Bool = true, tag: [Swift.String] = [])
  override open var bounds: SalemoveSDK.Rect {
    get
  }
  override public init(place: SalemoveSDK.Transform = super, opaque: Swift.Bool = super, opacity: Swift.Double = super, clip: SalemoveSDK.Locus? = super, mask: SalemoveSDK.Node? = super, effect: SalemoveSDK.Effect? = super, visible: Swift.Bool = super, tag: [Swift.String] = super)
  @objc deinit
}
@objc public protocol AudioStreamable {
  @objc @available(iOS, obsoleted: 10.0, message: "Audio is now played automatically when media is established")
  func playAudio()
  @objc func mute()
  @objc func unmute()
  @objc var isMuted: Swift.Bool { get }
  @objc var isRemote: Swift.Bool { get }
}
@objc public protocol VideoStreamable {
  @objc func getStreamView() -> SalemoveSDK.StreamView
  @objc func playVideo()
  @objc func pause()
  @objc func resume()
  @objc func stop()
  @objc var isPaused: Swift.Bool { get }
  @objc var isRemote: Swift.Bool { get }
}
@objc @_inheritsConvenienceInitializers public class SalemoveAppDelegate : ObjectiveC.NSObject, UIKit.UIApplicationDelegate {
  @discardableResult
  public func application(_ application: UIKit.UIApplication, didFinishLaunchingWithOptions launchOptions: [UIKit.UIApplication.LaunchOptionsKey : Any]? = nil, enablePushNotifications isPushNotificationsEnabled: Swift.Bool = false) -> Swift.Bool
  @objc public func applicationDidBecomeActive(_ application: UIKit.UIApplication)
  @objc public func application(_ application: UIKit.UIApplication, didRegisterForRemoteNotificationsWithDeviceToken deviceToken: Foundation.Data)
  @objc public func application(_ application: UIKit.UIApplication, didFailToRegisterForRemoteNotificationsWithError error: Swift.Error)
  @objc override dynamic public init()
  @objc deinit
}
@_hasMissingDesignatedInitializers public class SwiftPhoenixClientMessage {
  final public let ref: Swift.String
  final public let topic: Swift.String
  final public let event: Swift.String
  public var payload: SalemoveSDK.Payload
  public var status: Swift.String? {
    get
  }
  @objc deinit
}
extension Salemove {
  @available(*, deprecated, message: "Use fetchFile(engagementFile:progress:completion:) instead")
  @objc final public func fetchFile(_ id: Swift.String, progress: SalemoveSDK.EngagementFileProgressBlock?, completion: @escaping SalemoveSDK.EngagementFileFetchCompletionBlock)
}
@objc final public class SocketEngine : ObjectiveC.NSObject, Foundation.URLSessionDelegate, SalemoveSDK.SocketEnginePollable, SalemoveSDK.SocketEngineWebsocket {
  @objc final public let engineQueue: Dispatch.DispatchQueue
  @objc final public var connectParams: [Swift.String : Any]? {
    @objc get
    @objc set
  }
  final public var postWait: [Swift.String]
  final public var waitingForPoll: Swift.Bool
  final public var waitingForPost: Swift.Bool
  @objc final public var closed: Swift.Bool {
    get
  }
  @objc final public var connected: Swift.Bool {
    get
  }
  @objc final public var cookies: [Foundation.HTTPCookie]? {
    get
  }
  @objc final public var doubleEncodeUTF8: Swift.Bool {
    get
  }
  @objc final public var extraHeaders: [Swift.String : Swift.String]? {
    get
  }
  @objc final public var fastUpgrade: Swift.Bool {
    get
  }
  @objc final public var forcePolling: Swift.Bool {
    get
  }
  @objc final public var forceWebsockets: Swift.Bool {
    get
  }
  final public var invalidated: Swift.Bool {
    get
  }
  @objc final public var polling: Swift.Bool {
    get
  }
  @objc final public var probing: Swift.Bool {
    get
  }
  final public var session: Foundation.URLSession? {
    get
  }
  @objc final public var sid: Swift.String {
    get
  }
  @objc final public var socketPath: Swift.String {
    get
  }
  @objc final public var urlPolling: Foundation.URL {
    get
  }
  @objc final public var urlWebSocket: Foundation.URL {
    get
  }
  @objc final public var websocket: Swift.Bool {
    get
  }
  @objc final public var ws: SalemoveSDK.SocketIOWebSocket? {
    get
  }
  @objc weak final public var client: SalemoveSDK.SocketEngineClient?
  public init(client: SalemoveSDK.SocketEngineClient, url: Foundation.URL, config: SalemoveSDK.SocketIOClientConfiguration)
  @objc convenience public init(client: SalemoveSDK.SocketEngineClient, url: Foundation.URL, options: Foundation.NSDictionary?)
  @objc deinit
  @objc final public func connect()
  @objc final public func didError(reason: Swift.String)
  @objc final public func disconnect(reason: Swift.String)
  @objc final public func doFastUpgrade()
  @objc final public func flushWaitingForPostToWebSocket()
  @objc final public func parseEngineData(_ data: Foundation.Data)
  @objc final public func parseEngineMessage(_ message: Swift.String, fromPolling: Swift.Bool)
  @objc final public func write(_ msg: Swift.String, withType type: SalemoveSDK.SocketEnginePacketType, withData data: [Foundation.Data])
  final public func websocketDidConnect(socket: SalemoveSDK.SocketIOWebSocket)
  final public func websocketDidDisconnect(socket: SalemoveSDK.SocketIOWebSocket, error: Foundation.NSError?)
  @objc override dynamic public init()
}
extension SocketEngine {
  final public func URLSession(session: Foundation.URLSession, didBecomeInvalidWithError error: Foundation.NSError?)
}
@objc public enum SocketIOClientStatus : Swift.Int {
  case notConnected
  case disconnected
  case connecting
  case connected
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc open class MacawImage : SalemoveSDK.Node {
  final public let srcVar: SalemoveSDK.Variable<Swift.String>
  open var src: Swift.String {
    get
    set(val)
  }
  final public let xAlignVar: SalemoveSDK.Variable<SalemoveSDK.Align>
  open var xAlign: SalemoveSDK.Align {
    get
    set(val)
  }
  final public let yAlignVar: SalemoveSDK.Variable<SalemoveSDK.Align>
  open var yAlign: SalemoveSDK.Align {
    get
    set(val)
  }
  final public let aspectRatioVar: SalemoveSDK.Variable<SalemoveSDK.AspectRatio>
  open var aspectRatio: SalemoveSDK.AspectRatio {
    get
    set(val)
  }
  final public let wVar: SalemoveSDK.Variable<Swift.Int>
  open var w: Swift.Int {
    get
    set(val)
  }
  final public let hVar: SalemoveSDK.Variable<Swift.Int>
  open var h: Swift.Int {
    get
    set(val)
  }
  public init(src: Swift.String, xAlign: SalemoveSDK.Align = .min, yAlign: SalemoveSDK.Align = .min, aspectRatio: SalemoveSDK.AspectRatio = .none, w: Swift.Int = 0, h: Swift.Int = 0, place: SalemoveSDK.Transform = Transform.identity, opaque: Swift.Bool = true, opacity: Swift.Double = 1, clip: SalemoveSDK.Locus? = nil, mask: SalemoveSDK.Node? = nil, effect: SalemoveSDK.Effect? = nil, visible: Swift.Bool = true, tag: [Swift.String] = [])
  public init(image: SalemoveSDK.MImage, xAlign: SalemoveSDK.Align = .min, yAlign: SalemoveSDK.Align = .min, aspectRatio: SalemoveSDK.AspectRatio = .none, w: Swift.Int = 0, h: Swift.Int = 0, place: SalemoveSDK.Transform = Transform.identity, opaque: Swift.Bool = true, opacity: Swift.Double = 1, clip: SalemoveSDK.Locus? = nil, effect: SalemoveSDK.Effect? = nil, visible: Swift.Bool = true, tag: [Swift.String] = [])
  override open var bounds: SalemoveSDK.Rect? {
    get
  }
  override public init(place: SalemoveSDK.Transform = super, opaque: Swift.Bool = super, opacity: Swift.Double = super, clip: SalemoveSDK.Locus? = super, mask: SalemoveSDK.Node? = super, effect: SalemoveSDK.Effect? = super, visible: Swift.Bool = super, tag: [Swift.String] = super)
  @objc deinit
}
@objc open class SocketIOClient : ObjectiveC.NSObject, SalemoveSDK.SocketEngineClient {
  final public let socketURL: Foundation.URL
  public var engine: SalemoveSDK.SocketEngineSpec? {
    get
  }
  public var status: SalemoveSDK.SocketIOClientStatus {
    get
  }
  public var forceNew: Swift.Bool
  public var handleQueue: Dispatch.DispatchQueue
  public var nsp: Swift.String
  public var config: SalemoveSDK.SocketIOClientConfiguration
  public var reconnects: Swift.Bool
  public var reconnectWait: Swift.Int
  public var sid: Swift.String? {
    get
  }
  public init(socketURL: Foundation.URL, config: SalemoveSDK.SocketIOClientConfiguration = [])
  convenience public init(socketURL: Foundation.NSURL, config: Foundation.NSDictionary?)
  @objc deinit
  open func connect()
  open func connect(timeoutAfter: Swift.Int, withHandler handler: (() -> Swift.Void)?)
  open func disconnect()
  open func emit(_ event: Swift.String, _ items: SalemoveSDK.SocketData...)
  open func emit(_ event: Swift.String, with items: [Any])
  open func emitWithAck(_ event: Swift.String, _ items: SalemoveSDK.SocketData...) -> SalemoveSDK.OnAckCallback
  open func emitWithAck(_ event: Swift.String, with items: [Any]) -> SalemoveSDK.OnAckCallback
  @objc open func engineDidClose(reason: Swift.String)
  @objc open func engineDidError(reason: Swift.String)
  @objc open func engineDidOpen(reason: Swift.String)
  open func handleEvent(_ event: Swift.String, data: [Any], isInternalMessage: Swift.Bool, withAck ack: Swift.Int = -1)
  open func leaveNamespace()
  open func joinNamespace(_ namespace: Swift.String)
  open func off(_ event: Swift.String)
  open func off(id: Foundation.UUID)
  @discardableResult
  open func on(_ event: Swift.String, callback: @escaping SalemoveSDK.NormalCallback) -> Foundation.UUID
  @discardableResult
  open func on(clientEvent event: SalemoveSDK.SocketClientEvent, callback: @escaping SalemoveSDK.NormalCallback) -> Foundation.UUID
  @discardableResult
  open func once(_ event: Swift.String, callback: @escaping SalemoveSDK.NormalCallback) -> Foundation.UUID
  open func onAny(_ handler: @escaping (SalemoveSDK.SocketAnyEvent) -> Swift.Void)
  @objc public func parseEngineMessage(_ msg: Swift.String)
  @objc public func parseEngineBinaryData(_ data: Foundation.Data)
  open func reconnect()
  open func removeAllHandlers()
  @objc override dynamic public init()
}
public let SocketIOWebsocketDidConnectNotification: Swift.String
public let SocketIOWebsocketDidDisconnectNotification: Swift.String
public let SocketIOWebsocketDisconnectionErrorKeyName: Swift.String
public protocol SocketIOWebSocketDelegate : AnyObject {
  func websocketDidConnect(socket: SalemoveSDK.SocketIOWebSocket)
  func websocketDidDisconnect(socket: SalemoveSDK.SocketIOWebSocket, error: Foundation.NSError?)
  func websocketDidReceiveMessage(socket: SalemoveSDK.SocketIOWebSocket, text: Swift.String)
  func websocketDidReceiveData(socket: SalemoveSDK.SocketIOWebSocket, data: Foundation.Data)
}
public protocol SocketIOWebSocketPongDelegate : AnyObject {
  func websocketDidReceivePong(socket: SalemoveSDK.SocketIOWebSocket, data: Foundation.Data?)
}
@objc open class SocketIOWebSocket : ObjectiveC.NSObject, Foundation.StreamDelegate {
  public enum CloseCode : Swift.UInt16 {
    case normal
    case goingAway
    case protocolError
    case protocolUnhandledType
    case noStatusReceived
    case encoding
    case policyViolated
    case messageTooBig
    public init?(rawValue: Swift.UInt16)
    public typealias RawValue = Swift.UInt16
    public var rawValue: Swift.UInt16 {
      get
    }
  }
  public static let ErrorDomain: Swift.String
  public var callbackQueue: Dispatch.DispatchQueue
  weak public var delegate: SalemoveSDK.SocketIOWebSocketDelegate?
  weak public var pongDelegate: SalemoveSDK.SocketIOWebSocketPongDelegate?
  public var onConnect: (() -> Swift.Void)?
  public var onDisconnect: ((Foundation.NSError?) -> Swift.Void)?
  public var onText: ((Swift.String) -> Swift.Void)?
  public var onData: ((Foundation.Data) -> Swift.Void)?
  public var onPong: ((Foundation.Data?) -> Swift.Void)?
  public var headers: [Swift.String : Swift.String]
  public var voipEnabled: Swift.Bool
  public var disableSSLCertValidation: Swift.Bool
  public var security: SalemoveSDK.SocketIOSSLTrustValidator?
  public var enabledSSLCipherSuites: [Security.SSLCipherSuite]?
  public var origin: Swift.String?
  public var timeout: Swift.Int
  public var isConnected: Swift.Bool {
    get
  }
  public var currentURL: Foundation.URL {
    get
  }
  public init(url: Foundation.URL, protocols: [Swift.String]? = nil)
  convenience public init(url: Foundation.URL, writeQueueQOS: Foundation.QualityOfService, protocols: [Swift.String]? = nil)
  open func connect()
  open func disconnect(forceTimeout: Foundation.TimeInterval? = nil, closeCode: Swift.UInt16 = CloseCode.normal.rawValue)
  open func write(string: Swift.String, completion: (() -> ())? = nil)
  open func write(data: Foundation.Data, completion: (() -> ())? = nil)
  open func write(ping: Foundation.Data, completion: (() -> ())? = nil)
  @objc open func stream(_ aStream: Foundation.Stream, handle eventCode: Foundation.Stream.Event)
  @objc deinit
  @objc override dynamic public init()
}
public protocol TargetType {
  var baseURL: Foundation.URL { get }
  var path: Swift.String { get }
  var method: SalemoveSDK.MoyaMethod { get }
  var sampleData: Foundation.Data { get }
  var task: SalemoveSDK.Task { get }
  var validationType: SalemoveSDK.ValidationType { get }
  var headers: [Swift.String : Swift.String]? { get }
}
extension TargetType {
  public var validationType: SalemoveSDK.ValidationType {
    get
  }
}
extension MacawView {
  public func toPDF(size: CoreGraphics.CGSize, path: Foundation.URL)
}
final public class MoyaResponse : Swift.CustomDebugStringConvertible, Swift.Equatable {
  final public let statusCode: Swift.Int
  final public let data: Foundation.Data
  final public let request: Foundation.URLRequest?
  final public let response: Foundation.HTTPURLResponse?
  public init(statusCode: Swift.Int, data: Foundation.Data, request: Foundation.URLRequest? = nil, response: Foundation.HTTPURLResponse? = nil)
  final public var description: Swift.String {
    get
  }
  final public var debugDescription: Swift.String {
    get
  }
  public static func == (lhs: SalemoveSDK.MoyaResponse, rhs: SalemoveSDK.MoyaResponse) -> Swift.Bool
  @objc deinit
}
extension MoyaResponse {
  final public func filter<R>(statusCodes: R) throws -> SalemoveSDK.MoyaResponse where R : Swift.RangeExpression, R.Bound == Swift.Int
  final public func filter(statusCode: Swift.Int) throws -> SalemoveSDK.MoyaResponse
  final public func filterSuccessfulStatusCodes() throws -> SalemoveSDK.MoyaResponse
  final public func filterSuccessfulStatusAndRedirectCodes() throws -> SalemoveSDK.MoyaResponse
  final public func mapImage() throws -> SalemoveSDK.Image
  final public func mapJSON(failsOnEmptyData: Swift.Bool = true) throws -> Any
  final public func mapString(atKeyPath keyPath: Swift.String? = nil) throws -> Swift.String
  final public func map<D>(_ type: D.Type, atKeyPath keyPath: Swift.String? = nil, using decoder: Foundation.JSONDecoder = JSONDecoder(), failsOnEmptyData: Swift.Bool = true) throws -> D where D : Swift.Decodable
}
public enum ValidationType {
  case none
  case successCodes
  case successAndRedirectCodes
  case customCodes([Swift.Int])
}
extension ValidationType : Swift.Equatable {
  public static func == (lhs: SalemoveSDK.ValidationType, rhs: SalemoveSDK.ValidationType) -> Swift.Bool
}
@_hasMissingDesignatedInitializers public class Defaults {
  public static let timeoutInterval: Swift.Double
  public static let heartbeatInterval: Swift.Double
  public static let reconnectSteppedBackOff: (Swift.Int) -> Foundation.TimeInterval
  public static let rejoinSteppedBackOff: (Swift.Int) -> Foundation.TimeInterval
  public static let encode: ([Swift.String : Any]) -> Foundation.Data
  public static let decode: (Foundation.Data) -> [Swift.String : Any]?
  @objc deinit
}
public enum ChannelState : Swift.String {
  case closed
  case errored
  case joined
  case joining
  case leaving
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct ChannelEvent {
  public static let heartbeat: Swift.String
  public static let join: Swift.String
  public static let leave: Swift.String
  public static let reply: Swift.String
  public static let error: Swift.String
  public static let close: Swift.String
}
extension Salemove {
  @objc final public func waitForActiveEngagement(completion: @escaping SalemoveSDK.EngagementBlock)
  @objc final public func requestEngagementWith(selectedOperator: SalemoveSDK.Operator, visitorContext: SalemoveSDK.VisitorContext, completion: @escaping SalemoveSDK.EngagementSessionBlock)
  @objc final public func cancel(engagementRequest: SalemoveSDK.EngagementRequest, completion: @escaping SalemoveSDK.SuccessBlock)
  @objc final public func requestOperators(completion: @escaping SalemoveSDK.OperatorBlock)
  @objc final public func requestEngagedOperator(completion: @escaping SalemoveSDK.OperatorBlock)
  @objc final public func endEngagement(completion: @escaping SalemoveSDK.SuccessBlock)
}
@_inheritsConvenienceInitializers open class BlendEffect : SalemoveSDK.Effect {
  override public init(input: SalemoveSDK.Effect?)
  @objc deinit
}
open class Insets {
  final public let top: Swift.Double
  final public let right: Swift.Double
  final public let bottom: Swift.Double
  final public let left: Swift.Double
  public init(top: Swift.Double = 0, right: Swift.Double = 0, bottom: Swift.Double = 0, left: Swift.Double = 0)
  @objc deinit
}
@_hasMissingDesignatedInitializers open class MacawZoom {
  open func enable(move: Swift.Bool = true, scale: Swift.Bool = true, rotate: Swift.Bool = false)
  open func disable()
  open func set(offset: SalemoveSDK.Size? = nil, scale: Swift.Double? = nil, angle: Swift.Double? = nil)
  @objc deinit
}
public typealias ImageType = UIKit.UIImage
public typealias Image = SalemoveSDK.ImageType
extension Result : SalemoveSDK.SignalProducerConvertible {
  public var producer: SalemoveSDK.SignalProducer<Success, Failure> {
    get
  }
  public typealias Error = Failure
  public typealias Value = Success
}
@objc @_inheritsConvenienceInitializers open class SVGView : SalemoveSDK.MacawView {
  @objc @IBInspectable open var fileName: Swift.String? {
    @objc get
    @objc set
  }
  public init(node: SalemoveSDK.Node, frame: CoreGraphics.CGRect)
  @objc override public init?(node: SalemoveSDK.Node, coder aDecoder: Foundation.NSCoder)
  @objc required convenience dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc deinit
}
public enum MoyaError : Swift.Error {
  case imageMapping(SalemoveSDK.MoyaResponse)
  case jsonMapping(SalemoveSDK.MoyaResponse)
  case stringMapping(SalemoveSDK.MoyaResponse)
  case objectMapping(Swift.Error, SalemoveSDK.MoyaResponse)
  case encodableMapping(Swift.Error)
  case statusCode(SalemoveSDK.MoyaResponse)
  case underlying(Swift.Error, SalemoveSDK.MoyaResponse?)
  case requestMapping(Swift.String)
  case parameterEncoding(Swift.Error)
}
extension MoyaError {
  public var response: SalemoveSDK.MoyaResponse? {
    get
  }
}
extension MoyaError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
extension MoyaError : Foundation.CustomNSError {
  public var errorUserInfo: [Swift.String : Any] {
    get
  }
}
extension Rect : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public enum AnimationState {
  case initial
  case running
  case paused
  public static func == (a: SalemoveSDK.AnimationState, b: SalemoveSDK.AnimationState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class Animation {
  public func play()
  public func stop()
  public func pause()
  public func state() -> SalemoveSDK.AnimationState
  public func easing(_ easing: SalemoveSDK.Easing) -> SalemoveSDK.Animation
  public func delay(_ delay: Swift.Double) -> SalemoveSDK.Animation
  public func cycle(_ count: Swift.Double) -> SalemoveSDK.Animation
  public func cycle() -> SalemoveSDK.Animation
  public func reverse() -> SalemoveSDK.Animation
  public func autoreversed() -> SalemoveSDK.Animation
  @discardableResult
  public func onComplete(_: @escaping (() -> Swift.Void)) -> SalemoveSDK.Animation
  @objc deinit
}
public protocol Cancellable {
  var isCancelled: Swift.Bool { get }
  func cancel()
}
@_hasMissingDesignatedInitializers open class SVGConstants {
  public static let valueToColor: [Swift.Int : Swift.String]
  public static let colorList: [Swift.String : Swift.Int]
  public static let systemColorList: [Swift.String : Swift.Int]
  public static func valueToColor(_ color: Swift.Int) -> Swift.String?
  public static let defaultStrokeLineCap: SalemoveSDK.LineCap
  public static let defaultStrokeLineJoin: SalemoveSDK.LineJoin
  @objc deinit
}
extension Salemove : SalemoveSDK.PushNotificationHandling {
  @objc final public func userNotificationCenter(_ center: UserNotifications.UNUserNotificationCenter, willPresent notification: UserNotifications.UNNotification, withCompletionHandler completionHandler: @escaping (UserNotifications.UNNotificationPresentationOptions) -> Swift.Void)
  @objc final public func userNotificationCenter(_ center: UserNotifications.UNUserNotificationCenter, didReceive response: UserNotifications.UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -> Swift.Void)
}
public enum SocketIOClientOption {
  case connectParams([Swift.String : Any])
  case cookies([Foundation.HTTPCookie])
  case doubleEncodeUTF8(Swift.Bool)
  case extraHeaders([Swift.String : Swift.String])
  case forceNew(Swift.Bool)
  case forcePolling(Swift.Bool)
  case forceWebsockets(Swift.Bool)
  case handleQueue(Dispatch.DispatchQueue)
  case log(Swift.Bool)
  case logger(SalemoveSDK.SocketLogger)
  case nsp(Swift.String)
  case path(Swift.String)
  case reconnects(Swift.Bool)
  case reconnectAttempts(Swift.Int)
  case reconnectWait(Swift.Int)
  case secure(Swift.Bool)
  case security(SalemoveSDK.SocketIOSSLSecurity)
  case selfSigned(Swift.Bool)
  case sessionDelegate(Foundation.URLSessionDelegate)
  case voipEnabled(Swift.Bool)
  public var description: Swift.String {
    get
  }
  public static func == (lhs: SalemoveSDK.SocketIOClientOption, rhs: SalemoveSDK.SocketIOClientOption) -> Swift.Bool
}
public let AF: SalemoveSDK.AlamofireSession
public protocol ContentsInterpolation : SalemoveSDK.Interpolable {
}
extension Array : SalemoveSDK.ContentsInterpolation {
  public func interpolate(_ endValue: Swift.Array<Element>, progress: Swift.Double) -> Swift.Array<Element>
}
extension AlamofireRequest {
  public typealias ValidationResult = Swift.Result<Swift.Void, Swift.Error>
}
extension AlamofireDataRequest {
  public typealias Validation = (Foundation.URLRequest?, Foundation.HTTPURLResponse, Foundation.Data?) -> SalemoveSDK.AlamofireDataRequest.ValidationResult
  @discardableResult
  public func validate<S>(statusCode acceptableStatusCodes: S) -> Self where S : Swift.Sequence, S.Element == Swift.Int
  @discardableResult
  public func validate<S>(contentType acceptableContentTypes: @autoclosure @escaping () -> S) -> Self where S : Swift.Sequence, S.Element == Swift.String
  @discardableResult
  public func validate() -> Self
}
extension DataStreamRequest {
  public typealias Validation = (Foundation.URLRequest?, Foundation.HTTPURLResponse) -> SalemoveSDK.DataStreamRequest.ValidationResult
  @discardableResult
  final public func validate<S>(statusCode acceptableStatusCodes: S) -> Self where S : Swift.Sequence, S.Element == Swift.Int
  @discardableResult
  final public func validate<S>(contentType acceptableContentTypes: @autoclosure @escaping () -> S) -> Self where S : Swift.Sequence, S.Element == Swift.String
  @discardableResult
  final public func validate() -> Self
}
extension AlamofireDownloadRequest {
  public typealias Validation = (Foundation.URLRequest?, Foundation.HTTPURLResponse, Foundation.URL?) -> SalemoveSDK.AlamofireDownloadRequest.ValidationResult
  @discardableResult
  public func validate<S>(statusCode acceptableStatusCodes: S) -> Self where S : Swift.Sequence, S.Element == Swift.Int
  @discardableResult
  public func validate<S>(contentType acceptableContentTypes: @autoclosure @escaping () -> S) -> Self where S : Swift.Sequence, S.Element == Swift.String
  @discardableResult
  public func validate() -> Self
}
public enum LineCap {
  case butt
  case round
  case square
  public static func == (a: SalemoveSDK.LineCap, b: SalemoveSDK.LineCap) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension AnimatableVariable where T : SalemoveSDK.ContentsInterpolation {
  public func animation(_ f: @escaping (Swift.Double) -> [SalemoveSDK.Node]) -> SalemoveSDK.Animation
  public func animation(_ f: @escaping ((Swift.Double) -> [SalemoveSDK.Node]), during: Swift.Double = 1.0, delay: Swift.Double = 0.0) -> SalemoveSDK.Animation
  public func animation(during: Swift.Double = 1.0, delay: Swift.Double = 0.0, _ f: @escaping ((Swift.Double) -> [SalemoveSDK.Node])) -> SalemoveSDK.Animation
  public func animate(_ f: @escaping (Swift.Double) -> [SalemoveSDK.Node])
  public func animate(_ f: @escaping ((Swift.Double) -> [SalemoveSDK.Node]), during: Swift.Double = 1.0, delay: Swift.Double = 0.0)
  public func animate(during: Swift.Double = 1.0, delay: Swift.Double = 0.0, _ f: @escaping ((Swift.Double) -> [SalemoveSDK.Node]))
}
@_hasMissingDesignatedInitializers public class SwiftPhoenixClientPush {
  weak public var channel: SalemoveSDK.SwiftPhoenixClientChannel?
  final public let event: Swift.String
  public var payload: SalemoveSDK.Payload
  public var timeout: Foundation.TimeInterval
  public func resend(_ timeout: Foundation.TimeInterval = Defaults.timeoutInterval)
  public func send()
  @discardableResult
  public func receive(_ status: Swift.String, callback: @escaping ((SalemoveSDK.SwiftPhoenixClientMessage) -> ())) -> SalemoveSDK.SwiftPhoenixClientPush
  @discardableResult
  public func delegateReceive<Target>(_ status: Swift.String, to owner: Target, callback: @escaping ((Target, SalemoveSDK.SwiftPhoenixClientMessage) -> ())) -> SalemoveSDK.SwiftPhoenixClientPush where Target : AnyObject
  @objc deinit
}
public enum Baseline {
  case top
  case alphabetic
  case bottom
  case mid
  public static func == (a: SalemoveSDK.Baseline, b: SalemoveSDK.Baseline) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@objc public protocol SocketEngineClient {
  @objc func engineDidError(reason: Swift.String)
  @objc func engineDidClose(reason: Swift.String)
  @objc func engineDidOpen(reason: Swift.String)
  @objc func parseEngineMessage(_ msg: Swift.String)
  @objc func parseEngineBinaryData(_ data: Foundation.Data)
}
public struct SocketIOClientConfiguration : Swift.ExpressibleByArrayLiteral, Swift.Collection, Swift.MutableCollection {
  public typealias Element = SalemoveSDK.SocketIOClientOption
  public typealias Index = Swift.Array<SalemoveSDK.SocketIOClientOption>.Index
  public typealias Iterator = Swift.Array<SalemoveSDK.SocketIOClientOption>.Iterator
  public typealias SubSequence = Swift.Array<SalemoveSDK.SocketIOClientOption>.SubSequence
  public var startIndex: SalemoveSDK.SocketIOClientConfiguration.Index {
    get
  }
  public var endIndex: SalemoveSDK.SocketIOClientConfiguration.Index {
    get
  }
  public var isEmpty: Swift.Bool {
    get
  }
  public var count: SalemoveSDK.SocketIOClientConfiguration.Index.Stride {
    get
  }
  public var first: SalemoveSDK.SocketIOClientConfiguration.Element? {
    get
  }
  public subscript(position: SalemoveSDK.SocketIOClientConfiguration.Index) -> SalemoveSDK.SocketIOClientConfiguration.Element {
    get
    set
  }
  public subscript(bounds: Swift.Range<SalemoveSDK.SocketIOClientConfiguration.Index>) -> SalemoveSDK.SocketIOClientConfiguration.SubSequence {
    get
    set
  }
  public init(arrayLiteral elements: SalemoveSDK.SocketIOClientConfiguration.Element...)
  public func makeIterator() -> SalemoveSDK.SocketIOClientConfiguration.Iterator
  public func index(after i: SalemoveSDK.SocketIOClientConfiguration.Index) -> SalemoveSDK.SocketIOClientConfiguration.Index
  public mutating func insert(_ element: SalemoveSDK.SocketIOClientConfiguration.Element, replacing replace: Swift.Bool = true)
  public typealias ArrayLiteralElement = SalemoveSDK.SocketIOClientConfiguration.Element
  public typealias Indices = Swift.DefaultIndices<SalemoveSDK.SocketIOClientConfiguration>
}
final public class CredentialsPlugin : SalemoveSDK.PluginType {
  public typealias CredentialClosure = (SalemoveSDK.TargetType) -> Foundation.URLCredential?
  public init(credentialsClosure: @escaping SalemoveSDK.CredentialsPlugin.CredentialClosure)
  final public func willSend(_ request: SalemoveSDK.RequestType, target: SalemoveSDK.TargetType)
  @objc deinit
}
open class ServerTrustManager {
  final public let allHostsMustBeEvaluated: Swift.Bool
  final public let evaluators: [Swift.String : SalemoveSDK.ServerTrustEvaluating]
  public init(allHostsMustBeEvaluated: Swift.Bool = true, evaluators: [Swift.String : SalemoveSDK.ServerTrustEvaluating])
  open func serverTrustEvaluator(forHost host: Swift.String) throws -> SalemoveSDK.ServerTrustEvaluating?
  @objc deinit
}
public protocol ServerTrustEvaluating {
  func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
}
final public class DefaultTrustEvaluator : SalemoveSDK.ServerTrustEvaluating {
  public init(validateHost: Swift.Bool = true)
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
final public class RevocationTrustEvaluator : SalemoveSDK.ServerTrustEvaluating {
  public struct Options : Swift.OptionSet {
    public static let crl: SalemoveSDK.RevocationTrustEvaluator.Options
    public static let networkAccessDisabled: SalemoveSDK.RevocationTrustEvaluator.Options
    public static let ocsp: SalemoveSDK.RevocationTrustEvaluator.Options
    public static let preferCRL: SalemoveSDK.RevocationTrustEvaluator.Options
    public static let requirePositiveResponse: SalemoveSDK.RevocationTrustEvaluator.Options
    public static let any: SalemoveSDK.RevocationTrustEvaluator.Options
    public let rawValue: CoreFoundation.CFOptionFlags
    public init(rawValue: CoreFoundation.CFOptionFlags)
    public typealias ArrayLiteralElement = SalemoveSDK.RevocationTrustEvaluator.Options
    public typealias Element = SalemoveSDK.RevocationTrustEvaluator.Options
    public typealias RawValue = CoreFoundation.CFOptionFlags
  }
  public init(performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true, options: SalemoveSDK.RevocationTrustEvaluator.Options = .any)
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
final public class PinnedCertificatesTrustEvaluator : SalemoveSDK.ServerTrustEvaluating {
  public init(certificates: [Security.SecCertificate] = Bundle.main.af.certificates, acceptSelfSignedCertificates: Swift.Bool = false, performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true)
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
final public class PublicKeysTrustEvaluator : SalemoveSDK.ServerTrustEvaluating {
  public init(keys: [Security.SecKey] = Bundle.main.af.publicKeys, performDefaultValidation: Swift.Bool = true, validateHost: Swift.Bool = true)
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
final public class CompositeTrustEvaluator : SalemoveSDK.ServerTrustEvaluating {
  public init(evaluators: [SalemoveSDK.ServerTrustEvaluating])
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
@available(*, deprecated, renamed: "DisabledTrustEvaluator", message: "DisabledEvaluator has been renamed DisabledTrustEvaluator.")
public typealias DisabledEvaluator = SalemoveSDK.DisabledTrustEvaluator
final public class DisabledTrustEvaluator : SalemoveSDK.ServerTrustEvaluating {
  public init()
  final public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
  @objc deinit
}
extension Array where Element == SalemoveSDK.ServerTrustEvaluating {
  public func evaluate(_ trust: Security.SecTrust, forHost host: Swift.String) throws
}
extension Bundle : SalemoveSDK.AlamofireExtended {
  public typealias ExtendedType = Foundation.Bundle
}
extension AlamofireExtension where ExtendedType : Foundation.Bundle {
  public var certificates: [Security.SecCertificate] {
    get
  }
  public var publicKeys: [Security.SecKey] {
    get
  }
  public func paths(forResourcesOfTypes types: [Swift.String]) -> [Swift.String]
}
extension SecTrust : SalemoveSDK.AlamofireExtended {
  public typealias ExtendedType = Security.SecTrust
}
extension AlamofireExtension where ExtendedType == Security.SecTrust {
  @available(iOS 12, macOS 10.14, tvOS 12, watchOS 5, *)
  public func evaluate(afterApplying policy: Security.SecPolicy) throws
  @available(iOS, introduced: 10, deprecated: 12, renamed: "evaluate(afterApplying:)")
  @available(macOS, introduced: 10.12, deprecated: 10.14, renamed: "evaluate(afterApplying:)")
  @available(tvOS, introduced: 10, deprecated: 12, renamed: "evaluate(afterApplying:)")
  @available(watchOS, introduced: 3, deprecated: 5, renamed: "evaluate(afterApplying:)")
  public func validate(policy: Security.SecPolicy, errorProducer: (Darwin.OSStatus, Security.SecTrustResultType) -> Swift.Error) throws
  public func apply(policy: Security.SecPolicy) throws -> Security.SecTrust
  @available(iOS 12, macOS 10.14, tvOS 12, watchOS 5, *)
  public func evaluate() throws
  @available(iOS, introduced: 10, deprecated: 12, renamed: "evaluate()")
  @available(macOS, introduced: 10.12, deprecated: 10.14, renamed: "evaluate()")
  @available(tvOS, introduced: 10, deprecated: 12, renamed: "evaluate()")
  @available(watchOS, introduced: 3, deprecated: 5, renamed: "evaluate()")
  public func validate(errorProducer: (Darwin.OSStatus, Security.SecTrustResultType) -> Swift.Error) throws
  public func setAnchorCertificates(_ certificates: [Security.SecCertificate]) throws
  public var publicKeys: [Security.SecKey] {
    get
  }
  public var certificates: [Security.SecCertificate] {
    get
  }
  public var certificateData: [Foundation.Data] {
    get
  }
  public func performDefaultValidation(forHost host: Swift.String) throws
  public func performValidation(forHost host: Swift.String) throws
}
extension SecPolicy : SalemoveSDK.AlamofireExtended {
  public typealias ExtendedType = Security.SecPolicy
}
extension AlamofireExtension where ExtendedType == Security.SecPolicy {
  public static let `default`: Security.SecPolicy
  public static func hostname(_ hostname: Swift.String) -> Security.SecPolicy
  public static func revocation(options: SalemoveSDK.RevocationTrustEvaluator.Options) throws -> Security.SecPolicy
}
extension Array : SalemoveSDK.AlamofireExtended {
  public typealias ExtendedType = Swift.Array<Element>
}
extension AlamofireExtension where ExtendedType == [Security.SecCertificate] {
  public var data: [Foundation.Data] {
    get
  }
  public var publicKeys: [Security.SecKey] {
    get
  }
}
extension SecCertificate : SalemoveSDK.AlamofireExtended {
  public typealias ExtendedType = Security.SecCertificate
}
extension AlamofireExtension where ExtendedType == Security.SecCertificate {
  public var publicKey: Security.SecKey? {
    get
  }
}
extension Int32 : SalemoveSDK.AlamofireExtended {
  public typealias ExtendedType = Swift.Int32
}
extension AlamofireExtension where ExtendedType == Darwin.OSStatus {
  public var isSuccess: Swift.Bool {
    get
  }
}
extension SecTrustResultType : SalemoveSDK.AlamofireExtended {
  public typealias ExtendedType = Security.SecTrustResultType
}
extension AlamofireExtension where ExtendedType == Security.SecTrustResultType {
  public var isSuccess: Swift.Bool {
    get
  }
}
open class AlamofireSession {
  public static let `default`: SalemoveSDK.AlamofireSession
  final public let session: Foundation.URLSession
  final public let delegate: SalemoveSDK.SessionDelegate
  final public let rootQueue: Dispatch.DispatchQueue
  final public let startRequestsImmediately: Swift.Bool
  final public let requestQueue: Dispatch.DispatchQueue
  final public let serializationQueue: Dispatch.DispatchQueue
  final public let interceptor: SalemoveSDK.AlamofireRequestInterceptor?
  final public let serverTrustManager: SalemoveSDK.ServerTrustManager?
  final public let redirectHandler: SalemoveSDK.RedirectHandler?
  final public let cachedResponseHandler: SalemoveSDK.CachedResponseHandler?
  final public let eventMonitor: SalemoveSDK.CompositeEventMonitor
  final public let defaultEventMonitors: [SalemoveSDK.EventMonitor]
  public init(session: Foundation.URLSession, delegate: SalemoveSDK.SessionDelegate, rootQueue: Dispatch.DispatchQueue, startRequestsImmediately: Swift.Bool = true, requestQueue: Dispatch.DispatchQueue? = nil, serializationQueue: Dispatch.DispatchQueue? = nil, interceptor: SalemoveSDK.AlamofireRequestInterceptor? = nil, serverTrustManager: SalemoveSDK.ServerTrustManager? = nil, redirectHandler: SalemoveSDK.RedirectHandler? = nil, cachedResponseHandler: SalemoveSDK.CachedResponseHandler? = nil, eventMonitors: [SalemoveSDK.EventMonitor] = [])
  convenience public init(configuration: Foundation.URLSessionConfiguration = URLSessionConfiguration.af.default, delegate: SalemoveSDK.SessionDelegate = SessionDelegate(), rootQueue: Dispatch.DispatchQueue = DispatchQueue(label: "org.alamofire.session.rootQueue"), startRequestsImmediately: Swift.Bool = true, requestQueue: Dispatch.DispatchQueue? = nil, serializationQueue: Dispatch.DispatchQueue? = nil, interceptor: SalemoveSDK.AlamofireRequestInterceptor? = nil, serverTrustManager: SalemoveSDK.ServerTrustManager? = nil, redirectHandler: SalemoveSDK.RedirectHandler? = nil, cachedResponseHandler: SalemoveSDK.CachedResponseHandler? = nil, eventMonitors: [SalemoveSDK.EventMonitor] = [])
  @objc deinit
  public func withAllRequests(perform action: @escaping (Swift.Set<SalemoveSDK.AlamofireRequest>) -> Swift.Void)
  public func cancelAllRequests(completingOnQueue queue: Dispatch.DispatchQueue = .main, completion: (() -> Swift.Void)? = nil)
  public typealias RequestModifier = (inout Foundation.URLRequest) throws -> Swift.Void
  open func request(_ convertible: SalemoveSDK.URLConvertible, method: SalemoveSDK.AlamofireHTTPMethod = .get, parameters: SalemoveSDK.Parameters? = nil, encoding: SalemoveSDK.AlamofireParameterEncoding = AlamofireURLEncoding.default, headers: SalemoveSDK.HTTPHeaders? = nil, interceptor: SalemoveSDK.AlamofireRequestInterceptor? = nil, requestModifier: SalemoveSDK.AlamofireSession.RequestModifier? = nil) -> SalemoveSDK.AlamofireDataRequest
  open func request<Parameters>(_ convertible: SalemoveSDK.URLConvertible, method: SalemoveSDK.AlamofireHTTPMethod = .get, parameters: Parameters? = nil, encoder: SalemoveSDK.ParameterEncoder = URLEncodedFormParameterEncoder.default, headers: SalemoveSDK.HTTPHeaders? = nil, interceptor: SalemoveSDK.AlamofireRequestInterceptor? = nil, requestModifier: SalemoveSDK.AlamofireSession.RequestModifier? = nil) -> SalemoveSDK.AlamofireDataRequest where Parameters : Swift.Encodable
  open func request(_ convertible: SalemoveSDK.AlamofireURLRequestConvertible, interceptor: SalemoveSDK.AlamofireRequestInterceptor? = nil) -> SalemoveSDK.AlamofireDataRequest
  open func streamRequest<Parameters>(_ convertible: SalemoveSDK.URLConvertible, method: SalemoveSDK.AlamofireHTTPMethod = .get, parameters: Parameters? = nil, encoder: SalemoveSDK.ParameterEncoder = URLEncodedFormParameterEncoder.default, headers: SalemoveSDK.HTTPHeaders? = nil, automaticallyCancelOnStreamError: Swift.Bool = false, interceptor: SalemoveSDK.AlamofireRequestInterceptor? = nil, requestModifier: SalemoveSDK.AlamofireSession.RequestModifier? = nil) -> SalemoveSDK.DataStreamRequest where Parameters : Swift.Encodable
  open func streamRequest(_ convertible: SalemoveSDK.URLConvertible, method: SalemoveSDK.AlamofireHTTPMethod = .get, headers: SalemoveSDK.HTTPHeaders? = nil, automaticallyCancelOnStreamError: Swift.Bool = false, interceptor: SalemoveSDK.AlamofireRequestInterceptor? = nil, requestModifier: SalemoveSDK.AlamofireSession.RequestModifier? = nil) -> SalemoveSDK.DataStreamRequest
  open func streamRequest(_ convertible: SalemoveSDK.AlamofireURLRequestConvertible, automaticallyCancelOnStreamError: Swift.Bool = false, interceptor: SalemoveSDK.AlamofireRequestInterceptor? = nil) -> SalemoveSDK.DataStreamRequest
  open func download(_ convertible: SalemoveSDK.URLConvertible, method: SalemoveSDK.AlamofireHTTPMethod = .get, parameters: SalemoveSDK.Parameters? = nil, encoding: SalemoveSDK.AlamofireParameterEncoding = AlamofireURLEncoding.default, headers: SalemoveSDK.HTTPHeaders? = nil, interceptor: SalemoveSDK.AlamofireRequestInterceptor? = nil, requestModifier: SalemoveSDK.AlamofireSession.RequestModifier? = nil, to destination: SalemoveSDK.AlamofireDownloadRequest.Destination? = nil) -> SalemoveSDK.AlamofireDownloadRequest
  open func download<Parameters>(_ convertible: SalemoveSDK.URLConvertible, method: SalemoveSDK.AlamofireHTTPMethod = .get, parameters: Parameters? = nil, encoder: SalemoveSDK.ParameterEncoder = URLEncodedFormParameterEncoder.default, headers: SalemoveSDK.HTTPHeaders? = nil, interceptor: SalemoveSDK.AlamofireRequestInterceptor? = nil, requestModifier: SalemoveSDK.AlamofireSession.RequestModifier? = nil, to destination: SalemoveSDK.AlamofireDownloadRequest.Destination? = nil) -> SalemoveSDK.AlamofireDownloadRequest where Parameters : Swift.Encodable
  open func download(_ convertible: SalemoveSDK.AlamofireURLRequestConvertible, interceptor: SalemoveSDK.AlamofireRequestInterceptor? = nil, to destination: SalemoveSDK.AlamofireDownloadRequest.Destination? = nil) -> SalemoveSDK.AlamofireDownloadRequest
  open func download(resumingWith data: Foundation.Data, interceptor: SalemoveSDK.AlamofireRequestInterceptor? = nil, to destination: SalemoveSDK.AlamofireDownloadRequest.Destination? = nil) -> SalemoveSDK.AlamofireDownloadRequest
  open func upload(_ data: Foundation.Data, to convertible: SalemoveSDK.URLConvertible, method: SalemoveSDK.AlamofireHTTPMethod = .post, headers: SalemoveSDK.HTTPHeaders? = nil, interceptor: SalemoveSDK.AlamofireRequestInterceptor? = nil, fileManager: Foundation.FileManager = .default, requestModifier: SalemoveSDK.AlamofireSession.RequestModifier? = nil) -> SalemoveSDK.AlamofireUploadRequest
  open func upload(_ data: Foundation.Data, with convertible: SalemoveSDK.AlamofireURLRequestConvertible, interceptor: SalemoveSDK.AlamofireRequestInterceptor? = nil, fileManager: Foundation.FileManager = .default) -> SalemoveSDK.AlamofireUploadRequest
  open func upload(_ fileURL: Foundation.URL, to convertible: SalemoveSDK.URLConvertible, method: SalemoveSDK.AlamofireHTTPMethod = .post, headers: SalemoveSDK.HTTPHeaders? = nil, interceptor: SalemoveSDK.AlamofireRequestInterceptor? = nil, fileManager: Foundation.FileManager = .default, requestModifier: SalemoveSDK.AlamofireSession.RequestModifier? = nil) -> SalemoveSDK.AlamofireUploadRequest
  open func upload(_ fileURL: Foundation.URL, with convertible: SalemoveSDK.AlamofireURLRequestConvertible, interceptor: SalemoveSDK.AlamofireRequestInterceptor? = nil, fileManager: Foundation.FileManager = .default) -> SalemoveSDK.AlamofireUploadRequest
  open func upload(_ stream: Foundation.InputStream, to convertible: SalemoveSDK.URLConvertible, method: SalemoveSDK.AlamofireHTTPMethod = .post, headers: SalemoveSDK.HTTPHeaders? = nil, interceptor: SalemoveSDK.AlamofireRequestInterceptor? = nil, fileManager: Foundation.FileManager = .default, requestModifier: SalemoveSDK.AlamofireSession.RequestModifier? = nil) -> SalemoveSDK.AlamofireUploadRequest
  open func upload(_ stream: Foundation.InputStream, with convertible: SalemoveSDK.AlamofireURLRequestConvertible, interceptor: SalemoveSDK.AlamofireRequestInterceptor? = nil, fileManager: Foundation.FileManager = .default) -> SalemoveSDK.AlamofireUploadRequest
  open func upload(multipartFormData: @escaping (SalemoveSDK.AlamofireMultipartFormData) -> Swift.Void, to url: SalemoveSDK.URLConvertible, usingThreshold encodingMemoryThreshold: Swift.UInt64 = AlamofireMultipartFormData.encodingMemoryThreshold, method: SalemoveSDK.AlamofireHTTPMethod = .post, headers: SalemoveSDK.HTTPHeaders? = nil, interceptor: SalemoveSDK.AlamofireRequestInterceptor? = nil, fileManager: Foundation.FileManager = .default, requestModifier: SalemoveSDK.AlamofireSession.RequestModifier? = nil) -> SalemoveSDK.AlamofireUploadRequest
  open func upload(multipartFormData: @escaping (SalemoveSDK.AlamofireMultipartFormData) -> Swift.Void, with request: SalemoveSDK.AlamofireURLRequestConvertible, usingThreshold encodingMemoryThreshold: Swift.UInt64 = AlamofireMultipartFormData.encodingMemoryThreshold, interceptor: SalemoveSDK.AlamofireRequestInterceptor? = nil, fileManager: Foundation.FileManager = .default) -> SalemoveSDK.AlamofireUploadRequest
  open func upload(multipartFormData: SalemoveSDK.AlamofireMultipartFormData, to url: SalemoveSDK.URLConvertible, usingThreshold encodingMemoryThreshold: Swift.UInt64 = AlamofireMultipartFormData.encodingMemoryThreshold, method: SalemoveSDK.AlamofireHTTPMethod = .post, headers: SalemoveSDK.HTTPHeaders? = nil, interceptor: SalemoveSDK.AlamofireRequestInterceptor? = nil, fileManager: Foundation.FileManager = .default, requestModifier: SalemoveSDK.AlamofireSession.RequestModifier? = nil) -> SalemoveSDK.AlamofireUploadRequest
  open func upload(multipartFormData: SalemoveSDK.AlamofireMultipartFormData, with request: SalemoveSDK.AlamofireURLRequestConvertible, usingThreshold encodingMemoryThreshold: Swift.UInt64 = AlamofireMultipartFormData.encodingMemoryThreshold, interceptor: SalemoveSDK.AlamofireRequestInterceptor? = nil, fileManager: Foundation.FileManager = .default) -> SalemoveSDK.AlamofireUploadRequest
}
extension AlamofireSession : SalemoveSDK.RequestDelegate {
  public var sessionConfiguration: Foundation.URLSessionConfiguration {
    get
  }
  public var startImmediately: Swift.Bool {
    get
  }
  public func cleanup(after request: SalemoveSDK.AlamofireRequest)
  public func retryResult(for request: SalemoveSDK.AlamofireRequest, dueTo error: SalemoveSDK.AFError, completion: @escaping (SalemoveSDK.RetryResult) -> Swift.Void)
  public func retryRequest(_ request: SalemoveSDK.AlamofireRequest, withDelay timeDelay: Foundation.TimeInterval?)
}
public enum ContextType : Swift.String {
  case page
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@objc public class VisitorContext : ObjectiveC.NSObject {
  public var type: SalemoveSDK.ContextType {
    get
  }
  public var url: Swift.String {
    get
  }
  public init(type: SalemoveSDK.ContextType, url: Swift.String)
  @objc override dynamic public init()
  @objc deinit
}
public protocol ParameterEncoder {
  func encode<Parameters>(_ parameters: Parameters?, into request: Foundation.URLRequest) throws -> Foundation.URLRequest where Parameters : Swift.Encodable
}
open class JSONParameterEncoder : SalemoveSDK.ParameterEncoder {
  public static var `default`: SalemoveSDK.JSONParameterEncoder {
    get
  }
  public static var prettyPrinted: SalemoveSDK.JSONParameterEncoder {
    get
  }
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  public static var sortedKeys: SalemoveSDK.JSONParameterEncoder {
    get
  }
  final public let encoder: Foundation.JSONEncoder
  public init(encoder: Foundation.JSONEncoder = JSONEncoder())
  open func encode<Parameters>(_ parameters: Parameters?, into request: Foundation.URLRequest) throws -> Foundation.URLRequest where Parameters : Swift.Encodable
  @objc deinit
}
open class URLEncodedFormParameterEncoder : SalemoveSDK.ParameterEncoder {
  public enum Destination {
    case methodDependent
    case queryString
    case httpBody
    public static func == (a: SalemoveSDK.URLEncodedFormParameterEncoder.Destination, b: SalemoveSDK.URLEncodedFormParameterEncoder.Destination) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static var `default`: SalemoveSDK.URLEncodedFormParameterEncoder {
    get
  }
  final public let encoder: SalemoveSDK.URLEncodedFormEncoder
  final public let destination: SalemoveSDK.URLEncodedFormParameterEncoder.Destination
  public init(encoder: SalemoveSDK.URLEncodedFormEncoder = URLEncodedFormEncoder(), destination: SalemoveSDK.URLEncodedFormParameterEncoder.Destination = .methodDependent)
  open func encode<Parameters>(_ parameters: Parameters?, into request: Foundation.URLRequest) throws -> Foundation.URLRequest where Parameters : Swift.Encodable
  @objc deinit
}
open class TransformedLocus : SalemoveSDK.Locus {
  final public let locus: SalemoveSDK.Locus
  final public let transform: SalemoveSDK.Transform
  public init(locus: SalemoveSDK.Locus, transform: SalemoveSDK.Transform)
  override open func bounds() -> SalemoveSDK.Rect
  override public init()
  @objc deinit
}
extension Sequence where Self.Element : SalemoveSDK.Animation {
  public func sequence(delay: Swift.Double = 0.0) -> SalemoveSDK.Animation
}
public enum AFError : Swift.Error {
  public enum MultipartEncodingFailureReason {
    case bodyPartURLInvalid(url: Foundation.URL)
    case bodyPartFilenameInvalid(in: Foundation.URL)
    case bodyPartFileNotReachable(at: Foundation.URL)
    case bodyPartFileNotReachableWithError(atURL: Foundation.URL, error: Swift.Error)
    case bodyPartFileIsDirectory(at: Foundation.URL)
    case bodyPartFileSizeNotAvailable(at: Foundation.URL)
    case bodyPartFileSizeQueryFailedWithError(forURL: Foundation.URL, error: Swift.Error)
    case bodyPartInputStreamCreationFailed(for: Foundation.URL)
    case outputStreamCreationFailed(for: Foundation.URL)
    case outputStreamFileAlreadyExists(at: Foundation.URL)
    case outputStreamURLInvalid(url: Foundation.URL)
    case outputStreamWriteFailed(error: Swift.Error)
    case inputStreamReadFailed(error: Swift.Error)
  }
  public struct UnexpectedInputStreamLength : Swift.Error {
    public var bytesExpected: Swift.UInt64
    public var bytesRead: Swift.UInt64
  }
  public enum ParameterEncodingFailureReason {
    case missingURL
    case jsonEncodingFailed(error: Swift.Error)
    case customEncodingFailed(error: Swift.Error)
  }
  public enum ParameterEncoderFailureReason {
    public enum RequiredComponent {
      case url
      case httpMethod(rawValue: Swift.String)
    }
    case missingRequiredComponent(SalemoveSDK.AFError.ParameterEncoderFailureReason.RequiredComponent)
    case encoderFailed(error: Swift.Error)
  }
  public enum ResponseValidationFailureReason {
    case dataFileNil
    case dataFileReadFailed(at: Foundation.URL)
    case missingContentType(acceptableContentTypes: [Swift.String])
    case unacceptableContentType(acceptableContentTypes: [Swift.String], responseContentType: Swift.String)
    case unacceptableStatusCode(code: Swift.Int)
    case customValidationFailed(error: Swift.Error)
  }
  public enum ResponseSerializationFailureReason {
    case inputDataNilOrZeroLength
    case inputFileNil
    case inputFileReadFailed(at: Foundation.URL)
    case stringSerializationFailed(encoding: Swift.String.Encoding)
    case jsonSerializationFailed(error: Swift.Error)
    case decodingFailed(error: Swift.Error)
    case customSerializationFailed(error: Swift.Error)
    case invalidEmptyResponse(type: Swift.String)
  }
  public enum ServerTrustFailureReason {
    public struct Output {
      public let host: Swift.String
      public let trust: Security.SecTrust
      public let status: Darwin.OSStatus
      public let result: Security.SecTrustResultType
    }
    case noRequiredEvaluator(host: Swift.String)
    case noCertificatesFound
    case noPublicKeysFound
    case policyApplicationFailed(trust: Security.SecTrust, policy: Security.SecPolicy, status: Darwin.OSStatus)
    case settingAnchorCertificatesFailed(status: Darwin.OSStatus, certificates: [Security.SecCertificate])
    case revocationPolicyCreationFailed
    case trustEvaluationFailed(error: Swift.Error?)
    case defaultEvaluationFailed(output: SalemoveSDK.AFError.ServerTrustFailureReason.Output)
    case hostValidationFailed(output: SalemoveSDK.AFError.ServerTrustFailureReason.Output)
    case revocationCheckFailed(output: SalemoveSDK.AFError.ServerTrustFailureReason.Output, options: SalemoveSDK.RevocationTrustEvaluator.Options)
    case certificatePinningFailed(host: Swift.String, trust: Security.SecTrust, pinnedCertificates: [Security.SecCertificate], serverCertificates: [Security.SecCertificate])
    case publicKeyPinningFailed(host: Swift.String, trust: Security.SecTrust, pinnedKeys: [Security.SecKey], serverKeys: [Security.SecKey])
    case customEvaluationFailed(error: Swift.Error)
  }
  public enum URLRequestValidationFailureReason {
    case bodyDataInGETRequest(Foundation.Data)
  }
  case createUploadableFailed(error: Swift.Error)
  case createURLRequestFailed(error: Swift.Error)
  case downloadedFileMoveFailed(error: Swift.Error, source: Foundation.URL, destination: Foundation.URL)
  case explicitlyCancelled
  case invalidURL(url: SalemoveSDK.URLConvertible)
  case multipartEncodingFailed(reason: SalemoveSDK.AFError.MultipartEncodingFailureReason)
  case parameterEncodingFailed(reason: SalemoveSDK.AFError.ParameterEncodingFailureReason)
  case parameterEncoderFailed(reason: SalemoveSDK.AFError.ParameterEncoderFailureReason)
  case requestAdaptationFailed(error: Swift.Error)
  case requestRetryFailed(retryError: Swift.Error, originalError: Swift.Error)
  case responseValidationFailed(reason: SalemoveSDK.AFError.ResponseValidationFailureReason)
  case responseSerializationFailed(reason: SalemoveSDK.AFError.ResponseSerializationFailureReason)
  case serverTrustEvaluationFailed(reason: SalemoveSDK.AFError.ServerTrustFailureReason)
  case sessionDeinitialized
  case sessionInvalidated(error: Swift.Error?)
  case sessionTaskFailed(error: Swift.Error)
  case urlRequestValidationFailed(reason: SalemoveSDK.AFError.URLRequestValidationFailureReason)
}
extension Error {
  public var asAFError: SalemoveSDK.AFError? {
    get
  }
  public func asAFError(orFailWith message: @autoclosure () -> Swift.String, file: Swift.StaticString = #file, line: Swift.UInt = #line) -> SalemoveSDK.AFError
}
extension AFError {
  public var isSessionDeinitializedError: Swift.Bool {
    get
  }
  public var isSessionInvalidatedError: Swift.Bool {
    get
  }
  public var isExplicitlyCancelledError: Swift.Bool {
    get
  }
  public var isInvalidURLError: Swift.Bool {
    get
  }
  public var isParameterEncodingError: Swift.Bool {
    get
  }
  public var isParameterEncoderError: Swift.Bool {
    get
  }
  public var isMultipartEncodingError: Swift.Bool {
    get
  }
  public var isRequestAdaptationError: Swift.Bool {
    get
  }
  public var isResponseValidationError: Swift.Bool {
    get
  }
  public var isResponseSerializationError: Swift.Bool {
    get
  }
  public var isServerTrustEvaluationError: Swift.Bool {
    get
  }
  public var isRequestRetryError: Swift.Bool {
    get
  }
  public var isCreateUploadableError: Swift.Bool {
    get
  }
  public var isCreateURLRequestError: Swift.Bool {
    get
  }
  public var isDownloadedFileMoveError: Swift.Bool {
    get
  }
  public var isSessionTaskError: Swift.Bool {
    get
  }
}
extension AFError {
  public var urlConvertible: SalemoveSDK.URLConvertible? {
    get
  }
  public var url: Foundation.URL? {
    get
  }
  public var underlyingError: Swift.Error? {
    get
  }
  public var acceptableContentTypes: [Swift.String]? {
    get
  }
  public var responseContentType: Swift.String? {
    get
  }
  public var responseCode: Swift.Int? {
    get
  }
  public var failedStringEncoding: Swift.String.Encoding? {
    get
  }
  public var sourceURL: Foundation.URL? {
    get
  }
  public var destinationURL: Foundation.URL? {
    get
  }
  public var downloadResumeData: Foundation.Data? {
    get
  }
}
extension AFError : Foundation.LocalizedError {
  public var errorDescription: Swift.String? {
    get
  }
}
public typealias OpacityAnimationDescription = SalemoveSDK.AnimationDescription<Swift.Double>
extension AnimatableVariable where T : SalemoveSDK.DoubleInterpolation {
  public func animate(_ desc: SalemoveSDK.OpacityAnimationDescription)
  public func animation(_ desc: SalemoveSDK.OpacityAnimationDescription) -> SalemoveSDK.Animation
  public func animate(from: Swift.Double? = nil, to: Swift.Double, during: Swift.Double = 1.0, delay: Swift.Double = 0.0)
  public func animation(from: Swift.Double? = nil, to: Swift.Double, during: Swift.Double = 1.0, delay: Swift.Double = 0.0) -> SalemoveSDK.Animation
  public func animation(_ f: @escaping ((Swift.Double) -> Swift.Double), during: Swift.Double = 1.0, delay: Swift.Double = 0.0) -> SalemoveSDK.Animation
}
@_hasMissingDesignatedInitializers open class Variable<T> {
  open var value: T {
    get
    set
  }
  @discardableResult
  open func onChange(_ f: @escaping ((T) -> Swift.Void)) -> SalemoveSDK.MacawDisposable
  @objc deinit
}
open class OffsetEffect : SalemoveSDK.Effect {
  final public let dx: Swift.Double
  final public let dy: Swift.Double
  public init(dx: Swift.Double = 0, dy: Swift.Double = 0, input: SalemoveSDK.Effect? = nil)
  override public init(input: SalemoveSDK.Effect?)
  @objc deinit
}
@objc open class Group : SalemoveSDK.Node {
  open var contentsVar: SalemoveSDK.AnimatableVariable<[SalemoveSDK.Node]>
  open var contents: [SalemoveSDK.Node] {
    get
    set(val)
  }
  public init(contents: [SalemoveSDK.Node] = [], place: SalemoveSDK.Transform = Transform.identity, opaque: Swift.Bool = true, opacity: Swift.Double = 1, clip: SalemoveSDK.Locus? = nil, mask: SalemoveSDK.Node? = nil, effect: SalemoveSDK.Effect? = nil, visible: Swift.Bool = true, tag: [Swift.String] = [])
  override public func nodeBy(predicate: (SalemoveSDK.Node) -> Swift.Bool) -> SalemoveSDK.Node?
  override public func nodesBy(predicate: (SalemoveSDK.Node) -> Swift.Bool) -> [SalemoveSDK.Node]
  override open var bounds: SalemoveSDK.Rect? {
    get
  }
  override public init(place: SalemoveSDK.Transform = super, opaque: Swift.Bool = super, opacity: Swift.Double = super, clip: SalemoveSDK.Locus? = super, mask: SalemoveSDK.Node? = super, effect: SalemoveSDK.Effect? = super, visible: Swift.Bool = super, tag: [Swift.String] = super)
  @objc deinit
}
extension Array where Element : SalemoveSDK.Node {
  public func group(place: SalemoveSDK.Transform = Transform.identity, opaque: Swift.Bool = true, opacity: Swift.Double = 1, clip: SalemoveSDK.Locus? = nil, effect: SalemoveSDK.Effect? = nil, visible: Swift.Bool = true, tag: [Swift.String] = []) -> SalemoveSDK.Group
}
@objc open class Shape : SalemoveSDK.Node {
  final public let formVar: SalemoveSDK.AnimatableVariable<SalemoveSDK.Locus>
  open var form: SalemoveSDK.Locus {
    get
    set(val)
  }
  final public let fillVar: SalemoveSDK.AnimatableVariable<SalemoveSDK.Fill?>
  open var fill: SalemoveSDK.Fill? {
    get
    set(val)
  }
  final public let strokeVar: SalemoveSDK.AnimatableVariable<SalemoveSDK.Stroke?>
  open var stroke: SalemoveSDK.Stroke? {
    get
    set(val)
  }
  public init(form: SalemoveSDK.Locus, fill: SalemoveSDK.Fill? = nil, stroke: SalemoveSDK.Stroke? = nil, place: SalemoveSDK.Transform = Transform.identity, opaque: Swift.Bool = true, opacity: Swift.Double = 1, clip: SalemoveSDK.Locus? = nil, mask: SalemoveSDK.Node? = nil, effect: SalemoveSDK.Effect? = nil, visible: Swift.Bool = true, tag: [Swift.String] = [])
  override open var bounds: SalemoveSDK.Rect? {
    get
  }
  override public init(place: SalemoveSDK.Transform = super, opaque: Swift.Bool = super, opacity: Swift.Double = super, clip: SalemoveSDK.Locus? = super, mask: SalemoveSDK.Node? = super, effect: SalemoveSDK.Effect? = super, visible: Swift.Bool = super, tag: [Swift.String] = super)
  @objc deinit
}
public enum MediaType : Swift.String, Swift.Codable {
  case audio
  case video
  case text
  case phone
  case unknown
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
final public class Transform {
  final public let m11: Swift.Double
  final public let m12: Swift.Double
  final public let m21: Swift.Double
  final public let m22: Swift.Double
  final public let dx: Swift.Double
  final public let dy: Swift.Double
  public static let identity: SalemoveSDK.Transform
  public init(_ m11: Swift.Double, _ m12: Swift.Double, _ m21: Swift.Double, _ m22: Swift.Double, _ dx: Swift.Double, _ dy: Swift.Double)
  public init(m11: Swift.Double = 1, m12: Swift.Double = 0, m21: Swift.Double = 0, m22: Swift.Double = 1, dx: Swift.Double = 0, dy: Swift.Double = 0)
  final public func move(_ dx: Swift.Double, _ dy: Swift.Double) -> SalemoveSDK.Transform
  final public func move(dx: Swift.Double = 0, dy: Swift.Double = 0) -> SalemoveSDK.Transform
  final public func scale(sx: Swift.Double = 0, sy: Swift.Double = 0) -> SalemoveSDK.Transform
  final public func scale(_ sx: Swift.Double, _ sy: Swift.Double) -> SalemoveSDK.Transform
  final public func shear(shx: Swift.Double = 0, shy: Swift.Double = 0) -> SalemoveSDK.Transform
  final public func shear(_ shx: Swift.Double, _ shy: Swift.Double) -> SalemoveSDK.Transform
  final public func rotate(angle: Swift.Double) -> SalemoveSDK.Transform
  final public func rotate(_ angle: Swift.Double) -> SalemoveSDK.Transform
  final public func rotate(angle: Swift.Double, x: Swift.Double = 0, y: Swift.Double = 0) -> SalemoveSDK.Transform
  final public func rotate(_ angle: Swift.Double, _ x: Swift.Double, _ y: Swift.Double) -> SalemoveSDK.Transform
  final public class func move(dx: Swift.Double = 0, dy: Swift.Double = 0) -> SalemoveSDK.Transform
  final public class func move(_ dx: Swift.Double, _ dy: Swift.Double) -> SalemoveSDK.Transform
  final public class func scale(sx: Swift.Double = 0, sy: Swift.Double = 0) -> SalemoveSDK.Transform
  final public class func scale(_ sx: Swift.Double, _ sy: Swift.Double) -> SalemoveSDK.Transform
  final public class func shear(shx: Swift.Double = 0, shy: Swift.Double = 0) -> SalemoveSDK.Transform
  final public class func shear(_ shx: Swift.Double, _ shy: Swift.Double) -> SalemoveSDK.Transform
  final public class func rotate(angle: Swift.Double) -> SalemoveSDK.Transform
  final public class func rotate(_ angle: Swift.Double) -> SalemoveSDK.Transform
  final public class func rotate(angle: Swift.Double, x: Swift.Double = 0, y: Swift.Double = 0) -> SalemoveSDK.Transform
  final public class func rotate(_ angle: Swift.Double, _ x: Swift.Double, _ y: Swift.Double) -> SalemoveSDK.Transform
  final public func concat(with: SalemoveSDK.Transform) -> SalemoveSDK.Transform
  final public func apply(to: SalemoveSDK.Point) -> SalemoveSDK.Point
  final public func invert() -> SalemoveSDK.Transform?
  @objc deinit
}
open class PathSegment {
  final public let type: SalemoveSDK.PathSegmentType
  final public let data: [Swift.Double]
  public init(type: SalemoveSDK.PathSegmentType = .M, data: [Swift.Double] = [])
  open func isAbsolute() -> Swift.Bool
  @objc deinit
}
precedencegroup BindingPrecedence {
  associativity: right
  higherThan: AssignmentPrecedence
}
infix operator <~ : BindingPrecedence
public protocol BindingSource : SalemoveSDK.SignalProducerConvertible where Self.Error == Swift.Never {
}
extension Signal : SalemoveSDK.BindingSource where Error == Swift.Never {
}
extension SignalProducer : SalemoveSDK.BindingSource where Error == Swift.Never {
}
public protocol BindingTargetProvider {
  associatedtype Value
  var bindingTarget: SalemoveSDK.BindingTarget<Self.Value> { get }
}
extension BindingTargetProvider {
  @discardableResult
  public static func <~ <Source>(provider: Self, source: Source) -> SalemoveSDK.Disposable? where Source : SalemoveSDK.BindingSource, Self.Value == Source.Value
  @discardableResult
  public static func <~ <Source>(provider: Self, source: Source) -> SalemoveSDK.Disposable? where Source : SalemoveSDK.BindingSource, Self.Value == Source.Value?
}
extension Signal.Observer {
  @discardableResult
  public static func <~ <Source>(observer: SalemoveSDK.Signal<Value, Error>.Observer, source: Source) -> SalemoveSDK.Disposable? where Value == Source.Value, Source : SalemoveSDK.BindingSource
}
public struct BindingTarget<Value> : SalemoveSDK.BindingTargetProvider {
  public let lifetime: SalemoveSDK.Lifetime
  public let action: (Value) -> Swift.Void
  public var bindingTarget: SalemoveSDK.BindingTarget<Value> {
    get
  }
  public init(on scheduler: SalemoveSDK.Scheduler = ImmediateScheduler(), lifetime: SalemoveSDK.Lifetime, action: @escaping (Value) -> Swift.Void)
  public init<Object>(on scheduler: SalemoveSDK.Scheduler = ImmediateScheduler(), lifetime: SalemoveSDK.Lifetime, object: Object, keyPath: Swift.WritableKeyPath<Object, Value>) where Object : AnyObject
}
extension Optional : SalemoveSDK.BindingTargetProvider where Wrapped : SalemoveSDK.BindingTargetProvider {
  public typealias Value = Wrapped.Value
  public var bindingTarget: SalemoveSDK.BindingTarget<Wrapped.Value> {
    get
  }
}
extension AnimatableVariable {
  public func animate<T>(from: T? = nil, to: T, during: Swift.Double = 1.0, delay: Swift.Double = 0.0) where T : SalemoveSDK.Stroke
  public func animation<T>(from: T? = nil, to: T, during: Swift.Double = 1.0, delay: Swift.Double = 0.0) -> SalemoveSDK.Animation where T : SalemoveSDK.Stroke
}
extension AnimatableVariable {
  public func animate<T>(from: T? = nil, to: T, during: Swift.Double = 1.0, delay: Swift.Double = 0.0) where T : SalemoveSDK.Fill
  public func animation<T>(from: T? = nil, to: T, during: Swift.Double = 1.0, delay: Swift.Double = 0.0) -> SalemoveSDK.Animation where T : SalemoveSDK.Fill
}
extension NotificationCenter : SalemoveSDK.ReactiveExtensionsProvider {
}
extension Reactive where Base : Foundation.NotificationCenter {
  public func notifications(forName name: Foundation.Notification.Name?, object: Swift.AnyObject? = nil) -> SalemoveSDK.Signal<Foundation.Notification, Swift.Never>
}
extension URLSession : SalemoveSDK.ReactiveExtensionsProvider {
}
extension Reactive where Base : Foundation.URLSession {
  public func data(with request: Foundation.URLRequest) -> SalemoveSDK.SignalProducer<(Foundation.Data, Foundation.URLResponse), Swift.Error>
}
@objc @_inheritsConvenienceInitializers open class MacawView : SalemoveSDK.MView, SalemoveSDK.MGestureRecognizerDelegate {
  public var zoom: SalemoveSDK.MacawZoom {
    get
    set
  }
  open var node: SalemoveSDK.Node {
    get
    set
  }
  open var contentLayout: SalemoveSDK.ContentLayout {
    get
    set
  }
  @objc override dynamic open var contentMode: SalemoveSDK.MViewContentMode {
    @objc get
    @objc set
  }
  open var place: SalemoveSDK.Transform {
    get
  }
  open var placeVar: SalemoveSDK.Variable<SalemoveSDK.Transform> {
    get
  }
  @objc override dynamic open var frame: CoreGraphics.CGRect {
    @objc get
    @objc set
  }
  @objc override dynamic open var intrinsicContentSize: CoreGraphics.CGSize {
    @objc get
  }
  @objc convenience required dynamic public init?(coder aDecoder: Foundation.NSCoder)
  @objc public init?(node: SalemoveSDK.Node, coder aDecoder: Foundation.NSCoder)
  convenience public init(node: SalemoveSDK.Node, frame: CoreGraphics.CGRect)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  final public func findNodeAt(location: CoreGraphics.CGPoint) -> SalemoveSDK.Node?
  open func mTouchesBegan(_ touches: Swift.Set<SalemoveSDK.MTouch>, with event: SalemoveSDK.MEvent?)
  open func mTouchesMoved(_ touches: Swift.Set<SalemoveSDK.MTouch>, with event: SalemoveSDK.MEvent?)
  open func mTouchesEnded(_ touches: Swift.Set<SalemoveSDK.MTouch>, with event: SalemoveSDK.MEvent?)
  open func mTouchesCancelled(_ touches: Swift.Set<SalemoveSDK.MTouch>, with event: SalemoveSDK.MEvent?)
  @objc public func gestureRecognizer(_ gestureRecognizer: SalemoveSDK.MGestureRecognizer, shouldReceive touch: SalemoveSDK.MTouch) -> Swift.Bool
  @objc public func gestureRecognizer(_ gestureRecognizer: SalemoveSDK.MGestureRecognizer, shouldRecognizeSimultaneouslyWith otherGestureRecognizer: SalemoveSDK.MGestureRecognizer) -> Swift.Bool
  @objc deinit
}
open class Size {
  final public let w: Swift.Double
  final public let h: Swift.Double
  public static let zero: SalemoveSDK.Size
  public init(_ w: Swift.Double, _ h: Swift.Double)
  public init(w: Swift.Double = 0, h: Swift.Double = 0)
  open func rect(at point: SalemoveSDK.Point = Point.origin) -> SalemoveSDK.Rect
  open func angle() -> Swift.Double
  @objc deinit
}
extension Size {
  public static func == (lhs: SalemoveSDK.Size, rhs: SalemoveSDK.Size) -> Swift.Bool
  public static func + (lhs: SalemoveSDK.Size, rhs: SalemoveSDK.Size) -> SalemoveSDK.Size
  public static func - (lhs: SalemoveSDK.Size, rhs: SalemoveSDK.Size) -> SalemoveSDK.Size
}
@_hasMissingDesignatedInitializers @objc public class EngagementFileProgress : ObjectiveC.NSObject {
  final public let fractionCompleted: Swift.Double
  @objc override dynamic public init()
  @objc deinit
}
@objc @_inheritsConvenienceInitializers open class SocketClientManager : ObjectiveC.NSObject {
  public static let sharedManager: SalemoveSDK.SocketClientManager
  open subscript(string: Swift.String) -> SalemoveSDK.SocketIOClient? {
    get
    set(socket)
  }
  open func addSocket(_ socket: SalemoveSDK.SocketIOClient, labeledAs label: Swift.String)
  @discardableResult
  open func removeSocket(withLabel label: Swift.String) -> SalemoveSDK.SocketIOClient?
  @discardableResult
  open func removeSocket(_ socket: SalemoveSDK.SocketIOClient) -> SalemoveSDK.SocketIOClient?
  open func removeSockets()
  @objc override dynamic public init()
  @objc deinit
}
public enum MultiTarget : SalemoveSDK.TargetType {
  case target(SalemoveSDK.TargetType)
  public init(_ target: SalemoveSDK.TargetType)
  public var path: Swift.String {
    get
  }
  public var baseURL: Foundation.URL {
    get
  }
  public var method: SalemoveSDK.MoyaMethod {
    get
  }
  public var sampleData: Foundation.Data {
    get
  }
  public var task: SalemoveSDK.Task {
    get
  }
  public var validationType: SalemoveSDK.ValidationType {
    get
  }
  public var headers: [Swift.String : Swift.String]? {
    get
  }
  public var target: SalemoveSDK.TargetType {
    get
  }
}
extension MultiTarget : SalemoveSDK.AccessTokenAuthorizable {
  public var authorizationType: SalemoveSDK.AuthorizationType? {
    get
  }
}
extension MoyaProvider {
  final public class func defaultEndpointMapping(for target: Target) -> SalemoveSDK.Endpoint
  final public class func defaultRequestMapping(for endpoint: SalemoveSDK.Endpoint, closure: (Swift.Result<Foundation.URLRequest, SalemoveSDK.MoyaError>) -> Swift.Void)
  final public class func defaultAlamofireSession() -> SalemoveSDK.AlamofireSession
}
@_hasMissingDesignatedInitializers open class Easing {
  public static let ease: SalemoveSDK.Easing
  public static let linear: SalemoveSDK.Easing
  public static let easeIn: SalemoveSDK.Easing
  public static let easeOut: SalemoveSDK.Easing
  public static let easeInOut: SalemoveSDK.Easing
  public static let elasticOut: SalemoveSDK.Easing
  public static let elasticInOut: SalemoveSDK.Easing
  public static func elasticOut(elasticity: Swift.Double = 10.0) -> SalemoveSDK.ElasticOut
  public static func elasticInOut(elasticity: Swift.Double = 10.0) -> SalemoveSDK.ElasticInOut
  open func progressFor(time: Swift.Double) -> Swift.Double
  @objc deinit
}
@_hasMissingDesignatedInitializers public class ElasticOut : SalemoveSDK.Easing {
  override open func progressFor(time: Swift.Double) -> Swift.Double
  @objc deinit
}
@_hasMissingDesignatedInitializers public class ElasticInOut : SalemoveSDK.Easing {
  override open func progressFor(time: Swift.Double) -> Swift.Double
  @objc deinit
}
extension Salemove {
  @objc final public func configure(site: Swift.String) throws
  @objc final public func configure(environment: Swift.String) throws
  @objc final public func configure(interactor: SalemoveSDK.Interactable)
  @objc final public func configure(appToken: Swift.String) throws
  @objc final public func configure(apiToken: Swift.String) throws
}
extension Salemove {
  @objc final public func requestVisitorCode(completion: @escaping SalemoveSDK.VisitorCodeBlock)
}
extension Salemove {
  @objc final public func updateInformation(name: Swift.String?, email: Swift.String?, phone: Swift.String?, externalID: Swift.String?, customAttributes: [Swift.String : Swift.String]?, completion: @escaping SalemoveSDK.SuccessBlock)
}
extension Salemove {
  @objc final public func clearSession()
}
extension Salemove {
  @objc final public func requestMediaUpgrade(offer: SalemoveSDK.MediaUpgradeOffer, completion: @escaping SalemoveSDK.SuccessBlock)
}
extension Salemove {
  @objc final public func send(selectedOptionValue: Swift.String, messageId: Swift.String, completion: @escaping SalemoveSDK.MessageBlock)
  @objc final public func send(message: Swift.String = "", attachment: SalemoveSDK.Attachment? = nil, completion: @escaping SalemoveSDK.MessageBlock)
  @objc final public func send(message: Swift.String, queueID: Swift.String, completion: @escaping SalemoveSDK.MessageBlock)
  @objc final public func sendMessagePreview(message: Swift.String, completion: @escaping SalemoveSDK.SuccessBlock)
}
public protocol ReactiveExtensionsProvider {
}
extension ReactiveExtensionsProvider {
  public var reactive: SalemoveSDK.Reactive<Self> {
    get
  }
  public static var reactive: SalemoveSDK.Reactive<Self>.Type {
    get
  }
}
public struct Reactive<Base> {
  public let base: Base
}
open class RoundRect : SalemoveSDK.Locus {
  final public let rect: SalemoveSDK.Rect
  final public let rx: Swift.Double
  final public let ry: Swift.Double
  public init(rect: SalemoveSDK.Rect, rx: Swift.Double = 0, ry: Swift.Double = 0)
  override open func bounds() -> SalemoveSDK.Rect
  override public init()
  @objc deinit
}
open class Fill : Swift.Equatable {
  public init()
  @objc deinit
}
public func == <T>(lhs: T, rhs: T) -> Swift.Bool where T : SalemoveSDK.Fill
public struct Delegated<Input, Output> {
  public init()
  public mutating func delegate<Target>(to target: Target, with callback: @escaping (Target, Input) -> Output) where Target : AnyObject
  public func call(_ input: Input) -> Output?
  public var isDelegateSet: Swift.Bool {
    get
  }
}
extension Delegated {
  public mutating func stronglyDelegate<Target>(to target: Target, with callback: @escaping (Target, Input) -> Output) where Target : AnyObject
  public mutating func manuallyDelegate(with callback: @escaping (Input) -> Output)
  public mutating func removeDelegate()
}
extension Delegated where Input == Swift.Void {
  public mutating func delegate<Target>(to target: Target, with callback: @escaping (Target) -> Output) where Target : AnyObject
  public mutating func stronglyDelegate<Target>(to target: Target, with callback: @escaping (Target) -> Output) where Target : AnyObject
}
extension Delegated where Input == Swift.Void {
  public func call() -> Output?
}
extension Delegated where Output == Swift.Void {
  public func call(_ input: Input)
}
extension Delegated where Input == Swift.Void, Output == Swift.Void {
  public func call()
}
@_hasMissingDesignatedInitializers final public class Lifetime {
  final public var ended: SalemoveSDK.Signal<Swift.Never, Swift.Never> {
    get
  }
  final public var hasEnded: Swift.Bool {
    get
  }
  convenience public init(_ token: SalemoveSDK.Lifetime.Token)
  @discardableResult
  final public func observeEnded(_ action: @escaping () -> Swift.Void) -> SalemoveSDK.Disposable?
  @discardableResult
  public static func += (lifetime: SalemoveSDK.Lifetime, disposable: SalemoveSDK.Disposable?) -> SalemoveSDK.Disposable?
  @objc deinit
}
extension Lifetime {
  public static func make() -> (lifetime: SalemoveSDK.Lifetime, token: SalemoveSDK.Lifetime.Token)
  public static let empty: SalemoveSDK.Lifetime
}
extension Lifetime {
  final public class Token {
    public init()
    final public func dispose()
    @objc deinit
  }
}
open class Line : SalemoveSDK.Locus {
  final public let x1: Swift.Double
  final public let y1: Swift.Double
  final public let x2: Swift.Double
  final public let y2: Swift.Double
  public init(_ x1: Swift.Double, _ y1: Swift.Double, _ x2: Swift.Double, _ y2: Swift.Double)
  public init(x1: Swift.Double = 0, y1: Swift.Double = 0, x2: Swift.Double = 0, y2: Swift.Double = 0)
  override open func bounds() -> SalemoveSDK.Rect
  override open func toPath() -> SalemoveSDK.Path
  override public init()
  @objc deinit
}
open class RetryPolicy : SalemoveSDK.AlamofireRequestInterceptor {
  public static let defaultRetryLimit: Swift.UInt
  public static let defaultExponentialBackoffBase: Swift.UInt
  public static let defaultExponentialBackoffScale: Swift.Double
  public static let defaultRetryableHTTPMethods: Swift.Set<SalemoveSDK.AlamofireHTTPMethod>
  public static let defaultRetryableHTTPStatusCodes: Swift.Set<Swift.Int>
  public static let defaultRetryableURLErrorCodes: Swift.Set<Foundation.URLError.Code>
  final public let retryLimit: Swift.UInt
  final public let exponentialBackoffBase: Swift.UInt
  final public let exponentialBackoffScale: Swift.Double
  final public let retryableHTTPMethods: Swift.Set<SalemoveSDK.AlamofireHTTPMethod>
  final public let retryableHTTPStatusCodes: Swift.Set<Swift.Int>
  final public let retryableURLErrorCodes: Swift.Set<Foundation.URLError.Code>
  public init(retryLimit: Swift.UInt = RetryPolicy.defaultRetryLimit, exponentialBackoffBase: Swift.UInt = RetryPolicy.defaultExponentialBackoffBase, exponentialBackoffScale: Swift.Double = RetryPolicy.defaultExponentialBackoffScale, retryableHTTPMethods: Swift.Set<SalemoveSDK.AlamofireHTTPMethod> = RetryPolicy.defaultRetryableHTTPMethods, retryableHTTPStatusCodes: Swift.Set<Swift.Int> = RetryPolicy.defaultRetryableHTTPStatusCodes, retryableURLErrorCodes: Swift.Set<Foundation.URLError.Code> = RetryPolicy.defaultRetryableURLErrorCodes)
  open func retry(_ request: SalemoveSDK.AlamofireRequest, for session: SalemoveSDK.AlamofireSession, dueTo error: Swift.Error, completion: @escaping (SalemoveSDK.RetryResult) -> Swift.Void)
  open func shouldRetry(request: SalemoveSDK.AlamofireRequest, dueTo error: Swift.Error) -> Swift.Bool
  @objc deinit
}
open class ConnectionLostRetryPolicy : SalemoveSDK.RetryPolicy {
  public init(retryLimit: Swift.UInt = RetryPolicy.defaultRetryLimit, exponentialBackoffBase: Swift.UInt = RetryPolicy.defaultExponentialBackoffBase, exponentialBackoffScale: Swift.Double = RetryPolicy.defaultExponentialBackoffScale, retryableHTTPMethods: Swift.Set<SalemoveSDK.AlamofireHTTPMethod> = RetryPolicy.defaultRetryableHTTPMethods)
  override public init(retryLimit: Swift.UInt = super, exponentialBackoffBase: Swift.UInt = super, exponentialBackoffScale: Swift.Double = super, retryableHTTPMethods: Swift.Set<SalemoveSDK.AlamofireHTTPMethod> = super, retryableHTTPStatusCodes: Swift.Set<Swift.Int> = super, retryableURLErrorCodes: Swift.Set<Foundation.URLError.Code> = super)
  @objc deinit
}
@_hasMissingDesignatedInitializers @objc public class Push : ObjectiveC.NSObject, Swift.Codable {
  @objc public var actionIdentifier: Swift.String {
    get
  }
  @objc public var type: SalemoveSDK.PushType {
    get
  }
  required public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
  @objc override dynamic public init()
  @objc deinit
}
@objc public enum PushType : Swift.Int {
  case unidentified
  case chatMessage
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers @objc public class EngagementRequest : ObjectiveC.NSObject {
  @objc public var timeout: Swift.Int {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
@_hasMissingDesignatedInitializers open class Align {
  public static let min: SalemoveSDK.Align
  public static let mid: SalemoveSDK.Align
  public static let max: SalemoveSDK.Align
  open func align(outer: Swift.Double, inner: Swift.Double) -> Swift.Double
  open func align(size: Swift.Double) -> Swift.Double
  @objc deinit
}
public struct SSLClientCertificateError : Foundation.LocalizedError {
  public var errorDescription: Swift.String?
}
public class SSLClientCertificate {
  convenience public init(pkcs12Path: Swift.String, password: Swift.String) throws
  public init(identity: Security.SecIdentity, identityCertificate: Security.SecCertificate)
  convenience public init(pkcs12Url: Foundation.URL, password: Swift.String) throws
  public init(pkcs12Url: Foundation.URL, importOptions: CoreFoundation.CFDictionary) throws
  @objc deinit
}
open class RadialGradient : SalemoveSDK.Gradient {
  final public let cx: Swift.Double
  final public let cy: Swift.Double
  final public let fx: Swift.Double
  final public let fy: Swift.Double
  final public let r: Swift.Double
  public init(cx: Swift.Double = 0.5, cy: Swift.Double = 0.5, fx: Swift.Double = 0.5, fy: Swift.Double = 0.5, r: Swift.Double = 0.5, userSpace: Swift.Bool = false, stops: [SalemoveSDK.Stop] = [])
  override public init(userSpace: Swift.Bool = super, stops: [SalemoveSDK.Stop] = super)
  @objc deinit
}
@_hasMissingDesignatedInitializers open class TapEvent : SalemoveSDK.MacawEvent {
  final public let location: SalemoveSDK.Point
  @objc deinit
}
public enum SocketClientEvent : Swift.String {
  case connect
  case disconnect
  case error
  case reconnect
  case reconnectAttempt
  case statusChange
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public typealias Payload = [Swift.String : Any]
public typealias PayloadClosure = () -> SalemoveSDK.Payload?
@_hasMissingDesignatedInitializers public class SwiftPhoenixClientSocket {
  final public let endPoint: Swift.String
  public var endPointUrl: Foundation.URL {
    get
  }
  public var params: SalemoveSDK.Payload? {
    get
  }
  final public let paramsClosure: SalemoveSDK.PayloadClosure?
  public var encode: ([Swift.String : Any]) -> Foundation.Data
  public var decode: (Foundation.Data) -> [Swift.String : Any]?
  public var timeout: Foundation.TimeInterval
  public var heartbeatInterval: Foundation.TimeInterval
  public var reconnectAfter: (Swift.Int) -> Foundation.TimeInterval
  public var rejoinAfter: (Swift.Int) -> Foundation.TimeInterval
  public var logger: ((Swift.String) -> Swift.Void)?
  public var skipHeartbeat: Swift.Bool
  public var disableSSLCertValidation: Swift.Bool
  public var security: SalemoveSDK.SSLTrustValidator?
  public var enabledSSLCipherSuites: [Security.SSLCipherSuite]?
  convenience public init(_ endPoint: Swift.String, params: SalemoveSDK.Payload? = nil)
  convenience public init(_ endPoint: Swift.String, paramsClosure: SalemoveSDK.PayloadClosure?)
  @objc deinit
  public var websocketProtocol: Swift.String {
    get
  }
  public var isConnected: Swift.Bool {
    get
  }
  public func connect()
  public func disconnect(code: SalemoveSDK.CloseCode = CloseCode.normal, callback: (() -> Swift.Void)? = nil)
  public func onOpen(callback: @escaping () -> Swift.Void)
  public func delegateOnOpen<T>(to owner: T, callback: @escaping ((T) -> Swift.Void)) where T : AnyObject
  public func onClose(callback: @escaping () -> Swift.Void)
  public func delegateOnClose<T>(to owner: T, callback: @escaping ((T) -> Swift.Void)) where T : AnyObject
  public func onError(callback: @escaping (Swift.Error) -> Swift.Void)
  public func delegateOnError<T>(to owner: T, callback: @escaping ((T, Swift.Error) -> Swift.Void)) where T : AnyObject
  public func onMessage(callback: @escaping (SalemoveSDK.SwiftPhoenixClientMessage) -> Swift.Void)
  public func delegateOnMessage<T>(to owner: T, callback: @escaping ((T, SalemoveSDK.SwiftPhoenixClientMessage) -> Swift.Void)) where T : AnyObject
  public func releaseCallbacks()
  public func channel(_ topic: Swift.String, params: [Swift.String : Any] = [:]) -> SalemoveSDK.SwiftPhoenixClientChannel
  public func remove(_ channel: SalemoveSDK.SwiftPhoenixClientChannel)
  public func makeRef() -> Swift.String
}
extension SwiftPhoenixClientSocket : SalemoveSDK.WebSocketDelegate {
  public func websocketDidConnect(socket: SalemoveSDK.WebSocketClient)
  public func websocketDidDisconnect(socket: SalemoveSDK.WebSocketClient, error: Swift.Error?)
  public func websocketDidReceiveMessage(socket: SalemoveSDK.WebSocketClient, text: Swift.String)
  public func websocketDidReceiveData(socket: SalemoveSDK.WebSocketClient, data: Foundation.Data)
}
open class Polygon : SalemoveSDK.Locus {
  final public let points: [Swift.Double]
  public init(_ points: [Swift.Double])
  public init(points: [Swift.Double] = [])
  override open func bounds() -> SalemoveSDK.Rect
  override open func toPath() -> SalemoveSDK.Path
  override public init()
  @objc deinit
}
open class Pattern : SalemoveSDK.Fill {
  final public let content: SalemoveSDK.Node
  final public let bounds: SalemoveSDK.Rect
  final public let userSpace: Swift.Bool
  public init(content: SalemoveSDK.Node, bounds: SalemoveSDK.Rect, userSpace: Swift.Bool = false)
  override public init()
  @objc deinit
}
@objc open class SessionDelegate : ObjectiveC.NSObject {
  public init(fileManager: Foundation.FileManager = .default)
  @objc override dynamic public init()
  @objc deinit
}
extension SessionDelegate : Foundation.URLSessionDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: Swift.Error?)
}
extension SessionDelegate : Foundation.URLSessionTaskDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge, completionHandler: @escaping (Foundation.URLSession.AuthChallengeDisposition, Foundation.URLCredential?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, needNewBodyStream completionHandler: @escaping (Foundation.InputStream?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest, completionHandler: @escaping (Foundation.URLRequest?) -> Swift.Void)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
}
extension SessionDelegate : Foundation.URLSessionDataDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse, completionHandler: @escaping (Foundation.CachedURLResponse?) -> Swift.Void)
}
extension SessionDelegate : Foundation.URLSessionDownloadDelegate {
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  @objc dynamic open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
}
@_hasMissingDesignatedInitializers open class GeomUtils {
  @available(*, deprecated)
  open class func concat(t1: SalemoveSDK.Transform, t2: SalemoveSDK.Transform) -> SalemoveSDK.Transform
  open class func centerRotation(node: SalemoveSDK.Node, place: SalemoveSDK.Transform, angle: Swift.Double) -> SalemoveSDK.Transform
  open class func anchorRotation(node: SalemoveSDK.Node, place: SalemoveSDK.Transform, anchor: SalemoveSDK.Point, angle: Swift.Double) -> SalemoveSDK.Transform
  open class func centerScale(node: SalemoveSDK.Node, sx: Swift.Double, sy: Swift.Double) -> SalemoveSDK.Transform
  open class func center(node: SalemoveSDK.Node) -> SalemoveSDK.Point
  @objc deinit
}
open class MoveTo : SalemoveSDK.PathBuilder {
  public init(_ x: Swift.Double, _ y: Swift.Double)
  public init(x: Swift.Double, y: Swift.Double)
  override public init(segment: SalemoveSDK.PathSegment, rest: SalemoveSDK.PathBuilder? = super)
  @objc deinit
}
public protocol LocusInterpolation : SalemoveSDK.Interpolable {
}
extension Locus : SalemoveSDK.LocusInterpolation {
  public func interpolate(_ endValue: SalemoveSDK.Locus, progress: Swift.Double) -> Self
}
open class PathBuilder {
  final public let segment: SalemoveSDK.PathSegment
  final public let rest: SalemoveSDK.PathBuilder?
  public init(segment: SalemoveSDK.PathSegment, rest: SalemoveSDK.PathBuilder? = nil)
  open func moveTo(x: Swift.Double, y: Swift.Double) -> SalemoveSDK.PathBuilder
  open func lineTo(x: Swift.Double, y: Swift.Double) -> SalemoveSDK.PathBuilder
  open func cubicTo(x1: Swift.Double, y1: Swift.Double, x2: Swift.Double, y2: Swift.Double, x: Swift.Double, y: Swift.Double) -> SalemoveSDK.PathBuilder
  open func quadraticTo(x1: Swift.Double, y1: Swift.Double, x: Swift.Double, y: Swift.Double) -> SalemoveSDK.PathBuilder
  open func arcTo(rx: Swift.Double, ry: Swift.Double, angle: Swift.Double, largeArc: Swift.Bool, sweep: Swift.Bool, x: Swift.Double, y: Swift.Double) -> SalemoveSDK.PathBuilder
  open func close() -> SalemoveSDK.PathBuilder
  open func m(_ x: Swift.Double, _ y: Swift.Double) -> SalemoveSDK.PathBuilder
  open func M(_ x: Swift.Double, _ y: Swift.Double) -> SalemoveSDK.PathBuilder
  open func l(_ x: Swift.Double, _ y: Swift.Double) -> SalemoveSDK.PathBuilder
  open func L(_ x: Swift.Double, _ y: Swift.Double) -> SalemoveSDK.PathBuilder
  open func h(_ x: Swift.Double) -> SalemoveSDK.PathBuilder
  open func H(_ x: Swift.Double) -> SalemoveSDK.PathBuilder
  open func v(_ y: Swift.Double) -> SalemoveSDK.PathBuilder
  open func V(_ y: Swift.Double) -> SalemoveSDK.PathBuilder
  open func c(_ x1: Swift.Double, _ y1: Swift.Double, _ x2: Swift.Double, _ y2: Swift.Double, _ x: Swift.Double, _ y: Swift.Double) -> SalemoveSDK.PathBuilder
  open func C(_ x1: Swift.Double, _ y1: Swift.Double, _ x2: Swift.Double, _ y2: Swift.Double, _ x: Swift.Double, _ y: Swift.Double) -> SalemoveSDK.PathBuilder
  open func s(_ x2: Swift.Double, _ y2: Swift.Double, _ x: Swift.Double, _ y: Swift.Double) -> SalemoveSDK.PathBuilder
  open func S(_ x2: Swift.Double, _ y2: Swift.Double, _ x: Swift.Double, _ y: Swift.Double) -> SalemoveSDK.PathBuilder
  open func q(_ x1: Swift.Double, _ y1: Swift.Double, _ x: Swift.Double, _ y: Swift.Double) -> SalemoveSDK.PathBuilder
  open func Q(_ x1: Swift.Double, _ y1: Swift.Double, _ x: Swift.Double, _ y: Swift.Double) -> SalemoveSDK.PathBuilder
  open func t(_ x: Swift.Double, _ y: Swift.Double) -> SalemoveSDK.PathBuilder
  open func T(_ x: Swift.Double, _ y: Swift.Double) -> SalemoveSDK.PathBuilder
  open func a(_ rx: Swift.Double, _ ry: Swift.Double, _ angle: Swift.Double, _ largeArc: Swift.Bool, _ sweep: Swift.Bool, _ x: Swift.Double, _ y: Swift.Double) -> SalemoveSDK.PathBuilder
  open func A(_ rx: Swift.Double, _ ry: Swift.Double, _ angle: Swift.Double, _ largeArc: Swift.Bool, _ sweep: Swift.Bool, _ x: Swift.Double, _ y: Swift.Double) -> SalemoveSDK.PathBuilder
  open func e(_ x: Swift.Double, _ y: Swift.Double, _ w: Swift.Double, _ h: Swift.Double, _ startAngle: Swift.Double, _ arcAngle: Swift.Double) -> SalemoveSDK.PathBuilder
  open func E(_ x: Swift.Double, _ y: Swift.Double, _ w: Swift.Double, _ h: Swift.Double, _ startAngle: Swift.Double, _ arcAngle: Swift.Double) -> SalemoveSDK.PathBuilder
  open func Z() -> SalemoveSDK.PathBuilder
  open func build() -> SalemoveSDK.Path
  @objc deinit
}
open class Stop : Swift.Equatable {
  final public let offset: Swift.Double
  final public let color: SalemoveSDK.Color
  public init(offset: Swift.Double = 0, color: SalemoveSDK.Color)
  @objc deinit
}
public func == (lhs: SalemoveSDK.Stop, rhs: SalemoveSDK.Stop) -> Swift.Bool
@objc @_hasMissingDesignatedInitializers @objcMembers public class EngagementFile : ObjectiveC.NSObject {
  @objc public var id: Swift.String? {
    get
  }
  public var size: Swift.Double? {
    get
  }
  @objc public var contentType: Swift.String? {
    get
  }
  public var isDeleted: Swift.Bool? {
    get
  }
  @objc final public let name: Swift.String
  @objc final public let url: Foundation.URL?
  @objc public init(name: Swift.String = "content", url: Foundation.URL)
  @objc public init(id: Swift.String)
  @objc override dynamic public init()
  @objc deinit
}
public protocol SSLTrustValidator {
  func isValid(_ trust: Security.SecTrust, domain: Swift.String?) -> Swift.Bool
}
open class SSLCert {
  public init(data: Foundation.Data)
  public init(key: Security.SecKey)
  @objc deinit
}
open class SSLSecurity : SalemoveSDK.SSLTrustValidator {
  public var validatedDN: Swift.Bool
  public var validateEntireChain: Swift.Bool
  convenience public init(usePublicKeys: Swift.Bool = false)
  public init(certs: [SalemoveSDK.SSLCert], usePublicKeys: Swift.Bool)
  open func isValid(_ trust: Security.SecTrust, domain: Swift.String?) -> Swift.Bool
  public func extractPublicKey(_ data: Foundation.Data) -> Security.SecKey?
  public func extractPublicKey(_ cert: Security.SecCertificate, policy: Security.SecPolicy) -> Security.SecKey?
  public func certificateChain(_ trust: Security.SecTrust) -> [Foundation.Data]
  public func publicKeyChain(_ trust: Security.SecTrust) -> [Security.SecKey]
  @objc deinit
}
open class Gradient : SalemoveSDK.Fill {
  final public let userSpace: Swift.Bool
  final public let stops: [SalemoveSDK.Stop]
  public init(userSpace: Swift.Bool = false, stops: [SalemoveSDK.Stop] = [])
  override public init()
  @objc deinit
}
open class AnimationDescription<T> {
  final public let valueFunc: (Swift.Double) -> T
  open var duration: Swift.Double
  open var delay: Swift.Double
  public init(valueFunc: @escaping (Swift.Double) -> T, duration: Swift.Double = 1.0, delay: Swift.Double = 0.0)
  open func t(_ duration: Swift.Double, delay: Swift.Double = 0.0) -> SalemoveSDK.AnimationDescription<T>
  @objc deinit
}
open class Arc : SalemoveSDK.Locus {
  final public let ellipse: SalemoveSDK.Ellipse
  final public let shift: Swift.Double
  final public let extent: Swift.Double
  public init(ellipse: SalemoveSDK.Ellipse, shift: Swift.Double = 0, extent: Swift.Double = 0)
  override open func bounds() -> SalemoveSDK.Rect
  override open func toPath() -> SalemoveSDK.Path
  override public init()
  @objc deinit
}
extension Signal {
  @available(*, unavailable, message: "Use the `Signal.init` that accepts a two-argument generator.")
  convenience public init(_ generator: (SalemoveSDK.Signal<Value, Error>.Observer) -> SalemoveSDK.Disposable?)
}
extension Lifetime {
  @discardableResult
  @available(*, unavailable, message: "Use `observeEnded(_:)` with a method reference to `dispose()` instead.")
  final public func add(_ d: SalemoveSDK.Disposable?) -> SalemoveSDK.Disposable?
}
open class Polyline : SalemoveSDK.Locus {
  final public let points: [Swift.Double]
  public init(_ points: [Swift.Double])
  public init(points: [Swift.Double] = [])
  override open func bounds() -> SalemoveSDK.Rect
  override open func toPath() -> SalemoveSDK.Path
  override public init()
  @objc deinit
}
public enum Task {
  case requestPlain
  case requestData(Foundation.Data)
  case requestJSONEncodable(Swift.Encodable)
  case requestCustomJSONEncodable(Swift.Encodable, encoder: Foundation.JSONEncoder)
  case requestParameters(parameters: [Swift.String : Any], encoding: SalemoveSDK.ParameterEncoding)
  case requestCompositeData(bodyData: Foundation.Data, urlParameters: [Swift.String : Any])
  case requestCompositeParameters(bodyParameters: [Swift.String : Any], bodyEncoding: SalemoveSDK.ParameterEncoding, urlParameters: [Swift.String : Any])
  case uploadFile(Foundation.URL)
  case uploadMultipart([SalemoveSDK.MoyaMultipartFormData])
  case uploadCompositeMultipart([SalemoveSDK.MoyaMultipartFormData], urlParameters: [Swift.String : Any])
  case downloadDestination(SalemoveSDK.DownloadDestination)
  case downloadParameters(parameters: [Swift.String : Any], encoding: SalemoveSDK.ParameterEncoding, destination: SalemoveSDK.DownloadDestination)
}
public typealias Parameters = [Swift.String : Any]
public protocol AlamofireParameterEncoding {
  func encode(_ urlRequest: SalemoveSDK.AlamofireURLRequestConvertible, with parameters: SalemoveSDK.Parameters?) throws -> Foundation.URLRequest
}
public struct AlamofireURLEncoding : SalemoveSDK.AlamofireParameterEncoding {
  public enum Destination {
    case methodDependent
    case queryString
    case httpBody
    public static func == (a: SalemoveSDK.AlamofireURLEncoding.Destination, b: SalemoveSDK.AlamofireURLEncoding.Destination) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum ArrayEncoding {
    case brackets
    case noBrackets
    public static func == (a: SalemoveSDK.AlamofireURLEncoding.ArrayEncoding, b: SalemoveSDK.AlamofireURLEncoding.ArrayEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public enum BoolEncoding {
    case numeric
    case literal
    public static func == (a: SalemoveSDK.AlamofireURLEncoding.BoolEncoding, b: SalemoveSDK.AlamofireURLEncoding.BoolEncoding) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public static var `default`: SalemoveSDK.AlamofireURLEncoding {
    get
  }
  public static var queryString: SalemoveSDK.AlamofireURLEncoding {
    get
  }
  public static var httpBody: SalemoveSDK.AlamofireURLEncoding {
    get
  }
  public let destination: SalemoveSDK.AlamofireURLEncoding.Destination
  public let arrayEncoding: SalemoveSDK.AlamofireURLEncoding.ArrayEncoding
  public let boolEncoding: SalemoveSDK.AlamofireURLEncoding.BoolEncoding
  public init(destination: SalemoveSDK.AlamofireURLEncoding.Destination = .methodDependent, arrayEncoding: SalemoveSDK.AlamofireURLEncoding.ArrayEncoding = .brackets, boolEncoding: SalemoveSDK.AlamofireURLEncoding.BoolEncoding = .numeric)
  public func encode(_ urlRequest: SalemoveSDK.AlamofireURLRequestConvertible, with parameters: SalemoveSDK.Parameters?) throws -> Foundation.URLRequest
  public func queryComponents(fromKey key: Swift.String, value: Any) -> [(Swift.String, Swift.String)]
  public func escape(_ string: Swift.String) -> Swift.String
}
public struct AlamofireJSONEncoding : SalemoveSDK.AlamofireParameterEncoding {
  public static var `default`: SalemoveSDK.AlamofireJSONEncoding {
    get
  }
  public static var prettyPrinted: SalemoveSDK.AlamofireJSONEncoding {
    get
  }
  public let options: Foundation.JSONSerialization.WritingOptions
  public init(options: Foundation.JSONSerialization.WritingOptions = [])
  public func encode(_ urlRequest: SalemoveSDK.AlamofireURLRequestConvertible, with parameters: SalemoveSDK.Parameters?) throws -> Foundation.URLRequest
  public func encode(_ urlRequest: SalemoveSDK.AlamofireURLRequestConvertible, withJSONObject jsonObject: Any? = nil) throws -> Foundation.URLRequest
}
public protocol PluginType {
  func prepare(_ request: Foundation.URLRequest, target: SalemoveSDK.TargetType) -> Foundation.URLRequest
  func willSend(_ request: SalemoveSDK.RequestType, target: SalemoveSDK.TargetType)
  func didReceive(_ result: Swift.Result<SalemoveSDK.MoyaResponse, SalemoveSDK.MoyaError>, target: SalemoveSDK.TargetType)
  func process(_ result: Swift.Result<SalemoveSDK.MoyaResponse, SalemoveSDK.MoyaError>, target: SalemoveSDK.TargetType) -> Swift.Result<SalemoveSDK.MoyaResponse, SalemoveSDK.MoyaError>
}
extension PluginType {
  public func prepare(_ request: Foundation.URLRequest, target: SalemoveSDK.TargetType) -> Foundation.URLRequest
  public func willSend(_ request: SalemoveSDK.RequestType, target: SalemoveSDK.TargetType)
  public func didReceive(_ result: Swift.Result<SalemoveSDK.MoyaResponse, SalemoveSDK.MoyaError>, target: SalemoveSDK.TargetType)
  public func process(_ result: Swift.Result<SalemoveSDK.MoyaResponse, SalemoveSDK.MoyaError>, target: SalemoveSDK.TargetType) -> Swift.Result<SalemoveSDK.MoyaResponse, SalemoveSDK.MoyaError>
}
public protocol RequestType {
  var request: Foundation.URLRequest? { get }
  var sessionHeaders: [Swift.String : Swift.String] { get }
  func authenticate(username: Swift.String, password: Swift.String, persistence: Foundation.URLCredential.Persistence) -> Self
  func authenticate(with credential: Foundation.URLCredential) -> Self
  func cURLDescription(calling handler: @escaping (Swift.String) -> Swift.Void) -> Self
}
public protocol PropertyProtocol : AnyObject, SalemoveSDK.BindingSource {
  var value: Self.Value { get }
  var producer: SalemoveSDK.SignalProducer<Self.Value, Swift.Never> { get }
  var signal: SalemoveSDK.Signal<Self.Value, Swift.Never> { get }
}
public protocol MutablePropertyProtocol : SalemoveSDK.BindingTargetProvider, SalemoveSDK.PropertyProtocol {
  var value: Self.Value { get set }
  var lifetime: SalemoveSDK.Lifetime { get }
}
extension MutablePropertyProtocol {
  public var bindingTarget: SalemoveSDK.BindingTarget<Self.Value> {
    get
  }
}
public protocol ComposableMutablePropertyProtocol : SalemoveSDK.MutablePropertyProtocol {
  func withValue<Result>(_ action: (Self.Value) throws -> Result) rethrows -> Result
  func modify<Result>(_ action: (inout Self.Value) throws -> Result) rethrows -> Result
}
extension PropertyProtocol {
  public func map<U>(_ transform: @escaping (Self.Value) -> U) -> SalemoveSDK.Property<U>
  public func map<U>(value: U) -> SalemoveSDK.Property<U>
  public func map<U>(_ keyPath: Swift.KeyPath<Self.Value, U>) -> SalemoveSDK.Property<U>
  public func filter(initial: Self.Value, _ predicate: @escaping (Self.Value) -> Swift.Bool) -> SalemoveSDK.Property<Self.Value>
  public func combineLatest<P>(with other: P) -> SalemoveSDK.Property<(Self.Value, P.Value)> where P : SalemoveSDK.PropertyProtocol
  public func zip<P>(with other: P) -> SalemoveSDK.Property<(Self.Value, P.Value)> where P : SalemoveSDK.PropertyProtocol
  public func combinePrevious(_ initial: Self.Value) -> SalemoveSDK.Property<(Self.Value, Self.Value)>
  public func skipRepeats(_ isEquivalent: @escaping (Self.Value, Self.Value) -> Swift.Bool) -> SalemoveSDK.Property<Self.Value>
}
extension PropertyProtocol where Self.Value : Swift.Equatable {
  public func skipRepeats() -> SalemoveSDK.Property<Self.Value>
}
extension PropertyProtocol where Self.Value : SalemoveSDK.PropertyProtocol {
  public func flatten(_ strategy: SalemoveSDK.FlattenStrategy) -> SalemoveSDK.Property<Self.Value.Value>
}
extension PropertyProtocol {
  public func flatMap<P>(_ strategy: SalemoveSDK.FlattenStrategy, _ transform: @escaping (Self.Value) -> P) -> SalemoveSDK.Property<P.Value> where P : SalemoveSDK.PropertyProtocol
  public func uniqueValues<Identity>(_ transform: @escaping (Self.Value) -> Identity) -> SalemoveSDK.Property<Self.Value> where Identity : Swift.Hashable
}
extension PropertyProtocol where Self.Value : Swift.Hashable {
  public func uniqueValues() -> SalemoveSDK.Property<Self.Value>
}
extension PropertyProtocol {
  public static func combineLatest<A, B>(_ a: A, _ b: B) -> SalemoveSDK.Property<(A.Value, B.Value)> where A : SalemoveSDK.PropertyProtocol, B : SalemoveSDK.PropertyProtocol, Self.Value == A.Value
  public static func combineLatest<A, B, C>(_ a: A, _ b: B, _ c: C) -> SalemoveSDK.Property<(Self.Value, B.Value, C.Value)> where A : SalemoveSDK.PropertyProtocol, B : SalemoveSDK.PropertyProtocol, C : SalemoveSDK.PropertyProtocol, Self.Value == A.Value
  public static func combineLatest<A, B, C, D>(_ a: A, _ b: B, _ c: C, _ d: D) -> SalemoveSDK.Property<(Self.Value, B.Value, C.Value, D.Value)> where A : SalemoveSDK.PropertyProtocol, B : SalemoveSDK.PropertyProtocol, C : SalemoveSDK.PropertyProtocol, D : SalemoveSDK.PropertyProtocol, Self.Value == A.Value
  public static func combineLatest<A, B, C, D, E>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E) -> SalemoveSDK.Property<(Self.Value, B.Value, C.Value, D.Value, E.Value)> where A : SalemoveSDK.PropertyProtocol, B : SalemoveSDK.PropertyProtocol, C : SalemoveSDK.PropertyProtocol, D : SalemoveSDK.PropertyProtocol, E : SalemoveSDK.PropertyProtocol, Self.Value == A.Value
  public static func combineLatest<A, B, C, D, E, F>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F) -> SalemoveSDK.Property<(Self.Value, B.Value, C.Value, D.Value, E.Value, F.Value)> where A : SalemoveSDK.PropertyProtocol, B : SalemoveSDK.PropertyProtocol, C : SalemoveSDK.PropertyProtocol, D : SalemoveSDK.PropertyProtocol, E : SalemoveSDK.PropertyProtocol, F : SalemoveSDK.PropertyProtocol, Self.Value == A.Value
  public static func combineLatest<A, B, C, D, E, F, G>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F, _ g: G) -> SalemoveSDK.Property<(Self.Value, B.Value, C.Value, D.Value, E.Value, F.Value, G.Value)> where A : SalemoveSDK.PropertyProtocol, B : SalemoveSDK.PropertyProtocol, C : SalemoveSDK.PropertyProtocol, D : SalemoveSDK.PropertyProtocol, E : SalemoveSDK.PropertyProtocol, F : SalemoveSDK.PropertyProtocol, G : SalemoveSDK.PropertyProtocol, Self.Value == A.Value
  public static func combineLatest<A, B, C, D, E, F, G, H>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F, _ g: G, _ h: H) -> SalemoveSDK.Property<(Self.Value, B.Value, C.Value, D.Value, E.Value, F.Value, G.Value, H.Value)> where A : SalemoveSDK.PropertyProtocol, B : SalemoveSDK.PropertyProtocol, C : SalemoveSDK.PropertyProtocol, D : SalemoveSDK.PropertyProtocol, E : SalemoveSDK.PropertyProtocol, F : SalemoveSDK.PropertyProtocol, G : SalemoveSDK.PropertyProtocol, H : SalemoveSDK.PropertyProtocol, Self.Value == A.Value
  public static func combineLatest<A, B, C, D, E, F, G, H, I>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F, _ g: G, _ h: H, _ i: I) -> SalemoveSDK.Property<(Self.Value, B.Value, C.Value, D.Value, E.Value, F.Value, G.Value, H.Value, I.Value)> where A : SalemoveSDK.PropertyProtocol, B : SalemoveSDK.PropertyProtocol, C : SalemoveSDK.PropertyProtocol, D : SalemoveSDK.PropertyProtocol, E : SalemoveSDK.PropertyProtocol, F : SalemoveSDK.PropertyProtocol, G : SalemoveSDK.PropertyProtocol, H : SalemoveSDK.PropertyProtocol, I : SalemoveSDK.PropertyProtocol, Self.Value == A.Value
  public static func combineLatest<A, B, C, D, E, F, G, H, I, J>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F, _ g: G, _ h: H, _ i: I, _ j: J) -> SalemoveSDK.Property<(Self.Value, B.Value, C.Value, D.Value, E.Value, F.Value, G.Value, H.Value, I.Value, J.Value)> where A : SalemoveSDK.PropertyProtocol, B : SalemoveSDK.PropertyProtocol, C : SalemoveSDK.PropertyProtocol, D : SalemoveSDK.PropertyProtocol, E : SalemoveSDK.PropertyProtocol, F : SalemoveSDK.PropertyProtocol, G : SalemoveSDK.PropertyProtocol, H : SalemoveSDK.PropertyProtocol, I : SalemoveSDK.PropertyProtocol, J : SalemoveSDK.PropertyProtocol, Self.Value == A.Value
  public static func combineLatest<S>(_ properties: S) -> SalemoveSDK.Property<[S.Iterator.Element.Value]>? where S : Swift.Sequence, S.Element : SalemoveSDK.PropertyProtocol
  public static func combineLatest<S>(_ properties: S, emptySentinel: [S.Iterator.Element.Value]) -> SalemoveSDK.Property<[S.Iterator.Element.Value]> where S : Swift.Sequence, S.Element : SalemoveSDK.PropertyProtocol
  public static func zip<A, B>(_ a: A, _ b: B) -> SalemoveSDK.Property<(Self.Value, B.Value)> where A : SalemoveSDK.PropertyProtocol, B : SalemoveSDK.PropertyProtocol, Self.Value == A.Value
  public static func zip<A, B, C>(_ a: A, _ b: B, _ c: C) -> SalemoveSDK.Property<(Self.Value, B.Value, C.Value)> where A : SalemoveSDK.PropertyProtocol, B : SalemoveSDK.PropertyProtocol, C : SalemoveSDK.PropertyProtocol, Self.Value == A.Value
  public static func zip<A, B, C, D>(_ a: A, _ b: B, _ c: C, _ d: D) -> SalemoveSDK.Property<(Self.Value, B.Value, C.Value, D.Value)> where A : SalemoveSDK.PropertyProtocol, B : SalemoveSDK.PropertyProtocol, C : SalemoveSDK.PropertyProtocol, D : SalemoveSDK.PropertyProtocol, Self.Value == A.Value
  public static func zip<A, B, C, D, E>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E) -> SalemoveSDK.Property<(Self.Value, B.Value, C.Value, D.Value, E.Value)> where A : SalemoveSDK.PropertyProtocol, B : SalemoveSDK.PropertyProtocol, C : SalemoveSDK.PropertyProtocol, D : SalemoveSDK.PropertyProtocol, E : SalemoveSDK.PropertyProtocol, Self.Value == A.Value
  public static func zip<A, B, C, D, E, F>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F) -> SalemoveSDK.Property<(Self.Value, B.Value, C.Value, D.Value, E.Value, F.Value)> where A : SalemoveSDK.PropertyProtocol, B : SalemoveSDK.PropertyProtocol, C : SalemoveSDK.PropertyProtocol, D : SalemoveSDK.PropertyProtocol, E : SalemoveSDK.PropertyProtocol, F : SalemoveSDK.PropertyProtocol, Self.Value == A.Value
  public static func zip<A, B, C, D, E, F, G>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F, _ g: G) -> SalemoveSDK.Property<(Self.Value, B.Value, C.Value, D.Value, E.Value, F.Value, G.Value)> where A : SalemoveSDK.PropertyProtocol, B : SalemoveSDK.PropertyProtocol, C : SalemoveSDK.PropertyProtocol, D : SalemoveSDK.PropertyProtocol, E : SalemoveSDK.PropertyProtocol, F : SalemoveSDK.PropertyProtocol, G : SalemoveSDK.PropertyProtocol, Self.Value == A.Value
  public static func zip<A, B, C, D, E, F, G, H>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F, _ g: G, _ h: H) -> SalemoveSDK.Property<(Self.Value, B.Value, C.Value, D.Value, E.Value, F.Value, G.Value, H.Value)> where A : SalemoveSDK.PropertyProtocol, B : SalemoveSDK.PropertyProtocol, C : SalemoveSDK.PropertyProtocol, D : SalemoveSDK.PropertyProtocol, E : SalemoveSDK.PropertyProtocol, F : SalemoveSDK.PropertyProtocol, G : SalemoveSDK.PropertyProtocol, H : SalemoveSDK.PropertyProtocol, Self.Value == A.Value
  public static func zip<A, B, C, D, E, F, G, H, I>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F, _ g: G, _ h: H, _ i: I) -> SalemoveSDK.Property<(Self.Value, B.Value, C.Value, D.Value, E.Value, F.Value, G.Value, H.Value, I.Value)> where A : SalemoveSDK.PropertyProtocol, B : SalemoveSDK.PropertyProtocol, C : SalemoveSDK.PropertyProtocol, D : SalemoveSDK.PropertyProtocol, E : SalemoveSDK.PropertyProtocol, F : SalemoveSDK.PropertyProtocol, G : SalemoveSDK.PropertyProtocol, H : SalemoveSDK.PropertyProtocol, I : SalemoveSDK.PropertyProtocol, Self.Value == A.Value
  public static func zip<A, B, C, D, E, F, G, H, I, J>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F, _ g: G, _ h: H, _ i: I, _ j: J) -> SalemoveSDK.Property<(Self.Value, B.Value, C.Value, D.Value, E.Value, F.Value, G.Value, H.Value, I.Value, J.Value)> where A : SalemoveSDK.PropertyProtocol, B : SalemoveSDK.PropertyProtocol, C : SalemoveSDK.PropertyProtocol, D : SalemoveSDK.PropertyProtocol, E : SalemoveSDK.PropertyProtocol, F : SalemoveSDK.PropertyProtocol, G : SalemoveSDK.PropertyProtocol, H : SalemoveSDK.PropertyProtocol, I : SalemoveSDK.PropertyProtocol, J : SalemoveSDK.PropertyProtocol, Self.Value == A.Value
  public static func zip<S>(_ properties: S) -> SalemoveSDK.Property<[S.Iterator.Element.Value]>? where S : Swift.Sequence, S.Element : SalemoveSDK.PropertyProtocol
  public static func zip<S>(_ properties: S, emptySentinel: [S.Iterator.Element.Value]) -> SalemoveSDK.Property<[S.Iterator.Element.Value]> where S : Swift.Sequence, S.Element : SalemoveSDK.PropertyProtocol
}
extension PropertyProtocol where Self.Value == Swift.Bool {
  public func negate() -> SalemoveSDK.Property<Self.Value>
  public func and<P>(_ property: P) -> SalemoveSDK.Property<Self.Value> where P : SalemoveSDK.PropertyProtocol, P.Value == Swift.Bool
  public static func all<P, Properties>(_ properties: Properties) -> SalemoveSDK.Property<Self.Value> where P : SalemoveSDK.PropertyProtocol, P == Properties.Element, Properties : Swift.Collection, P.Value == Swift.Bool
  public static func all<P>(_ properties: P...) -> SalemoveSDK.Property<Self.Value> where P : SalemoveSDK.PropertyProtocol, P.Value == Swift.Bool
  public func or<P>(_ property: P) -> SalemoveSDK.Property<Self.Value> where P : SalemoveSDK.PropertyProtocol, P.Value == Swift.Bool
  public static func any<P, Properties>(_ properties: Properties) -> SalemoveSDK.Property<Self.Value> where P : SalemoveSDK.PropertyProtocol, P == Properties.Element, Properties : Swift.Collection, P.Value == Swift.Bool
  public static func any<P>(_ properties: P...) -> SalemoveSDK.Property<Self.Value> where P : SalemoveSDK.PropertyProtocol, P.Value == Swift.Bool
}
@_hasMissingDesignatedInitializers @propertyWrapper final public class Property<Value> : SalemoveSDK.PropertyProtocol {
  final public var value: Value {
    get
  }
  @inlinable final public var wrappedValue: Value {
    get {
		return value
	}
  }
  @inlinable final public var projectedValue: SalemoveSDK.Property<Value> {
    get {
		return self
	}
  }
  final public let producer: SalemoveSDK.SignalProducer<Value, Swift.Never>
  final public let signal: SalemoveSDK.Signal<Value, Swift.Never>
  public init(value: Value)
  public init<P>(capturing property: P) where Value == P.Value, P : SalemoveSDK.PropertyProtocol
  convenience public init<P>(_ property: P) where Value == P.Value, P : SalemoveSDK.PropertyProtocol
  convenience public init(initial: Value, then values: SalemoveSDK.SignalProducer<Value, Swift.Never>)
  convenience public init<Values>(initial: Value, then values: Values) where Value == Values.Value, Values : SalemoveSDK.SignalProducerConvertible, Values.Error == Swift.Never
  public typealias Error = Swift.Never
  @objc deinit
}
extension Property where Value : SalemoveSDK.OptionalProtocol {
  convenience public init(initial: Value, then values: SalemoveSDK.SignalProducer<Value.Wrapped, Swift.Never>)
  convenience public init<Values>(initial: Value, then values: Values) where Values : SalemoveSDK.SignalProducerConvertible, Value.Wrapped == Values.Value, Values.Error == Swift.Never
}
@propertyWrapper final public class MutableProperty<Value> : SalemoveSDK.ComposableMutablePropertyProtocol {
  final public var value: Value {
    get
    set
  }
  @inlinable final public var wrappedValue: Value {
    get { value }
    set { value = newValue }
  }
  @inlinable final public var projectedValue: SalemoveSDK.MutableProperty<Value> {
    get {
		return self
	}
  }
  final public let lifetime: SalemoveSDK.Lifetime
  final public let signal: SalemoveSDK.Signal<Value, Swift.Never>
  final public var producer: SalemoveSDK.SignalProducer<Value, Swift.Never> {
    get
  }
  public init(_ initialValue: Value)
  convenience public init(wrappedValue: Value)
  @discardableResult
  final public func swap(_ newValue: Value) -> Value
  @discardableResult
  final public func modify<Result>(_ action: (inout Value) throws -> Result) rethrows -> Result
  @discardableResult
  final public func withValue<Result>(_ action: (Value) throws -> Result) rethrows -> Result
  @objc deinit
  public typealias Error = Swift.Never
}
final public class ValidatingProperty<Value, ValidationError> : SalemoveSDK.MutablePropertyProtocol where ValidationError : Swift.Error {
  final public let result: SalemoveSDK.Property<SalemoveSDK.ValidatingProperty<Value, ValidationError>.Result>
  final public var value: Value {
    get
    set
  }
  final public let producer: SalemoveSDK.SignalProducer<Value, Swift.Never>
  final public let signal: SalemoveSDK.Signal<Value, Swift.Never>
  final public let lifetime: SalemoveSDK.Lifetime
  public init<Inner>(_ inner: Inner, _ validator: @escaping (Value) -> SalemoveSDK.ValidatingProperty<Value, ValidationError>.Decision) where Value == Inner.Value, Inner : SalemoveSDK.ComposableMutablePropertyProtocol
  convenience public init(_ initial: Value, _ validator: @escaping (Value) -> SalemoveSDK.ValidatingProperty<Value, ValidationError>.Decision)
  convenience public init<Other>(_ inner: SalemoveSDK.MutableProperty<Value>, with other: Other, _ validator: @escaping (Value, Other.Value) -> SalemoveSDK.ValidatingProperty<Value, ValidationError>.Decision) where Other : SalemoveSDK.PropertyProtocol
  convenience public init<Other>(_ initial: Value, with other: Other, _ validator: @escaping (Value, Other.Value) -> SalemoveSDK.ValidatingProperty<Value, ValidationError>.Decision) where Other : SalemoveSDK.PropertyProtocol
  convenience public init<U, E>(_ initial: Value, with other: SalemoveSDK.ValidatingProperty<U, E>, _ validator: @escaping (Value, U) -> SalemoveSDK.ValidatingProperty<Value, ValidationError>.Decision) where E : Swift.Error
  convenience public init<U, E>(_ inner: SalemoveSDK.MutableProperty<Value>, with other: SalemoveSDK.ValidatingProperty<U, E>, _ validator: @escaping (Value, U) -> SalemoveSDK.ValidatingProperty<Value, ValidationError>.Decision) where E : Swift.Error
  public enum Decision {
    case valid
    case coerced(Value, ValidationError?)
    case invalid(ValidationError)
  }
  public enum Result {
    case valid(Value)
    case coerced(replacement: Value, proposed: Value, error: ValidationError?)
    case invalid(Value, ValidationError)
    public var isInvalid: Swift.Bool {
      get
    }
    public var value: Value? {
      get
    }
    public var error: ValidationError? {
      get
    }
  }
  public typealias Error = Swift.Never
  @objc deinit
}
open class ColorMatrixEffect : SalemoveSDK.Effect {
  final public let matrix: SalemoveSDK.ColorMatrix
  public init(matrix: SalemoveSDK.ColorMatrix, input: SalemoveSDK.Effect? = nil)
  override public init(input: SalemoveSDK.Effect?)
  @objc deinit
}
@objc public class EngagementFileInformation : ObjectiveC.NSObject, Swift.Codable {
  final public let id: Swift.String
  final public let isSecurityScanningRequired: Swift.Bool
  final public let url: Swift.String?
  @objc deinit
  public func encode(to encoder: Swift.Encoder) throws
  required public init(from decoder: Swift.Decoder) throws
}
public enum EndpointSampleResponse {
  case networkResponse(Swift.Int, Foundation.Data)
  case response(Foundation.HTTPURLResponse, Foundation.Data)
  case networkError(Foundation.NSError)
}
open class Endpoint {
  public typealias SampleResponseClosure = () -> SalemoveSDK.EndpointSampleResponse
  final public let url: Swift.String
  final public let sampleResponseClosure: SalemoveSDK.Endpoint.SampleResponseClosure
  final public let method: SalemoveSDK.MoyaMethod
  final public let task: SalemoveSDK.Task
  final public let httpHeaderFields: [Swift.String : Swift.String]?
  public init(url: Swift.String, sampleResponseClosure: @escaping SalemoveSDK.Endpoint.SampleResponseClosure, method: SalemoveSDK.MoyaMethod, task: SalemoveSDK.Task, httpHeaderFields: [Swift.String : Swift.String]?)
  open func adding(newHTTPHeaderFields: [Swift.String : Swift.String]) -> SalemoveSDK.Endpoint
  open func replacing(task: SalemoveSDK.Task) -> SalemoveSDK.Endpoint
  @objc deinit
}
extension Endpoint {
  public func urlRequest() throws -> Foundation.URLRequest
}
extension Endpoint : Swift.Equatable, Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (lhs: SalemoveSDK.Endpoint, rhs: SalemoveSDK.Endpoint) -> Swift.Bool
  open var hashValue: Swift.Int {
    get
  }
}
@objc open class Drawable : ObjectiveC.NSObject {
  final public let visible: Swift.Bool
  final public let tag: [Swift.String]
  public init(visible: Swift.Bool = true, tag: [Swift.String] = [])
  @objc override dynamic public init()
  @objc deinit
}
public struct FlattenStrategy {
  public static let merge: SalemoveSDK.FlattenStrategy
  public static let concat: SalemoveSDK.FlattenStrategy
  public static func concurrent(limit: Swift.UInt) -> SalemoveSDK.FlattenStrategy
  public static let latest: SalemoveSDK.FlattenStrategy
  public static let race: SalemoveSDK.FlattenStrategy
  public static let throttle: SalemoveSDK.FlattenStrategy
}
extension Signal where Value : SalemoveSDK.SignalProducerConvertible, Error == Value.Error {
  final public func flatten(_ strategy: SalemoveSDK.FlattenStrategy) -> SalemoveSDK.Signal<Value.Value, Error>
}
extension Signal where Value : SalemoveSDK.SignalProducerConvertible, Error == Swift.Never {
  final public func flatten(_ strategy: SalemoveSDK.FlattenStrategy) -> SalemoveSDK.Signal<Value.Value, Value.Error>
}
extension Signal where Value : SalemoveSDK.SignalProducerConvertible, Error == Swift.Never, Value.Error == Swift.Never {
  final public func flatten(_ strategy: SalemoveSDK.FlattenStrategy) -> SalemoveSDK.Signal<Value.Value, Value.Error>
}
extension Signal where Value : SalemoveSDK.SignalProducerConvertible, Value.Error == Swift.Never {
  final public func flatten(_ strategy: SalemoveSDK.FlattenStrategy) -> SalemoveSDK.Signal<Value.Value, Error>
}
extension SignalProducer where Value : SalemoveSDK.SignalProducerConvertible, Error == Value.Error {
  public func flatten(_ strategy: SalemoveSDK.FlattenStrategy) -> SalemoveSDK.SignalProducer<Value.Value, Error>
}
extension SignalProducer where Value : SalemoveSDK.SignalProducerConvertible, Error == Swift.Never {
  public func flatten(_ strategy: SalemoveSDK.FlattenStrategy) -> SalemoveSDK.SignalProducer<Value.Value, Value.Error>
}
extension SignalProducer where Value : SalemoveSDK.SignalProducerConvertible, Error == Swift.Never, Value.Error == Swift.Never {
  public func flatten(_ strategy: SalemoveSDK.FlattenStrategy) -> SalemoveSDK.SignalProducer<Value.Value, Value.Error>
}
extension SignalProducer where Value : SalemoveSDK.SignalProducerConvertible, Value.Error == Swift.Never {
  public func flatten(_ strategy: SalemoveSDK.FlattenStrategy) -> SalemoveSDK.SignalProducer<Value.Value, Error>
}
extension Signal where Value : Swift.Sequence {
  final public func flatten() -> SalemoveSDK.Signal<Value.Iterator.Element, Error>
}
extension SignalProducer where Value : Swift.Sequence {
  public func flatten() -> SalemoveSDK.SignalProducer<Value.Iterator.Element, Error>
}
extension SignalProducer {
  public func concat(_ next: SalemoveSDK.SignalProducer<Value, Error>) -> SalemoveSDK.SignalProducer<Value, Error>
  public func concat<Next>(_ next: Next) -> SalemoveSDK.SignalProducer<Value, Error> where Value == Next.Value, Error == Next.Error, Next : SalemoveSDK.SignalProducerConvertible
  public func concat(value: Value) -> SalemoveSDK.SignalProducer<Value, Error>
  public func concat(error: Error) -> SalemoveSDK.SignalProducer<Value, Error>
  public func prefix(_ previous: SalemoveSDK.SignalProducer<Value, Error>) -> SalemoveSDK.SignalProducer<Value, Error>
  public func prefix<Previous>(_ previous: Previous) -> SalemoveSDK.SignalProducer<Value, Error> where Value == Previous.Value, Error == Previous.Error, Previous : SalemoveSDK.SignalProducerConvertible
  public func prefix(value: Value) -> SalemoveSDK.SignalProducer<Value, Error>
}
extension Signal {
  public static func merge<Seq>(_ signals: Seq) -> SalemoveSDK.Signal<Value, Error> where Seq : Swift.Sequence, Seq.Element == SalemoveSDK.Signal<Value, Error>
  public static func merge(_ signals: SalemoveSDK.Signal<Value, Error>...) -> SalemoveSDK.Signal<Value, Error>
}
extension SignalProducer {
  public static func merge<Seq>(_ producers: Seq) -> SalemoveSDK.SignalProducer<Value, Error> where Seq : Swift.Sequence, Seq.Element == SalemoveSDK.SignalProducer<Value, Error>
  public static func merge<A, B>(_ a: A, _ b: B) -> SalemoveSDK.SignalProducer<Value, Error> where Value == A.Value, Error == A.Error, A : SalemoveSDK.SignalProducerConvertible, B : SalemoveSDK.SignalProducerConvertible, A.Error == B.Error, A.Value == B.Value
  public static func merge<A, B, C>(_ a: A, _ b: B, _ c: C) -> SalemoveSDK.SignalProducer<Value, Error> where Value == A.Value, Error == A.Error, A : SalemoveSDK.SignalProducerConvertible, B : SalemoveSDK.SignalProducerConvertible, C : SalemoveSDK.SignalProducerConvertible, A.Error == B.Error, A.Value == B.Value, B.Error == C.Error, B.Value == C.Value
  public static func merge<A, B, C, D>(_ a: A, _ b: B, _ c: C, _ d: D) -> SalemoveSDK.SignalProducer<Value, Error> where Value == A.Value, Error == A.Error, A : SalemoveSDK.SignalProducerConvertible, B : SalemoveSDK.SignalProducerConvertible, C : SalemoveSDK.SignalProducerConvertible, D : SalemoveSDK.SignalProducerConvertible, A.Error == B.Error, A.Value == B.Value, B.Error == C.Error, B.Value == C.Value, C.Error == D.Error, C.Value == D.Value
  public static func merge<A, B, C, D, E>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E) -> SalemoveSDK.SignalProducer<Value, Error> where Value == A.Value, Error == A.Error, A : SalemoveSDK.SignalProducerConvertible, B : SalemoveSDK.SignalProducerConvertible, C : SalemoveSDK.SignalProducerConvertible, D : SalemoveSDK.SignalProducerConvertible, E : SalemoveSDK.SignalProducerConvertible, A.Error == B.Error, A.Value == B.Value, B.Error == C.Error, B.Value == C.Value, C.Error == D.Error, C.Value == D.Value, D.Error == E.Error, D.Value == E.Value
  public static func merge<A, B, C, D, E, F>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F) -> SalemoveSDK.SignalProducer<Value, Error> where Value == A.Value, Error == A.Error, A : SalemoveSDK.SignalProducerConvertible, B : SalemoveSDK.SignalProducerConvertible, C : SalemoveSDK.SignalProducerConvertible, D : SalemoveSDK.SignalProducerConvertible, E : SalemoveSDK.SignalProducerConvertible, F : SalemoveSDK.SignalProducerConvertible, A.Error == B.Error, A.Value == B.Value, B.Error == C.Error, B.Value == C.Value, C.Error == D.Error, C.Value == D.Value, D.Error == E.Error, D.Value == E.Value, E.Error == F.Error, E.Value == F.Value
  public static func merge<A, B, C, D, E, F, G>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F, _ g: G) -> SalemoveSDK.SignalProducer<Value, Error> where Value == A.Value, Error == A.Error, A : SalemoveSDK.SignalProducerConvertible, B : SalemoveSDK.SignalProducerConvertible, C : SalemoveSDK.SignalProducerConvertible, D : SalemoveSDK.SignalProducerConvertible, E : SalemoveSDK.SignalProducerConvertible, F : SalemoveSDK.SignalProducerConvertible, G : SalemoveSDK.SignalProducerConvertible, A.Error == B.Error, A.Value == B.Value, B.Error == C.Error, B.Value == C.Value, C.Error == D.Error, C.Value == D.Value, D.Error == E.Error, D.Value == E.Value, E.Error == F.Error, E.Value == F.Value, F.Error == G.Error, F.Value == G.Value
  public static func merge<A, B, C, D, E, F, G, H>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F, _ g: G, _ h: H) -> SalemoveSDK.SignalProducer<Value, Error> where Value == A.Value, Error == A.Error, A : SalemoveSDK.SignalProducerConvertible, B : SalemoveSDK.SignalProducerConvertible, C : SalemoveSDK.SignalProducerConvertible, D : SalemoveSDK.SignalProducerConvertible, E : SalemoveSDK.SignalProducerConvertible, F : SalemoveSDK.SignalProducerConvertible, G : SalemoveSDK.SignalProducerConvertible, H : SalemoveSDK.SignalProducerConvertible, A.Error == B.Error, A.Value == B.Value, B.Error == C.Error, B.Value == C.Value, C.Error == D.Error, C.Value == D.Value, D.Error == E.Error, D.Value == E.Value, E.Error == F.Error, E.Value == F.Value, F.Error == G.Error, F.Value == G.Value, G.Error == H.Error, G.Value == H.Value
  public static func merge<A, B, C, D, E, F, G, H, I>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F, _ g: G, _ h: H, _ i: I) -> SalemoveSDK.SignalProducer<Value, Error> where Value == A.Value, Error == A.Error, A : SalemoveSDK.SignalProducerConvertible, B : SalemoveSDK.SignalProducerConvertible, C : SalemoveSDK.SignalProducerConvertible, D : SalemoveSDK.SignalProducerConvertible, E : SalemoveSDK.SignalProducerConvertible, F : SalemoveSDK.SignalProducerConvertible, G : SalemoveSDK.SignalProducerConvertible, H : SalemoveSDK.SignalProducerConvertible, I : SalemoveSDK.SignalProducerConvertible, A.Error == B.Error, A.Value == B.Value, B.Error == C.Error, B.Value == C.Value, C.Error == D.Error, C.Value == D.Value, D.Error == E.Error, D.Value == E.Value, E.Error == F.Error, E.Value == F.Value, F.Error == G.Error, F.Value == G.Value, G.Error == H.Error, G.Value == H.Value, H.Error == I.Error, H.Value == I.Value
  public static func merge<A, B, C, D, E, F, G, H, I, J>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F, _ g: G, _ h: H, _ i: I, _ j: J) -> SalemoveSDK.SignalProducer<Value, Error> where Value == A.Value, Error == A.Error, A : SalemoveSDK.SignalProducerConvertible, B : SalemoveSDK.SignalProducerConvertible, C : SalemoveSDK.SignalProducerConvertible, D : SalemoveSDK.SignalProducerConvertible, E : SalemoveSDK.SignalProducerConvertible, F : SalemoveSDK.SignalProducerConvertible, G : SalemoveSDK.SignalProducerConvertible, H : SalemoveSDK.SignalProducerConvertible, I : SalemoveSDK.SignalProducerConvertible, J : SalemoveSDK.SignalProducerConvertible, A.Error == B.Error, A.Value == B.Value, B.Error == C.Error, B.Value == C.Value, C.Error == D.Error, C.Value == D.Value, D.Error == E.Error, D.Value == E.Value, E.Error == F.Error, E.Value == F.Value, F.Error == G.Error, F.Value == G.Value, G.Error == H.Error, G.Value == H.Value, H.Error == I.Error, H.Value == I.Value, I.Error == J.Error, I.Value == J.Value
}
extension Signal {
  final public func flatMap<U>(_ strategy: SalemoveSDK.FlattenStrategy, _ transform: @escaping (Value) -> SalemoveSDK.SignalProducer<U, Error>) -> SalemoveSDK.Signal<U, Error>
  final public func flatMap<Inner>(_ strategy: SalemoveSDK.FlattenStrategy, _ transform: @escaping (Value) -> Inner) -> SalemoveSDK.Signal<Inner.Value, Error> where Error == Inner.Error, Inner : SalemoveSDK.SignalProducerConvertible
  final public func flatMap<U>(_ strategy: SalemoveSDK.FlattenStrategy, _ transform: @escaping (Value) -> SalemoveSDK.SignalProducer<U, Swift.Never>) -> SalemoveSDK.Signal<U, Error>
  final public func flatMap<Inner>(_ strategy: SalemoveSDK.FlattenStrategy, _ transform: @escaping (Value) -> Inner) -> SalemoveSDK.Signal<Inner.Value, Error> where Inner : SalemoveSDK.SignalProducerConvertible, Inner.Error == Swift.Never
}
extension Signal where Error == Swift.Never {
  final public func flatMap<U, F>(_ strategy: SalemoveSDK.FlattenStrategy, _ transform: @escaping (Value) -> SalemoveSDK.SignalProducer<U, F>) -> SalemoveSDK.Signal<U, F> where F : Swift.Error
  final public func flatMap<Inner>(_ strategy: SalemoveSDK.FlattenStrategy, _ transform: @escaping (Value) -> Inner) -> SalemoveSDK.Signal<Inner.Value, Inner.Error> where Inner : SalemoveSDK.SignalProducerConvertible
  final public func flatMap<U>(_ strategy: SalemoveSDK.FlattenStrategy, _ transform: @escaping (Value) -> SalemoveSDK.SignalProducer<U, Swift.Never>) -> SalemoveSDK.Signal<U, Swift.Never>
  final public func flatMap<Inner>(_ strategy: SalemoveSDK.FlattenStrategy, _ transform: @escaping (Value) -> Inner) -> SalemoveSDK.Signal<Inner.Value, Swift.Never> where Inner : SalemoveSDK.SignalProducerConvertible, Inner.Error == Swift.Never
}
extension SignalProducer {
  public func flatMap<U>(_ strategy: SalemoveSDK.FlattenStrategy, _ transform: @escaping (Value) -> SalemoveSDK.SignalProducer<U, Error>) -> SalemoveSDK.SignalProducer<U, Error>
  public func flatMap<Inner>(_ strategy: SalemoveSDK.FlattenStrategy, _ transform: @escaping (Value) -> Inner) -> SalemoveSDK.SignalProducer<Inner.Value, Error> where Error == Inner.Error, Inner : SalemoveSDK.SignalProducerConvertible
  public func flatMap<U>(_ strategy: SalemoveSDK.FlattenStrategy, _ transform: @escaping (Value) -> SalemoveSDK.SignalProducer<U, Swift.Never>) -> SalemoveSDK.SignalProducer<U, Error>
  public func flatMap<Inner>(_ strategy: SalemoveSDK.FlattenStrategy, _ transform: @escaping (Value) -> Inner) -> SalemoveSDK.SignalProducer<Inner.Value, Error> where Inner : SalemoveSDK.SignalProducerConvertible, Inner.Error == Swift.Never
}
extension SignalProducer where Error == Swift.Never {
  public func flatMap<U>(_ strategy: SalemoveSDK.FlattenStrategy, _ transform: @escaping (Value) -> SalemoveSDK.SignalProducer<U, Error>) -> SalemoveSDK.SignalProducer<U, Error>
  public func flatMap<Inner>(_ strategy: SalemoveSDK.FlattenStrategy, _ transform: @escaping (Value) -> Inner) -> SalemoveSDK.SignalProducer<Inner.Value, Error> where Inner : SalemoveSDK.SignalProducerConvertible, Inner.Error == Swift.Never
  public func flatMap<U, F>(_ strategy: SalemoveSDK.FlattenStrategy, _ transform: @escaping (Value) -> SalemoveSDK.SignalProducer<U, F>) -> SalemoveSDK.SignalProducer<U, F> where F : Swift.Error
  public func flatMap<Inner>(_ strategy: SalemoveSDK.FlattenStrategy, _ transform: @escaping (Value) -> Inner) -> SalemoveSDK.SignalProducer<Inner.Value, Inner.Error> where Inner : SalemoveSDK.SignalProducerConvertible
}
extension Signal {
  final public func flatMapError<F>(_ transform: @escaping (Error) -> SalemoveSDK.SignalProducer<Value, F>) -> SalemoveSDK.Signal<Value, F> where F : Swift.Error
  final public func flatMapError<Inner>(_ transform: @escaping (Error) -> Inner) -> SalemoveSDK.Signal<Value, Inner.Error> where Value == Inner.Value, Inner : SalemoveSDK.SignalProducerConvertible
}
extension SignalProducer {
  public func flatMapError<F>(_ transform: @escaping (Error) -> SalemoveSDK.SignalProducer<Value, F>) -> SalemoveSDK.SignalProducer<Value, F> where F : Swift.Error
  public func flatMapError<Inner>(_ transform: @escaping (Error) -> Inner) -> SalemoveSDK.SignalProducer<Value, Inner.Error> where Value == Inner.Value, Inner : SalemoveSDK.SignalProducerConvertible
}
@objc @_inheritsConvenienceInitializers open class MView : UIKit.UIView {
  @objc override dynamic open func touchesBegan(_ touches: Swift.Set<SalemoveSDK.MTouch>, with event: SalemoveSDK.MEvent?)
  @objc override dynamic open func touchesMoved(_ touches: Swift.Set<SalemoveSDK.MTouch>, with event: SalemoveSDK.MEvent?)
  @objc override dynamic open func touchesEnded(_ touches: Swift.Set<SalemoveSDK.MTouch>, with event: SalemoveSDK.MEvent?)
  @objc override dynamic open func touchesCancelled(_ touches: Swift.Set<SalemoveSDK.MTouch>, with event: SalemoveSDK.MEvent?)
  @objc override dynamic public init(frame: CoreGraphics.CGRect)
  @objc required dynamic public init?(coder: Foundation.NSCoder)
  @objc deinit
}
open class ColorMatrix {
  public static let identity: SalemoveSDK.ColorMatrix
  public static let luminanceToAlpha: SalemoveSDK.ColorMatrix
  final public let values: [Swift.Double]
  public init(values: [Swift.Double])
  convenience public init(color: SalemoveSDK.Color)
  convenience public init(saturate: Swift.Double)
  convenience public init(hueRotate: Swift.Double)
  @objc deinit
}
public enum FillRule {
  case nonzero, evenodd
  public static func == (a: SalemoveSDK.FillRule, b: SalemoveSDK.FillRule) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
open class Path : SalemoveSDK.Locus {
  final public let segments: [SalemoveSDK.PathSegment]
  final public let fillRule: SalemoveSDK.FillRule
  public init(segments: [SalemoveSDK.PathSegment] = [], fillRule: SalemoveSDK.FillRule = .nonzero)
  override open func bounds() -> SalemoveSDK.Rect
  override open func toPath() -> SalemoveSDK.Path
  override public init()
  @objc deinit
}
public protocol FillInterpolation : SalemoveSDK.Interpolable {
}
extension Fill : SalemoveSDK.FillInterpolation {
  public func interpolate(_ endValue: SalemoveSDK.Fill, progress: Swift.Double) -> Self
}
@_hasMissingDesignatedInitializers open class NetworkReachabilityManager {
  public enum NetworkReachabilityStatus {
    case unknown
    case notReachable
    case reachable(SalemoveSDK.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType)
    public enum ConnectionType {
      case ethernetOrWiFi
      case cellular
      public static func == (a: SalemoveSDK.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType, b: SalemoveSDK.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType) -> Swift.Bool
      public func hash(into hasher: inout Swift.Hasher)
      public var hashValue: Swift.Int {
        get
      }
    }
  }
  public typealias Listener = (SalemoveSDK.NetworkReachabilityManager.NetworkReachabilityStatus) -> Swift.Void
  public static let `default`: SalemoveSDK.NetworkReachabilityManager?
  open var isReachable: Swift.Bool {
    get
  }
  open var isReachableOnCellular: Swift.Bool {
    get
  }
  open var isReachableOnEthernetOrWiFi: Swift.Bool {
    get
  }
  final public let reachabilityQueue: Dispatch.DispatchQueue
  open var flags: SystemConfiguration.SCNetworkReachabilityFlags? {
    get
  }
  open var status: SalemoveSDK.NetworkReachabilityManager.NetworkReachabilityStatus {
    get
  }
  convenience public init?(host: Swift.String)
  convenience public init?()
  @objc deinit
  @discardableResult
  open func startListening(onQueue queue: Dispatch.DispatchQueue = .main, onUpdatePerforming listener: @escaping SalemoveSDK.NetworkReachabilityManager.Listener) -> Swift.Bool
  open func stopListening()
}
extension NetworkReachabilityManager.NetworkReachabilityStatus : Swift.Equatable {
  public static func == (a: SalemoveSDK.NetworkReachabilityManager.NetworkReachabilityStatus, b: SalemoveSDK.NetworkReachabilityManager.NetworkReachabilityStatus) -> Swift.Bool
}
@_hasMissingDesignatedInitializers @objc public class OperatorTypingStatus : ObjectiveC.NSObject {
  @objc public var isTyping: Swift.Bool {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
public protocol StrokeInterpolation : SalemoveSDK.Interpolable {
}
extension Stroke : SalemoveSDK.StrokeInterpolation {
  public func interpolate(_ endValue: SalemoveSDK.Stroke, progress: Swift.Double) -> Self
}
public protocol EventMonitor {
  var queue: Dispatch.DispatchQueue { get }
  func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: Swift.Error?)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  func urlSession(_ session: Foundation.URLSession, taskNeedsNewBodyStream task: Foundation.URLSessionTask)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
  func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse)
  func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  func request(_ request: SalemoveSDK.AlamofireRequest, didCreateInitialURLRequest urlRequest: Foundation.URLRequest)
  func request(_ request: SalemoveSDK.AlamofireRequest, didFailToCreateURLRequestWithError error: SalemoveSDK.AFError)
  func request(_ request: SalemoveSDK.AlamofireRequest, didAdaptInitialRequest initialRequest: Foundation.URLRequest, to adaptedRequest: Foundation.URLRequest)
  func request(_ request: SalemoveSDK.AlamofireRequest, didFailToAdaptURLRequest initialRequest: Foundation.URLRequest, withError error: SalemoveSDK.AFError)
  func request(_ request: SalemoveSDK.AlamofireRequest, didCreateURLRequest urlRequest: Foundation.URLRequest)
  func request(_ request: SalemoveSDK.AlamofireRequest, didCreateTask task: Foundation.URLSessionTask)
  func request(_ request: SalemoveSDK.AlamofireRequest, didGatherMetrics metrics: Foundation.URLSessionTaskMetrics)
  func request(_ request: SalemoveSDK.AlamofireRequest, didFailTask task: Foundation.URLSessionTask, earlyWithError error: SalemoveSDK.AFError)
  func request(_ request: SalemoveSDK.AlamofireRequest, didCompleteTask task: Foundation.URLSessionTask, with error: SalemoveSDK.AFError?)
  func requestIsRetrying(_ request: SalemoveSDK.AlamofireRequest)
  func requestDidFinish(_ request: SalemoveSDK.AlamofireRequest)
  func requestDidResume(_ request: SalemoveSDK.AlamofireRequest)
  func request(_ request: SalemoveSDK.AlamofireRequest, didResumeTask task: Foundation.URLSessionTask)
  func requestDidSuspend(_ request: SalemoveSDK.AlamofireRequest)
  func request(_ request: SalemoveSDK.AlamofireRequest, didSuspendTask task: Foundation.URLSessionTask)
  func requestDidCancel(_ request: SalemoveSDK.AlamofireRequest)
  func request(_ request: SalemoveSDK.AlamofireRequest, didCancelTask task: Foundation.URLSessionTask)
  func request(_ request: SalemoveSDK.AlamofireDataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, withResult result: SalemoveSDK.AlamofireRequest.ValidationResult)
  func request(_ request: SalemoveSDK.AlamofireDataRequest, didParseResponse response: SalemoveSDK.DataResponse<Foundation.Data?, SalemoveSDK.AFError>)
  func request<Value>(_ request: SalemoveSDK.AlamofireDataRequest, didParseResponse response: SalemoveSDK.DataResponse<Value, SalemoveSDK.AFError>)
  func request(_ request: SalemoveSDK.DataStreamRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, withResult result: SalemoveSDK.AlamofireRequest.ValidationResult)
  func request<Value>(_ request: SalemoveSDK.DataStreamRequest, didParseStream result: Swift.Result<Value, SalemoveSDK.AFError>)
  func request(_ request: SalemoveSDK.AlamofireUploadRequest, didCreateUploadable uploadable: SalemoveSDK.AlamofireUploadRequest.Uploadable)
  func request(_ request: SalemoveSDK.AlamofireUploadRequest, didFailToCreateUploadableWithError error: SalemoveSDK.AFError)
  func request(_ request: SalemoveSDK.AlamofireUploadRequest, didProvideInputStream stream: Foundation.InputStream)
  func request(_ request: SalemoveSDK.AlamofireDownloadRequest, didFinishDownloadingUsing task: Foundation.URLSessionTask, with result: Swift.Result<Foundation.URL, SalemoveSDK.AFError>)
  func request(_ request: SalemoveSDK.AlamofireDownloadRequest, didCreateDestinationURL url: Foundation.URL)
  func request(_ request: SalemoveSDK.AlamofireDownloadRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, fileURL: Foundation.URL?, withResult result: SalemoveSDK.AlamofireRequest.ValidationResult)
  func request(_ request: SalemoveSDK.AlamofireDownloadRequest, didParseResponse response: SalemoveSDK.DownloadResponse<Foundation.URL?, SalemoveSDK.AFError>)
  func request<Value>(_ request: SalemoveSDK.AlamofireDownloadRequest, didParseResponse response: SalemoveSDK.DownloadResponse<Value, SalemoveSDK.AFError>)
}
extension EventMonitor {
  public var queue: Dispatch.DispatchQueue {
    get
  }
  public func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: Swift.Error?)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  public func urlSession(_ session: Foundation.URLSession, taskNeedsNewBodyStream task: Foundation.URLSessionTask)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
  public func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
  public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse)
  public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  public func request(_ request: SalemoveSDK.AlamofireRequest, didCreateInitialURLRequest urlRequest: Foundation.URLRequest)
  public func request(_ request: SalemoveSDK.AlamofireRequest, didFailToCreateURLRequestWithError error: SalemoveSDK.AFError)
  public func request(_ request: SalemoveSDK.AlamofireRequest, didAdaptInitialRequest initialRequest: Foundation.URLRequest, to adaptedRequest: Foundation.URLRequest)
  public func request(_ request: SalemoveSDK.AlamofireRequest, didFailToAdaptURLRequest initialRequest: Foundation.URLRequest, withError error: SalemoveSDK.AFError)
  public func request(_ request: SalemoveSDK.AlamofireRequest, didCreateURLRequest urlRequest: Foundation.URLRequest)
  public func request(_ request: SalemoveSDK.AlamofireRequest, didCreateTask task: Foundation.URLSessionTask)
  public func request(_ request: SalemoveSDK.AlamofireRequest, didGatherMetrics metrics: Foundation.URLSessionTaskMetrics)
  public func request(_ request: SalemoveSDK.AlamofireRequest, didFailTask task: Foundation.URLSessionTask, earlyWithError error: SalemoveSDK.AFError)
  public func request(_ request: SalemoveSDK.AlamofireRequest, didCompleteTask task: Foundation.URLSessionTask, with error: SalemoveSDK.AFError?)
  public func requestIsRetrying(_ request: SalemoveSDK.AlamofireRequest)
  public func requestDidFinish(_ request: SalemoveSDK.AlamofireRequest)
  public func requestDidResume(_ request: SalemoveSDK.AlamofireRequest)
  public func request(_ request: SalemoveSDK.AlamofireRequest, didResumeTask task: Foundation.URLSessionTask)
  public func requestDidSuspend(_ request: SalemoveSDK.AlamofireRequest)
  public func request(_ request: SalemoveSDK.AlamofireRequest, didSuspendTask task: Foundation.URLSessionTask)
  public func requestDidCancel(_ request: SalemoveSDK.AlamofireRequest)
  public func request(_ request: SalemoveSDK.AlamofireRequest, didCancelTask task: Foundation.URLSessionTask)
  public func request(_ request: SalemoveSDK.AlamofireDataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, withResult result: SalemoveSDK.AlamofireRequest.ValidationResult)
  public func request(_ request: SalemoveSDK.AlamofireDataRequest, didParseResponse response: SalemoveSDK.DataResponse<Foundation.Data?, SalemoveSDK.AFError>)
  public func request<Value>(_ request: SalemoveSDK.AlamofireDataRequest, didParseResponse response: SalemoveSDK.DataResponse<Value, SalemoveSDK.AFError>)
  public func request(_ request: SalemoveSDK.DataStreamRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, withResult result: SalemoveSDK.AlamofireRequest.ValidationResult)
  public func request<Value>(_ request: SalemoveSDK.DataStreamRequest, didParseStream result: Swift.Result<Value, SalemoveSDK.AFError>)
  public func request(_ request: SalemoveSDK.AlamofireUploadRequest, didCreateUploadable uploadable: SalemoveSDK.AlamofireUploadRequest.Uploadable)
  public func request(_ request: SalemoveSDK.AlamofireUploadRequest, didFailToCreateUploadableWithError error: SalemoveSDK.AFError)
  public func request(_ request: SalemoveSDK.AlamofireUploadRequest, didProvideInputStream stream: Foundation.InputStream)
  public func request(_ request: SalemoveSDK.AlamofireDownloadRequest, didFinishDownloadingUsing task: Foundation.URLSessionTask, with result: Swift.Result<Foundation.URL, SalemoveSDK.AFError>)
  public func request(_ request: SalemoveSDK.AlamofireDownloadRequest, didCreateDestinationURL url: Foundation.URL)
  public func request(_ request: SalemoveSDK.AlamofireDownloadRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, fileURL: Foundation.URL?, withResult result: SalemoveSDK.AlamofireRequest.ValidationResult)
  public func request(_ request: SalemoveSDK.AlamofireDownloadRequest, didParseResponse response: SalemoveSDK.DownloadResponse<Foundation.URL?, SalemoveSDK.AFError>)
  public func request<Value>(_ request: SalemoveSDK.AlamofireDownloadRequest, didParseResponse response: SalemoveSDK.DownloadResponse<Value, SalemoveSDK.AFError>)
}
@_hasMissingDesignatedInitializers final public class CompositeEventMonitor : SalemoveSDK.EventMonitor {
  final public let queue: Dispatch.DispatchQueue
  final public func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: Swift.Error?)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  final public func urlSession(_ session: Foundation.URLSession, taskNeedsNewBodyStream task: Foundation.URLSessionTask)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  final public func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
  @available(macOS 10.13, iOS 11.0, tvOS 11.0, watchOS 4.0, *)
  final public func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
  final public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  final public func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse)
  final public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  final public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  final public func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  final public func request(_ request: SalemoveSDK.AlamofireRequest, didCreateInitialURLRequest urlRequest: Foundation.URLRequest)
  final public func request(_ request: SalemoveSDK.AlamofireRequest, didFailToCreateURLRequestWithError error: SalemoveSDK.AFError)
  final public func request(_ request: SalemoveSDK.AlamofireRequest, didAdaptInitialRequest initialRequest: Foundation.URLRequest, to adaptedRequest: Foundation.URLRequest)
  final public func request(_ request: SalemoveSDK.AlamofireRequest, didFailToAdaptURLRequest initialRequest: Foundation.URLRequest, withError error: SalemoveSDK.AFError)
  final public func request(_ request: SalemoveSDK.AlamofireRequest, didCreateURLRequest urlRequest: Foundation.URLRequest)
  final public func request(_ request: SalemoveSDK.AlamofireRequest, didCreateTask task: Foundation.URLSessionTask)
  final public func request(_ request: SalemoveSDK.AlamofireRequest, didGatherMetrics metrics: Foundation.URLSessionTaskMetrics)
  final public func request(_ request: SalemoveSDK.AlamofireRequest, didFailTask task: Foundation.URLSessionTask, earlyWithError error: SalemoveSDK.AFError)
  final public func request(_ request: SalemoveSDK.AlamofireRequest, didCompleteTask task: Foundation.URLSessionTask, with error: SalemoveSDK.AFError?)
  final public func requestIsRetrying(_ request: SalemoveSDK.AlamofireRequest)
  final public func requestDidFinish(_ request: SalemoveSDK.AlamofireRequest)
  final public func requestDidResume(_ request: SalemoveSDK.AlamofireRequest)
  final public func request(_ request: SalemoveSDK.AlamofireRequest, didResumeTask task: Foundation.URLSessionTask)
  final public func requestDidSuspend(_ request: SalemoveSDK.AlamofireRequest)
  final public func request(_ request: SalemoveSDK.AlamofireRequest, didSuspendTask task: Foundation.URLSessionTask)
  final public func requestDidCancel(_ request: SalemoveSDK.AlamofireRequest)
  final public func request(_ request: SalemoveSDK.AlamofireRequest, didCancelTask task: Foundation.URLSessionTask)
  final public func request(_ request: SalemoveSDK.AlamofireDataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, withResult result: SalemoveSDK.AlamofireRequest.ValidationResult)
  final public func request(_ request: SalemoveSDK.AlamofireDataRequest, didParseResponse response: SalemoveSDK.DataResponse<Foundation.Data?, SalemoveSDK.AFError>)
  final public func request<Value>(_ request: SalemoveSDK.AlamofireDataRequest, didParseResponse response: SalemoveSDK.DataResponse<Value, SalemoveSDK.AFError>)
  final public func request(_ request: SalemoveSDK.DataStreamRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, withResult result: SalemoveSDK.AlamofireRequest.ValidationResult)
  final public func request<Value>(_ request: SalemoveSDK.DataStreamRequest, didParseStream result: Swift.Result<Value, SalemoveSDK.AFError>)
  final public func request(_ request: SalemoveSDK.AlamofireUploadRequest, didCreateUploadable uploadable: SalemoveSDK.AlamofireUploadRequest.Uploadable)
  final public func request(_ request: SalemoveSDK.AlamofireUploadRequest, didFailToCreateUploadableWithError error: SalemoveSDK.AFError)
  final public func request(_ request: SalemoveSDK.AlamofireUploadRequest, didProvideInputStream stream: Foundation.InputStream)
  final public func request(_ request: SalemoveSDK.AlamofireDownloadRequest, didFinishDownloadingUsing task: Foundation.URLSessionTask, with result: Swift.Result<Foundation.URL, SalemoveSDK.AFError>)
  final public func request(_ request: SalemoveSDK.AlamofireDownloadRequest, didCreateDestinationURL url: Foundation.URL)
  final public func request(_ request: SalemoveSDK.AlamofireDownloadRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, fileURL: Foundation.URL?, withResult result: SalemoveSDK.AlamofireRequest.ValidationResult)
  final public func request(_ request: SalemoveSDK.AlamofireDownloadRequest, didParseResponse response: SalemoveSDK.DownloadResponse<Foundation.URL?, SalemoveSDK.AFError>)
  final public func request<Value>(_ request: SalemoveSDK.AlamofireDownloadRequest, didParseResponse response: SalemoveSDK.DownloadResponse<Value, SalemoveSDK.AFError>)
  @objc deinit
}
open class ClosureEventMonitor : SalemoveSDK.EventMonitor {
  open var sessionDidBecomeInvalidWithError: ((Foundation.URLSession, Swift.Error?) -> Swift.Void)?
  open var taskDidReceiveChallenge: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.URLAuthenticationChallenge) -> Swift.Void)?
  open var taskDidSendBodyData: ((Foundation.URLSession, Foundation.URLSessionTask, Swift.Int64, Swift.Int64, Swift.Int64) -> Swift.Void)?
  open var taskNeedNewBodyStream: ((Foundation.URLSession, Foundation.URLSessionTask) -> Swift.Void)?
  open var taskWillPerformHTTPRedirection: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.HTTPURLResponse, Foundation.URLRequest) -> Swift.Void)?
  open var taskDidFinishCollectingMetrics: ((Foundation.URLSession, Foundation.URLSessionTask, Foundation.URLSessionTaskMetrics) -> Swift.Void)?
  open var taskDidComplete: ((Foundation.URLSession, Foundation.URLSessionTask, Swift.Error?) -> Swift.Void)?
  open var taskIsWaitingForConnectivity: ((Foundation.URLSession, Foundation.URLSessionTask) -> Swift.Void)?
  open var dataTaskDidReceiveData: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.Data) -> Swift.Void)?
  open var dataTaskWillCacheResponse: ((Foundation.URLSession, Foundation.URLSessionDataTask, Foundation.CachedURLResponse) -> Swift.Void)?
  open var downloadTaskDidFinishDownloadingToURL: ((Foundation.URLSession, Foundation.URLSessionDownloadTask, Foundation.URL) -> Swift.Void)?
  open var downloadTaskDidWriteData: ((Foundation.URLSession, Foundation.URLSessionDownloadTask, Swift.Int64, Swift.Int64, Swift.Int64) -> Swift.Void)?
  open var downloadTaskDidResumeAtOffset: ((Foundation.URLSession, Foundation.URLSessionDownloadTask, Swift.Int64, Swift.Int64) -> Swift.Void)?
  open var requestDidCreateInitialURLRequest: ((SalemoveSDK.AlamofireRequest, Foundation.URLRequest) -> Swift.Void)?
  open var requestDidFailToCreateURLRequestWithError: ((SalemoveSDK.AlamofireRequest, SalemoveSDK.AFError) -> Swift.Void)?
  open var requestDidAdaptInitialRequestToAdaptedRequest: ((SalemoveSDK.AlamofireRequest, Foundation.URLRequest, Foundation.URLRequest) -> Swift.Void)?
  open var requestDidFailToAdaptURLRequestWithError: ((SalemoveSDK.AlamofireRequest, Foundation.URLRequest, SalemoveSDK.AFError) -> Swift.Void)?
  open var requestDidCreateURLRequest: ((SalemoveSDK.AlamofireRequest, Foundation.URLRequest) -> Swift.Void)?
  open var requestDidCreateTask: ((SalemoveSDK.AlamofireRequest, Foundation.URLSessionTask) -> Swift.Void)?
  open var requestDidGatherMetrics: ((SalemoveSDK.AlamofireRequest, Foundation.URLSessionTaskMetrics) -> Swift.Void)?
  open var requestDidFailTaskEarlyWithError: ((SalemoveSDK.AlamofireRequest, Foundation.URLSessionTask, SalemoveSDK.AFError) -> Swift.Void)?
  open var requestDidCompleteTaskWithError: ((SalemoveSDK.AlamofireRequest, Foundation.URLSessionTask, SalemoveSDK.AFError?) -> Swift.Void)?
  open var requestIsRetrying: ((SalemoveSDK.AlamofireRequest) -> Swift.Void)?
  open var requestDidFinish: ((SalemoveSDK.AlamofireRequest) -> Swift.Void)?
  open var requestDidResume: ((SalemoveSDK.AlamofireRequest) -> Swift.Void)?
  open var requestDidResumeTask: ((SalemoveSDK.AlamofireRequest, Foundation.URLSessionTask) -> Swift.Void)?
  open var requestDidSuspend: ((SalemoveSDK.AlamofireRequest) -> Swift.Void)?
  open var requestDidSuspendTask: ((SalemoveSDK.AlamofireRequest, Foundation.URLSessionTask) -> Swift.Void)?
  open var requestDidCancel: ((SalemoveSDK.AlamofireRequest) -> Swift.Void)?
  open var requestDidCancelTask: ((SalemoveSDK.AlamofireRequest, Foundation.URLSessionTask) -> Swift.Void)?
  open var requestDidValidateRequestResponseDataWithResult: ((SalemoveSDK.AlamofireDataRequest, Foundation.URLRequest?, Foundation.HTTPURLResponse, Foundation.Data?, SalemoveSDK.AlamofireRequest.ValidationResult) -> Swift.Void)?
  open var requestDidParseResponse: ((SalemoveSDK.AlamofireDataRequest, SalemoveSDK.DataResponse<Foundation.Data?, SalemoveSDK.AFError>) -> Swift.Void)?
  open var requestDidValidateRequestResponseWithResult: ((SalemoveSDK.DataStreamRequest, Foundation.URLRequest?, Foundation.HTTPURLResponse, SalemoveSDK.AlamofireRequest.ValidationResult) -> Swift.Void)?
  open var requestDidCreateUploadable: ((SalemoveSDK.AlamofireUploadRequest, SalemoveSDK.AlamofireUploadRequest.Uploadable) -> Swift.Void)?
  open var requestDidFailToCreateUploadableWithError: ((SalemoveSDK.AlamofireUploadRequest, SalemoveSDK.AFError) -> Swift.Void)?
  open var requestDidProvideInputStream: ((SalemoveSDK.AlamofireUploadRequest, Foundation.InputStream) -> Swift.Void)?
  open var requestDidFinishDownloadingUsingTaskWithResult: ((SalemoveSDK.AlamofireDownloadRequest, Foundation.URLSessionTask, Swift.Result<Foundation.URL, SalemoveSDK.AFError>) -> Swift.Void)?
  open var requestDidCreateDestinationURL: ((SalemoveSDK.AlamofireDownloadRequest, Foundation.URL) -> Swift.Void)?
  open var requestDidValidateRequestResponseFileURLWithResult: ((SalemoveSDK.AlamofireDownloadRequest, Foundation.URLRequest?, Foundation.HTTPURLResponse, Foundation.URL?, SalemoveSDK.AlamofireRequest.ValidationResult) -> Swift.Void)?
  open var requestDidParseDownloadResponse: ((SalemoveSDK.AlamofireDownloadRequest, SalemoveSDK.DownloadResponse<Foundation.URL?, SalemoveSDK.AFError>) -> Swift.Void)?
  final public let queue: Dispatch.DispatchQueue
  public init(queue: Dispatch.DispatchQueue = .main)
  open func urlSession(_ session: Foundation.URLSession, didBecomeInvalidWithError error: Swift.Error?)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didReceive challenge: Foundation.URLAuthenticationChallenge)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didSendBodyData bytesSent: Swift.Int64, totalBytesSent: Swift.Int64, totalBytesExpectedToSend: Swift.Int64)
  open func urlSession(_ session: Foundation.URLSession, taskNeedsNewBodyStream task: Foundation.URLSessionTask)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, willPerformHTTPRedirection response: Foundation.HTTPURLResponse, newRequest request: Foundation.URLRequest)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didFinishCollecting metrics: Foundation.URLSessionTaskMetrics)
  open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: Swift.Error?)
  open func urlSession(_ session: Foundation.URLSession, taskIsWaitingForConnectivity task: Foundation.URLSessionTask)
  open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, didReceive data: Foundation.Data)
  open func urlSession(_ session: Foundation.URLSession, dataTask: Foundation.URLSessionDataTask, willCacheResponse proposedResponse: Foundation.CachedURLResponse)
  open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didResumeAtOffset fileOffset: Swift.Int64, expectedTotalBytes: Swift.Int64)
  open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didWriteData bytesWritten: Swift.Int64, totalBytesWritten: Swift.Int64, totalBytesExpectedToWrite: Swift.Int64)
  open func urlSession(_ session: Foundation.URLSession, downloadTask: Foundation.URLSessionDownloadTask, didFinishDownloadingTo location: Foundation.URL)
  open func request(_ request: SalemoveSDK.AlamofireRequest, didCreateInitialURLRequest urlRequest: Foundation.URLRequest)
  open func request(_ request: SalemoveSDK.AlamofireRequest, didFailToCreateURLRequestWithError error: SalemoveSDK.AFError)
  open func request(_ request: SalemoveSDK.AlamofireRequest, didAdaptInitialRequest initialRequest: Foundation.URLRequest, to adaptedRequest: Foundation.URLRequest)
  open func request(_ request: SalemoveSDK.AlamofireRequest, didFailToAdaptURLRequest initialRequest: Foundation.URLRequest, withError error: SalemoveSDK.AFError)
  open func request(_ request: SalemoveSDK.AlamofireRequest, didCreateURLRequest urlRequest: Foundation.URLRequest)
  open func request(_ request: SalemoveSDK.AlamofireRequest, didCreateTask task: Foundation.URLSessionTask)
  open func request(_ request: SalemoveSDK.AlamofireRequest, didGatherMetrics metrics: Foundation.URLSessionTaskMetrics)
  open func request(_ request: SalemoveSDK.AlamofireRequest, didFailTask task: Foundation.URLSessionTask, earlyWithError error: SalemoveSDK.AFError)
  open func request(_ request: SalemoveSDK.AlamofireRequest, didCompleteTask task: Foundation.URLSessionTask, with error: SalemoveSDK.AFError?)
  open func requestIsRetrying(_ request: SalemoveSDK.AlamofireRequest)
  open func requestDidFinish(_ request: SalemoveSDK.AlamofireRequest)
  open func requestDidResume(_ request: SalemoveSDK.AlamofireRequest)
  public func request(_ request: SalemoveSDK.AlamofireRequest, didResumeTask task: Foundation.URLSessionTask)
  open func requestDidSuspend(_ request: SalemoveSDK.AlamofireRequest)
  public func request(_ request: SalemoveSDK.AlamofireRequest, didSuspendTask task: Foundation.URLSessionTask)
  open func requestDidCancel(_ request: SalemoveSDK.AlamofireRequest)
  public func request(_ request: SalemoveSDK.AlamofireRequest, didCancelTask task: Foundation.URLSessionTask)
  open func request(_ request: SalemoveSDK.AlamofireDataRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, data: Foundation.Data?, withResult result: SalemoveSDK.AlamofireRequest.ValidationResult)
  open func request(_ request: SalemoveSDK.AlamofireDataRequest, didParseResponse response: SalemoveSDK.DataResponse<Foundation.Data?, SalemoveSDK.AFError>)
  public func request(_ request: SalemoveSDK.DataStreamRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, withResult result: SalemoveSDK.AlamofireRequest.ValidationResult)
  open func request(_ request: SalemoveSDK.AlamofireUploadRequest, didCreateUploadable uploadable: SalemoveSDK.AlamofireUploadRequest.Uploadable)
  open func request(_ request: SalemoveSDK.AlamofireUploadRequest, didFailToCreateUploadableWithError error: SalemoveSDK.AFError)
  open func request(_ request: SalemoveSDK.AlamofireUploadRequest, didProvideInputStream stream: Foundation.InputStream)
  open func request(_ request: SalemoveSDK.AlamofireDownloadRequest, didFinishDownloadingUsing task: Foundation.URLSessionTask, with result: Swift.Result<Foundation.URL, SalemoveSDK.AFError>)
  open func request(_ request: SalemoveSDK.AlamofireDownloadRequest, didCreateDestinationURL url: Foundation.URL)
  open func request(_ request: SalemoveSDK.AlamofireDownloadRequest, didValidateRequest urlRequest: Foundation.URLRequest?, response: Foundation.HTTPURLResponse, fileURL: Foundation.URL?, withResult result: SalemoveSDK.AlamofireRequest.ValidationResult)
  open func request(_ request: SalemoveSDK.AlamofireDownloadRequest, didParseResponse response: SalemoveSDK.DownloadResponse<Foundation.URL?, SalemoveSDK.AFError>)
  @objc deinit
}
public struct MCAMediaTimingFunctionName {
}
@objc public enum VideoScalingOptions : Swift.Int {
  case fill
  case aspectFit
  case aspectFill
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @objc public class StreamView : UIKit.UIView {
  @objc public var scale: SalemoveSDK.VideoScalingOptions {
    @objc get
    @objc set
  }
  @objc deinit
}
extension StreamView : WebRTC.RTCVideoViewDelegate {
  @objc dynamic public func videoView(_ videoView: WebRTC.RTCVideoRenderer, didChangeVideoSize size: CoreGraphics.CGSize)
}
public protocol TransformInterpolation : SalemoveSDK.Interpolable {
}
extension Transform : SalemoveSDK.TransformInterpolation {
  final public func interpolate(_ endValue: SalemoveSDK.Transform, progress: Swift.Double) -> SalemoveSDK.Transform
}
@objc public enum LogLevel : Swift.Int {
  case none
  case error
  case warning
  case info
  case debug
  public static func >= (a: SalemoveSDK.LogLevel, b: SalemoveSDK.LogLevel) -> Swift.Bool
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers @objc public class LocalScreen : ObjectiveC.NSObject {
  @objc public func stopSharing()
  @objc public func getStreamView() -> SalemoveSDK.StreamView
  @objc override dynamic public init()
  @objc deinit
}
@_hasMissingDesignatedInitializers public class SwiftPhoenixClientChannel {
  final public let topic: Swift.String
  public var params: SalemoveSDK.Payload {
    get
    set
  }
  @objc deinit
  public var onMessage: (SalemoveSDK.SwiftPhoenixClientMessage) -> SalemoveSDK.SwiftPhoenixClientMessage
  @discardableResult
  public func join(timeout: Foundation.TimeInterval? = nil) -> SalemoveSDK.SwiftPhoenixClientPush
  @discardableResult
  public func onClose(_ callback: @escaping ((SalemoveSDK.SwiftPhoenixClientMessage) -> Swift.Void)) -> Swift.Int
  @discardableResult
  public func delegateOnClose<Target>(to owner: Target, callback: @escaping ((Target, SalemoveSDK.SwiftPhoenixClientMessage) -> Swift.Void)) -> Swift.Int where Target : AnyObject
  @discardableResult
  public func onError(_ callback: @escaping ((SalemoveSDK.SwiftPhoenixClientMessage) -> Swift.Void)) -> Swift.Int
  @discardableResult
  public func delegateOnError<Target>(to owner: Target, callback: @escaping ((Target, SalemoveSDK.SwiftPhoenixClientMessage) -> Swift.Void)) -> Swift.Int where Target : AnyObject
  @discardableResult
  public func on(_ event: Swift.String, callback: @escaping ((SalemoveSDK.SwiftPhoenixClientMessage) -> Swift.Void)) -> Swift.Int
  @discardableResult
  public func delegateOn<Target>(_ event: Swift.String, to owner: Target, callback: @escaping ((Target, SalemoveSDK.SwiftPhoenixClientMessage) -> Swift.Void)) -> Swift.Int where Target : AnyObject
  public func off(_ event: Swift.String, ref: Swift.Int? = nil)
  @discardableResult
  public func push(_ event: Swift.String, payload: SalemoveSDK.Payload, timeout: Foundation.TimeInterval = Defaults.timeoutInterval) -> SalemoveSDK.SwiftPhoenixClientPush
  @discardableResult
  public func leave(timeout: Foundation.TimeInterval = Defaults.timeoutInterval) -> SalemoveSDK.SwiftPhoenixClientPush
  public func onMessage(callback: @escaping (SalemoveSDK.SwiftPhoenixClientMessage) -> SalemoveSDK.SwiftPhoenixClientMessage)
}
extension SwiftPhoenixClientChannel {
  public var isClosed: Swift.Bool {
    get
  }
  public var isErrored: Swift.Bool {
    get
  }
  public var isJoined: Swift.Bool {
    get
  }
  public var isJoining: Swift.Bool {
    get
  }
  public var isLeaving: Swift.Bool {
    get
  }
}
public protocol SocketIOSSLTrustValidator {
  func isValid(_ trust: Security.SecTrust, domain: Swift.String?) -> Swift.Bool
}
@objc open class SocketIOSSLCert : ObjectiveC.NSObject {
  public init(data: Foundation.Data)
  public init(key: Security.SecKey)
  @objc override dynamic public init()
  @objc deinit
}
open class SocketIOSSLSecurity : SalemoveSDK.SocketIOSSLTrustValidator {
  public var validatedDN: Swift.Bool
  convenience public init(usePublicKeys: Swift.Bool = false)
  public init(certs: [SalemoveSDK.SocketIOSSLCert], usePublicKeys: Swift.Bool)
  public func isValid(_ trust: Security.SecTrust, domain: Swift.String?) -> Swift.Bool
  @objc deinit
}
@_hasMissingDesignatedInitializers @objc public class OperatorPicture : ObjectiveC.NSObject {
  @objc final public let url: Swift.String?
  @objc override dynamic public init()
  @objc deinit
}
@_hasMissingDesignatedInitializers public class SWXMLHashOptions {
  public var shouldProcessLazily: Swift.Bool
  public var shouldProcessNamespaces: Swift.Bool
  public var caseInsensitive: Swift.Bool
  public var encoding: Swift.String.Encoding
  @objc deinit
}
@_hasMissingDesignatedInitializers public class SWXMLHash {
  public class func config(_ configAction: (SalemoveSDK.SWXMLHashOptions) -> Swift.Void) -> SalemoveSDK.SWXMLHash
  public func parse(_ xml: Swift.String) -> SalemoveSDK.XMLIndexer
  public func parse(_ data: Foundation.Data) -> SalemoveSDK.XMLIndexer
  public class func parse(_ xml: Swift.String) -> SalemoveSDK.XMLIndexer
  public class func parse(_ data: Foundation.Data) -> SalemoveSDK.XMLIndexer
  public class func lazy(_ xml: Swift.String) -> SalemoveSDK.XMLIndexer
  public class func lazy(_ data: Foundation.Data) -> SalemoveSDK.XMLIndexer
  @objc deinit
}
@_hasMissingDesignatedInitializers public class IndexOp {
  @objc deinit
}
@_hasMissingDesignatedInitializers public class IndexOps {
  @objc deinit
}
public enum IndexingError : Swift.Error {
  case attribute(attr: Swift.String)
  case attributeValue(attr: Swift.String, value: Swift.String)
  case key(key: Swift.String)
  case index(idx: Swift.Int)
  case initialize(instance: Swift.AnyObject)
  case encoding
  case error
  @available(*, unavailable, renamed: "attribute(attr:)")
  public static func Attribute(attr: Swift.String) -> SalemoveSDK.IndexingError
  @available(*, unavailable, renamed: "attributeValue(attr:value:)")
  public static func AttributeValue(attr: Swift.String, value: Swift.String) -> SalemoveSDK.IndexingError
  @available(*, unavailable, renamed: "key(key:)")
  public static func Key(key: Swift.String) -> SalemoveSDK.IndexingError
  @available(*, unavailable, renamed: "index(idx:)")
  public static func Index(idx: Swift.Int) -> SalemoveSDK.IndexingError
  @available(*, unavailable, renamed: "initialize(instance:)")
  public static func Init(instance: Swift.AnyObject) -> SalemoveSDK.IndexingError
  @available(*, unavailable, renamed: "error")
  public static var Error: SalemoveSDK.IndexingError {
    get
  }
}
public enum XMLIndexer {
  case element(SalemoveSDK.XMLElement)
  case list([SalemoveSDK.XMLElement])
  case stream(SalemoveSDK.IndexOps)
  case xmlError(SalemoveSDK.IndexingError)
  @available(*, unavailable, renamed: "element(_:)")
  public static func Element(_: SalemoveSDK.XMLElement) -> SalemoveSDK.XMLIndexer
  @available(*, unavailable, renamed: "list(_:)")
  public static func List(_: [SalemoveSDK.XMLElement]) -> SalemoveSDK.XMLIndexer
  @available(*, unavailable, renamed: "stream(_:)")
  public static func Stream(_: SalemoveSDK.IndexOps) -> SalemoveSDK.XMLIndexer
  @available(*, unavailable, renamed: "xmlError(_:)")
  public static func XMLError(_: SalemoveSDK.IndexingError) -> SalemoveSDK.XMLIndexer
  @available(*, unavailable, renamed: "withAttribute(_:_:)")
  public static func withAttr(_ attr: Swift.String, _ value: Swift.String) throws -> SalemoveSDK.XMLIndexer
  public var element: SalemoveSDK.XMLElement? {
    get
  }
  public var all: [SalemoveSDK.XMLIndexer] {
    get
  }
  public var children: [SalemoveSDK.XMLIndexer] {
    get
  }
  public func withAttribute(_ attr: Swift.String, _ value: Swift.String) throws -> SalemoveSDK.XMLIndexer
  public init(_ rawObject: Swift.AnyObject) throws
  public init(_ elem: SalemoveSDK.XMLElement)
  public func byKey(_ key: Swift.String) throws -> SalemoveSDK.XMLIndexer
  public subscript(key: Swift.String) -> SalemoveSDK.XMLIndexer {
    get
  }
  public func byIndex(_ index: Swift.Int) throws -> SalemoveSDK.XMLIndexer
  public subscript(index: Swift.Int) -> SalemoveSDK.XMLIndexer {
    get
  }
}
extension XMLIndexer : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension IndexingError : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public protocol XMLContent : Swift.CustomStringConvertible {
}
@_hasMissingDesignatedInitializers public class TextElement : SalemoveSDK.XMLContent {
  final public let text: Swift.String
  @objc deinit
}
public struct XMLAttribute {
  public let name: Swift.String
  public let text: Swift.String
}
@_hasMissingDesignatedInitializers public class XMLElement : SalemoveSDK.XMLContent {
  final public let name: Swift.String
  public var caseInsensitive: Swift.Bool
  public var allAttributes: [Swift.String : SalemoveSDK.XMLAttribute]
  public func attribute(by name: Swift.String) -> SalemoveSDK.XMLAttribute?
  public var text: Swift.String {
    get
  }
  public var recursiveText: Swift.String {
    get
  }
  public var children: [SalemoveSDK.XMLContent]
  @objc deinit
}
extension TextElement : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension XMLAttribute : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension XMLElement : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension SWXMLHash {
  public typealias XMLElement = SalemoveSDK.SWXMLHashXMLElement
}
public typealias SWXMLHashXMLElement = SalemoveSDK.XMLElement
@objc public enum GeneralError : Swift.Int, Swift.Error {
  case internalError
  case networkError
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public static var _nsErrorDomain: Swift.String {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum ContextError : Swift.Int, Swift.Error {
  case invalidURL
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public static var _nsErrorDomain: Swift.String {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum ConfigurationError : Swift.Int, Swift.Error {
  case invalidSite
  case invalidEnvironment
  case invalidAppToken
  case invalidApiToken
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public static var _nsErrorDomain: Swift.String {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum MediaUpgradeError : Swift.Int, Swift.Error {
  case requestError
  case unsupportedRequest
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public static var _nsErrorDomain: Swift.String {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum EngagementError : Swift.Int, Swift.Error {
  case operatorUnavailable
  case timeout
  case rejected
  case visitorCanceled
  case operatorCanceled
  case operatorLeft
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public static var _nsErrorDomain: Swift.String {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum MediaError : Swift.Int, Swift.Error {
  case permissionDenied
  case screenSharingNotAvailable
  case notAvailableOnIOSVersion
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public static var _nsErrorDomain: Swift.String {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum QueueError : Swift.Int, Swift.Error {
  case queueClosed
  case queueFull
  case invalidId
  case alreadyEnqueued
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public static var _nsErrorDomain: Swift.String {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum FileError : Swift.Int, Swift.Error {
  case infected
  case unsupportedFileType
  case fileTooBig
  case invalidFileURL
  case fileUnavailable
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public static var _nsErrorDomain: Swift.String {
    get
  }
  public var rawValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers @objc public class SalemoveError : ObjectiveC.NSObject {
  @objc public var reason: Swift.String {
    get
  }
  @objc public var error: Swift.Error? {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
@_hasMissingDesignatedInitializers @objc public class Queue : ObjectiveC.NSObject {
  @objc public var id: Swift.String {
    get
  }
  @objc public var name: Swift.String {
    get
  }
  @objc public var state: SalemoveSDK.QueueState {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
@_hasMissingDesignatedInitializers @objc public class QueueState : ObjectiveC.NSObject {
  public var status: SalemoveSDK.QueueStatus {
    get
  }
  public var media: [SalemoveSDK.MediaType] {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
public enum QueueStatus : Swift.String, Swift.Codable {
  case open
  case closed
  case full
  case unstaffed
  case unknown
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension Transform : Swift.Hashable {
  final public func hash(into hasher: inout Swift.Hasher)
  final public var hashValue: Swift.Int {
    get
  }
}
public func == (lhs: SalemoveSDK.Transform, rhs: SalemoveSDK.Transform) -> Swift.Bool
public struct HTTPHeaders {
  public init()
  public init(_ headers: [SalemoveSDK.HTTPHeader])
  public init(_ dictionary: [Swift.String : Swift.String])
  public mutating func add(name: Swift.String, value: Swift.String)
  public mutating func add(_ header: SalemoveSDK.HTTPHeader)
  public mutating func update(name: Swift.String, value: Swift.String)
  public mutating func update(_ header: SalemoveSDK.HTTPHeader)
  public mutating func remove(name: Swift.String)
  public mutating func sort()
  public func sorted() -> SalemoveSDK.HTTPHeaders
  public func value(for name: Swift.String) -> Swift.String?
  public subscript(name: Swift.String) -> Swift.String? {
    get
    set
  }
  public var dictionary: [Swift.String : Swift.String] {
    get
  }
}
extension HTTPHeaders : Swift.ExpressibleByDictionaryLiteral {
  public init(dictionaryLiteral elements: (Swift.String, Swift.String)...)
  public typealias Key = Swift.String
  public typealias Value = Swift.String
}
extension HTTPHeaders : Swift.ExpressibleByArrayLiteral {
  public init(arrayLiteral elements: SalemoveSDK.HTTPHeader...)
  public typealias ArrayLiteralElement = SalemoveSDK.HTTPHeader
}
extension HTTPHeaders : Swift.Sequence {
  public func makeIterator() -> Swift.IndexingIterator<[SalemoveSDK.HTTPHeader]>
}
extension HTTPHeaders : Swift.Collection {
  public var startIndex: Swift.Int {
    get
  }
  public var endIndex: Swift.Int {
    get
  }
  public subscript(position: Swift.Int) -> SalemoveSDK.HTTPHeader {
    get
  }
  public func index(after i: Swift.Int) -> Swift.Int
  public typealias Element = SalemoveSDK.HTTPHeader
  public typealias Index = Swift.Int
  public typealias Indices = Swift.DefaultIndices<SalemoveSDK.HTTPHeaders>
  public typealias Iterator = Swift.IndexingIterator<[SalemoveSDK.HTTPHeader]>
  public typealias SubSequence = Swift.Slice<SalemoveSDK.HTTPHeaders>
}
extension HTTPHeaders : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public struct HTTPHeader : Swift.Hashable {
  public let name: Swift.String
  public let value: Swift.String
  public init(name: Swift.String, value: Swift.String)
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: SalemoveSDK.HTTPHeader, b: SalemoveSDK.HTTPHeader) -> Swift.Bool
  public var hashValue: Swift.Int {
    get
  }
}
extension HTTPHeader : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension HTTPHeader {
  public static func accept(_ value: Swift.String) -> SalemoveSDK.HTTPHeader
  public static func acceptCharset(_ value: Swift.String) -> SalemoveSDK.HTTPHeader
  public static func acceptLanguage(_ value: Swift.String) -> SalemoveSDK.HTTPHeader
  public static func acceptEncoding(_ value: Swift.String) -> SalemoveSDK.HTTPHeader
  public static func authorization(username: Swift.String, password: Swift.String) -> SalemoveSDK.HTTPHeader
  public static func authorization(bearerToken: Swift.String) -> SalemoveSDK.HTTPHeader
  public static func authorization(_ value: Swift.String) -> SalemoveSDK.HTTPHeader
  public static func contentDisposition(_ value: Swift.String) -> SalemoveSDK.HTTPHeader
  public static func contentType(_ value: Swift.String) -> SalemoveSDK.HTTPHeader
  public static func userAgent(_ value: Swift.String) -> SalemoveSDK.HTTPHeader
}
extension HTTPHeaders {
  public static let `default`: SalemoveSDK.HTTPHeaders
}
extension HTTPHeader {
  public static let defaultAcceptEncoding: SalemoveSDK.HTTPHeader
  public static let defaultAcceptLanguage: SalemoveSDK.HTTPHeader
  public static let defaultUserAgent: SalemoveSDK.HTTPHeader
}
extension URLRequest {
  public var headers: SalemoveSDK.HTTPHeaders {
    get
    set
  }
}
extension HTTPURLResponse {
  public var headers: SalemoveSDK.HTTPHeaders {
    get
  }
}
extension URLSessionConfiguration {
  public var headers: SalemoveSDK.HTTPHeaders {
    get
    set
  }
}
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers final public class Salemove : ObjectiveC.NSObject {
  @objc public static let sharedInstance: SalemoveSDK.Salemove
  @objc weak final public var currentInteractor: SalemoveSDK.Interactable?
  @objc final public var pushHandler: SalemoveSDK.PushActionBlock? {
    @objc get
    @objc set
  }
  @objc final public var environment: Swift.String {
    @objc get
  }
  @objc final public var site: Swift.String {
    @objc get
  }
  @objc final public var appToken: Swift.String {
    @objc get
  }
  @objc final public var apiToken: Swift.String {
    @objc get
  }
  @objc deinit
}
extension Salemove {
  @objc final public func configureLogLevel(level: SalemoveSDK.LogLevel)
}
extension Salemove : SalemoveSDK.PushNotificationConfigurable {
  final public func configurePushNotifications(_ notifications: [SalemoveSDK.PushNotificationType])
}
@_hasMissingDesignatedInitializers @objc public class Operator : ObjectiveC.NSObject {
  @objc public var name: Swift.String {
    get
  }
  @objc public var picture: SalemoveSDK.OperatorPicture? {
    get
  }
  public var availableMedia: [SalemoveSDK.MediaType]? {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
@_hasMissingDesignatedInitializers open class AspectRatio {
  public static let none: SalemoveSDK.AspectRatio
  public static let meet: SalemoveSDK.AspectRatio
  public static let slice: SalemoveSDK.AspectRatio
  open func fit(size: SalemoveSDK.Size, into sizeToFitIn: SalemoveSDK.Size) -> SalemoveSDK.Size
  open func fit(rect: SalemoveSDK.Rect, into rectToFitIn: SalemoveSDK.Rect) -> SalemoveSDK.Size
  open func fit(size: SalemoveSDK.Size, into rectToFitIn: SalemoveSDK.Rect) -> SalemoveSDK.Size
  @objc deinit
}
public typealias InternalOperatorTypingStatusUpdate = (SalemoveSDK.OperatorTypingStatus) -> Swift.Void
open class Rect : SalemoveSDK.Locus {
  final public let x: Swift.Double
  final public let y: Swift.Double
  final public let w: Swift.Double
  final public let h: Swift.Double
  public init(_ x: Swift.Double, _ y: Swift.Double, _ w: Swift.Double, _ h: Swift.Double)
  public init(x: Swift.Double = 0, y: Swift.Double = 0, w: Swift.Double = 0, h: Swift.Double = 0)
  public init(point: SalemoveSDK.Point, size: SalemoveSDK.Size)
  override open func bounds() -> SalemoveSDK.Rect
  open func round(rx: Swift.Double, ry: Swift.Double) -> SalemoveSDK.RoundRect
  public func round(r: Swift.Double) -> SalemoveSDK.RoundRect
  open func center() -> SalemoveSDK.Point
  open func contains(locus: SalemoveSDK.Locus) -> Swift.Bool
  open func move(offset: SalemoveSDK.Point) -> SalemoveSDK.Rect
  open func union(rect: SalemoveSDK.Rect) -> SalemoveSDK.Rect
  open func size() -> SalemoveSDK.Size
  override open func toPath() -> SalemoveSDK.Path
  override public init()
  @objc deinit
}
extension Rect {
  public static func == (lhs: SalemoveSDK.Rect, rhs: SalemoveSDK.Rect) -> Swift.Bool
}
extension Color {
  public func toCG() -> CoreGraphics.CGColor
}
extension Transform {
  final public func toCG() -> CoreGraphics.CGAffineTransform
}
extension LineJoin {
  public func toCG() -> CoreGraphics.CGLineJoin
}
extension LineCap {
  public func toCG() -> CoreGraphics.CGLineCap
}
extension Rect {
  public func toCG() -> CoreGraphics.CGRect
  public func applying(_ t: SalemoveSDK.Transform) -> SalemoveSDK.Rect
}
extension CGRect {
  public func toMacaw() -> SalemoveSDK.Rect
}
extension Size {
  public func toCG() -> CoreGraphics.CGSize
}
extension CGSize {
  public func toMacaw() -> SalemoveSDK.Size
}
extension Point {
  public func toCG() -> CoreGraphics.CGPoint
}
extension CGPoint {
  public func toMacaw() -> SalemoveSDK.Point
}
extension Locus {
  public func toCGPath() -> CoreGraphics.CGPath
}
extension CGAffineTransform {
  public func toMacaw() -> SalemoveSDK.Transform
}
extension Node {
  public func toNativeImage(size: SalemoveSDK.Size, layout: SalemoveSDK.ContentLayout = .of()) -> SalemoveSDK.MImage
}
extension UIBezierPath {
  public func toMacaw() -> SalemoveSDK.Path
}
extension CGPath {
  public func toMacaw(fillRule: SalemoveSDK.FillRule = .nonzero) -> SalemoveSDK.Path
}
public protocol AuthenticationCredential {
  var requiresRefresh: Swift.Bool { get }
}
public protocol Authenticator : AnyObject {
  associatedtype Credential : SalemoveSDK.AuthenticationCredential
  func apply(_ credential: Self.Credential, to urlRequest: inout Foundation.URLRequest)
  func refresh(_ credential: Self.Credential, for session: SalemoveSDK.AlamofireSession, completion: @escaping (Swift.Result<Self.Credential, Swift.Error>) -> Swift.Void)
  func didRequest(_ urlRequest: Foundation.URLRequest, with response: Foundation.HTTPURLResponse, failDueToAuthenticationError error: Swift.Error) -> Swift.Bool
  func isRequest(_ urlRequest: Foundation.URLRequest, authenticatedWith credential: Self.Credential) -> Swift.Bool
}
public enum AuthenticationError : Swift.Error {
  case missingCredential
  case excessiveRefresh
  public static func == (a: SalemoveSDK.AuthenticationError, b: SalemoveSDK.AuthenticationError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class AuthenticationInterceptor<AuthenticatorType> : SalemoveSDK.AlamofireRequestInterceptor where AuthenticatorType : SalemoveSDK.Authenticator {
  public typealias Credential = AuthenticatorType.Credential
  public struct RefreshWindow {
    public let interval: Foundation.TimeInterval
    public let maximumAttempts: Swift.Int
    public init(interval: Foundation.TimeInterval = 30.0, maximumAttempts: Swift.Int = 5)
  }
  public var credential: SalemoveSDK.AuthenticationInterceptor<AuthenticatorType>.Credential? {
    get
    set
  }
  public init(authenticator: AuthenticatorType, credential: SalemoveSDK.AuthenticationInterceptor<AuthenticatorType>.Credential? = nil, refreshWindow: SalemoveSDK.AuthenticationInterceptor<AuthenticatorType>.RefreshWindow? = RefreshWindow())
  public func adapt(_ urlRequest: Foundation.URLRequest, for session: SalemoveSDK.AlamofireSession, completion: @escaping (Swift.Result<Foundation.URLRequest, Swift.Error>) -> Swift.Void)
  public func retry(_ request: SalemoveSDK.AlamofireRequest, for session: SalemoveSDK.AlamofireSession, dueTo error: Swift.Error, completion: @escaping (SalemoveSDK.RetryResult) -> Swift.Void)
  @objc deinit
}
final public class NetworkLoggerPlugin {
  final public var configuration: SalemoveSDK.NetworkLoggerPlugin.Configuration
  public init(configuration: SalemoveSDK.NetworkLoggerPlugin.Configuration = Configuration())
  @objc deinit
}
extension NetworkLoggerPlugin : SalemoveSDK.PluginType {
  final public func willSend(_ request: SalemoveSDK.RequestType, target: SalemoveSDK.TargetType)
  final public func didReceive(_ result: Swift.Result<SalemoveSDK.MoyaResponse, SalemoveSDK.MoyaError>, target: SalemoveSDK.TargetType)
}
extension NetworkLoggerPlugin {
  public struct Configuration {
    public typealias OutputType = (SalemoveSDK.TargetType, [Swift.String]) -> Swift.Void
    public var formatter: SalemoveSDK.NetworkLoggerPlugin.Configuration.Formatter
    public var output: SalemoveSDK.NetworkLoggerPlugin.Configuration.OutputType
    public var logOptions: SalemoveSDK.NetworkLoggerPlugin.Configuration.LogOptions
    public init(formatter: SalemoveSDK.NetworkLoggerPlugin.Configuration.Formatter = Formatter(), output: @escaping SalemoveSDK.NetworkLoggerPlugin.Configuration.OutputType = defaultOutput, logOptions: SalemoveSDK.NetworkLoggerPlugin.Configuration.LogOptions = .default)
    public static func defaultOutput(target: SalemoveSDK.TargetType, items: [Swift.String])
  }
}
extension NetworkLoggerPlugin.Configuration {
  public struct LogOptions : Swift.OptionSet {
    public let rawValue: Swift.Int
    public init(rawValue: Swift.Int)
    public static let requestMethod: SalemoveSDK.NetworkLoggerPlugin.Configuration.LogOptions
    public static let requestBody: SalemoveSDK.NetworkLoggerPlugin.Configuration.LogOptions
    public static let requestHeaders: SalemoveSDK.NetworkLoggerPlugin.Configuration.LogOptions
    public static let formatRequestAscURL: SalemoveSDK.NetworkLoggerPlugin.Configuration.LogOptions
    public static let successResponseBody: SalemoveSDK.NetworkLoggerPlugin.Configuration.LogOptions
    public static let errorResponseBody: SalemoveSDK.NetworkLoggerPlugin.Configuration.LogOptions
    public static let `default`: SalemoveSDK.NetworkLoggerPlugin.Configuration.LogOptions
    public static let verbose: SalemoveSDK.NetworkLoggerPlugin.Configuration.LogOptions
    public typealias ArrayLiteralElement = SalemoveSDK.NetworkLoggerPlugin.Configuration.LogOptions
    public typealias Element = SalemoveSDK.NetworkLoggerPlugin.Configuration.LogOptions
    public typealias RawValue = Swift.Int
  }
}
extension NetworkLoggerPlugin.Configuration {
  public struct Formatter {
    public typealias DataFormatterType = (Foundation.Data) -> (Swift.String)
    public typealias EntryFormatterType = (Swift.String, Swift.String, SalemoveSDK.TargetType) -> Swift.String
    public var entry: SalemoveSDK.NetworkLoggerPlugin.Configuration.Formatter.EntryFormatterType
    public var requestData: SalemoveSDK.NetworkLoggerPlugin.Configuration.Formatter.DataFormatterType
    public var responseData: SalemoveSDK.NetworkLoggerPlugin.Configuration.Formatter.DataFormatterType
    public init(entry: @escaping SalemoveSDK.NetworkLoggerPlugin.Configuration.Formatter.EntryFormatterType = defaultEntryFormatter, requestData: @escaping SalemoveSDK.NetworkLoggerPlugin.Configuration.Formatter.DataFormatterType = defaultDataFormatter, responseData: @escaping SalemoveSDK.NetworkLoggerPlugin.Configuration.Formatter.DataFormatterType = defaultDataFormatter)
    public static func defaultDataFormatter(_ data: Foundation.Data) -> Swift.String
    public static func defaultEntryFormatter(identifier: Swift.String, message: Swift.String, target: SalemoveSDK.TargetType) -> Swift.String
  }
}
@_hasMissingDesignatedInitializers open class MacawDisposable {
  open func dispose()
  @objc deinit
}
public protocol DoubleInterpolation : SalemoveSDK.Interpolable {
}
extension Double : SalemoveSDK.DoubleInterpolation {
  public func interpolate(_ endValue: Swift.Double, progress: Swift.Double) -> Swift.Double
}
open class LinearGradient : SalemoveSDK.Gradient {
  final public let x1: Swift.Double
  final public let y1: Swift.Double
  final public let x2: Swift.Double
  final public let y2: Swift.Double
  public init(x1: Swift.Double = 0, y1: Swift.Double = 0, x2: Swift.Double = 0, y2: Swift.Double = 0, userSpace: Swift.Bool = false, stops: [SalemoveSDK.Stop] = [])
  convenience public init(degree: Swift.Double = 0, from: SalemoveSDK.Color, to: SalemoveSDK.Color)
  public init(degree: Swift.Double = 0, stops: [SalemoveSDK.Stop])
  override public init(userSpace: Swift.Bool = super, stops: [SalemoveSDK.Stop] = super)
  @objc deinit
}
open class Ellipse : SalemoveSDK.Locus {
  final public let cx: Swift.Double
  final public let cy: Swift.Double
  final public let rx: Swift.Double
  final public let ry: Swift.Double
  public init(cx: Swift.Double = 0, cy: Swift.Double = 0, rx: Swift.Double = 0, ry: Swift.Double = 0)
  override open func bounds() -> SalemoveSDK.Rect
  open func arc(shift: Swift.Double, extent: Swift.Double) -> SalemoveSDK.Arc
  override public init()
  @objc deinit
}
extension Sequence where Self.Element : SalemoveSDK.Animation {
  public func combine(delay: Swift.Double = 0.0, node: SalemoveSDK.Node? = .none, toNodes: [SalemoveSDK.Node] = []) -> SalemoveSDK.Animation
}
public protocol XMLIndexerDeserializable {
  static func deserialize(_ element: SalemoveSDK.XMLIndexer) throws -> Self
}
extension XMLIndexerDeserializable {
  public static func deserialize(_ element: SalemoveSDK.XMLIndexer) throws -> Self
}
public protocol XMLElementDeserializable {
  static func deserialize(_ element: SalemoveSDK.XMLElement) throws -> Self
}
extension XMLElementDeserializable {
  public static func deserialize(_ element: SalemoveSDK.XMLElement) throws -> Self
}
public protocol XMLAttributeDeserializable {
  static func deserialize(_ attribute: SalemoveSDK.XMLAttribute) throws -> Self
}
extension XMLAttributeDeserializable {
  public static func deserialize(attribute: SalemoveSDK.XMLAttribute) throws -> Self
}
extension XMLIndexer {
  public func value<T>(ofAttribute attr: Swift.String) throws -> T where T : SalemoveSDK.XMLAttributeDeserializable
  public func value<T>(ofAttribute attr: Swift.String) -> T? where T : SalemoveSDK.XMLAttributeDeserializable
  public func value<T>(ofAttribute attr: Swift.String) throws -> [T] where T : SalemoveSDK.XMLAttributeDeserializable
  public func value<T>(ofAttribute attr: Swift.String) throws -> [T]? where T : SalemoveSDK.XMLAttributeDeserializable
  public func value<T>(ofAttribute attr: Swift.String) throws -> [T?] where T : SalemoveSDK.XMLAttributeDeserializable
  public func value<T>() throws -> T where T : SalemoveSDK.XMLElementDeserializable
  public func value<T>() throws -> T? where T : SalemoveSDK.XMLElementDeserializable
  public func value<T>() throws -> [T] where T : SalemoveSDK.XMLElementDeserializable
  public func value<T>() throws -> [T]? where T : SalemoveSDK.XMLElementDeserializable
  public func value<T>() throws -> [T?] where T : SalemoveSDK.XMLElementDeserializable
  public func value<T>() throws -> T where T : SalemoveSDK.XMLIndexerDeserializable
  public func value<T>() throws -> T? where T : SalemoveSDK.XMLIndexerDeserializable
  public func value<T>() throws -> [T] where T : SalemoveSDK.XMLIndexerDeserializable
  public func value<T>() throws -> [T]? where T : SalemoveSDK.XMLIndexerDeserializable
  public func value<T>() throws -> [T?] where T : SalemoveSDK.XMLIndexerDeserializable
}
extension XMLElement {
  public func value<T>(ofAttribute attr: Swift.String) throws -> T where T : SalemoveSDK.XMLAttributeDeserializable
  public func value<T>(ofAttribute attr: Swift.String) -> T? where T : SalemoveSDK.XMLAttributeDeserializable
}
public enum XMLDeserializationError : Swift.Error, Swift.CustomStringConvertible {
  case implementationIsMissing(method: Swift.String)
  case nodeIsInvalid(node: SalemoveSDK.XMLIndexer)
  case nodeHasNoValue
  case typeConversionFailed(type: Swift.String, element: SalemoveSDK.XMLElement)
  case attributeDoesNotExist(element: SalemoveSDK.XMLElement, attribute: Swift.String)
  case attributeDeserializationFailed(type: Swift.String, attribute: SalemoveSDK.XMLAttribute)
  @available(*, unavailable, renamed: "implementationIsMissing(method:)")
  public static func ImplementationIsMissing(method: Swift.String) -> SalemoveSDK.XMLDeserializationError
  @available(*, unavailable, renamed: "nodeHasNoValue(_:)")
  public static func NodeHasNoValue(_: SalemoveSDK.IndexOps) -> SalemoveSDK.XMLDeserializationError
  @available(*, unavailable, renamed: "typeConversionFailed(_:)")
  public static func TypeConversionFailed(_: SalemoveSDK.IndexingError) -> SalemoveSDK.XMLDeserializationError
  @available(*, unavailable, renamed: "attributeDoesNotExist(_:_:)")
  public static func AttributeDoesNotExist(_ attr: Swift.String, _ value: Swift.String) throws -> SalemoveSDK.XMLDeserializationError
  @available(*, unavailable, renamed: "attributeDeserializationFailed(_:_:)")
  public static func AttributeDeserializationFailed(_ attr: Swift.String, _ value: Swift.String) throws -> SalemoveSDK.XMLDeserializationError
  public var description: Swift.String {
    get
  }
}
extension String : SalemoveSDK.XMLElementDeserializable, SalemoveSDK.XMLAttributeDeserializable {
  public static func deserialize(_ element: SalemoveSDK.XMLElement) -> Swift.String
  public static func deserialize(_ attribute: SalemoveSDK.XMLAttribute) -> Swift.String
}
extension Int : SalemoveSDK.XMLElementDeserializable, SalemoveSDK.XMLAttributeDeserializable {
  public static func deserialize(_ element: SalemoveSDK.XMLElement) throws -> Swift.Int
  public static func deserialize(_ attribute: SalemoveSDK.XMLAttribute) throws -> Swift.Int
}
extension Double : SalemoveSDK.XMLElementDeserializable, SalemoveSDK.XMLAttributeDeserializable {
  public static func deserialize(_ element: SalemoveSDK.XMLElement) throws -> Swift.Double
  public static func deserialize(_ attribute: SalemoveSDK.XMLAttribute) throws -> Swift.Double
}
extension Float : SalemoveSDK.XMLElementDeserializable, SalemoveSDK.XMLAttributeDeserializable {
  public static func deserialize(_ element: SalemoveSDK.XMLElement) throws -> Swift.Float
  public static func deserialize(_ attribute: SalemoveSDK.XMLAttribute) throws -> Swift.Float
}
extension Bool : SalemoveSDK.XMLElementDeserializable, SalemoveSDK.XMLAttributeDeserializable {
  public static func deserialize(_ element: SalemoveSDK.XMLElement) throws -> Swift.Bool
  public static func deserialize(_ attribute: SalemoveSDK.XMLAttribute) throws -> Swift.Bool
}
open class Point : SalemoveSDK.Locus {
  final public let x: Swift.Double
  final public let y: Swift.Double
  public static let origin: SalemoveSDK.Point
  public init(_ x: Swift.Double, _ y: Swift.Double)
  public init(x: Swift.Double = 0, y: Swift.Double = 0)
  override open func bounds() -> SalemoveSDK.Rect
  open func add(_ point: SalemoveSDK.Point) -> SalemoveSDK.Point
  open func rect(size: SalemoveSDK.Size) -> SalemoveSDK.Rect
  open func distance(to point: SalemoveSDK.Point) -> Swift.Double
  override open func toPath() -> SalemoveSDK.Path
  override public init()
  @objc deinit
}
extension Point : Swift.Equatable {
  public static func == (lhs: SalemoveSDK.Point, rhs: SalemoveSDK.Point) -> Swift.Bool
  public static func - (lhs: SalemoveSDK.Point, rhs: SalemoveSDK.Point) -> SalemoveSDK.Size
}
public enum LoggingEvent {
  public enum Signal : Swift.String, Swift.CaseIterable {
    case value, completed, failed, terminated, disposed, interrupted
    @available(*, deprecated, message: "Use `allCases` instead.")
    public static var allEvents: Swift.Set<SalemoveSDK.LoggingEvent.Signal> {
      get
    }
    public init?(rawValue: Swift.String)
    public typealias AllCases = [SalemoveSDK.LoggingEvent.Signal]
    public typealias RawValue = Swift.String
    public static var allCases: [SalemoveSDK.LoggingEvent.Signal] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
  public enum SignalProducer : Swift.String, Swift.CaseIterable {
    case starting, started, value, completed, failed, terminated, disposed, interrupted
    @available(*, deprecated, message: "Use `allCases` instead.")
    public static var allEvents: Swift.Set<SalemoveSDK.LoggingEvent.SignalProducer> {
      get
    }
    public init?(rawValue: Swift.String)
    public typealias AllCases = [SalemoveSDK.LoggingEvent.SignalProducer]
    public typealias RawValue = Swift.String
    public static var allCases: [SalemoveSDK.LoggingEvent.SignalProducer] {
      get
    }
    public var rawValue: Swift.String {
      get
    }
  }
}
public func defaultEventLog(identifier: Swift.String, event: Swift.String, fileName: Swift.String, functionName: Swift.String, lineNumber: Swift.Int)
public typealias EventLogger = (Swift.String, Swift.String, Swift.String, Swift.String, Swift.Int) -> Swift.Void
extension Signal {
  final public func logEvents(identifier: Swift.String = "", events: Swift.Set<SalemoveSDK.LoggingEvent.Signal> = Set(LoggingEvent.Signal.allCases), fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line, logger: @escaping SalemoveSDK.EventLogger = defaultEventLog) -> SalemoveSDK.Signal<Value, Error>
}
extension SignalProducer {
  public func logEvents(identifier: Swift.String = "", events: Swift.Set<SalemoveSDK.LoggingEvent.SignalProducer> = Set(LoggingEvent.SignalProducer.allCases), fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line, logger: @escaping SalemoveSDK.EventLogger = defaultEventLog) -> SalemoveSDK.SignalProducer<Value, Error>
}
extension UIImage {
  public func image(xAlign: SalemoveSDK.Align = .min, yAlign: SalemoveSDK.Align = .min, aspectRatio: SalemoveSDK.AspectRatio = .none, w: Swift.Int = 0, h: Swift.Int = 0, place: SalemoveSDK.Transform = Transform.identity, opaque: Swift.Bool = true, opacity: Swift.Double = 1, clip: SalemoveSDK.Locus? = nil, effect: SalemoveSDK.Effect? = nil, visible: Swift.Bool = true, tag: [Swift.String] = []) -> SalemoveSDK.MacawImage
}
public enum SocketAckStatus : Swift.String {
  case noAck
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
extension URLRequest {
  public var method: SalemoveSDK.AlamofireHTTPMethod? {
    get
    set
  }
  public func validate() throws
}
public struct Bag<Element> {
  public struct Token {
  }
  public init()
  public init<S>(_ elements: S) where Element == S.Element, S : Swift.Sequence
  @discardableResult
  public mutating func insert(_ value: Element) -> SalemoveSDK.Bag<Element>.Token
  @discardableResult
  public mutating func remove(using token: SalemoveSDK.Bag<Element>.Token) -> Element?
}
extension Bag : Swift.RandomAccessCollection {
  public var startIndex: Swift.Int {
    get
  }
  public var endIndex: Swift.Int {
    get
  }
  public subscript(index: Swift.Int) -> Element {
    get
  }
  public func makeIterator() -> SalemoveSDK.Bag<Element>.Iterator
  public struct Iterator : Swift.IteratorProtocol {
    public mutating func next() -> Element?
  }
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  public typealias SubSequence = Swift.Slice<SalemoveSDK.Bag<Element>>
}
extension Salemove {
  @objc final public func queueForEngagement(queueID: Swift.String, visitorContext: SalemoveSDK.VisitorContext, shouldCloseAllQueues: Swift.Bool = true, completion: @escaping SalemoveSDK.QueueTicketBlock)
  @objc final public func dequeueFromActiveTickets(completion: @escaping SalemoveSDK.SuccessBlock)
  @objc final public func cancel(queueTicket: SalemoveSDK.QueueTicket, completion: @escaping SalemoveSDK.SuccessBlock)
  @objc final public func listQueues(completion: @escaping SalemoveSDK.QueueRequestBlock)
  @objc final public func subscribeForUpdates(forQueue queueIds: [Swift.String], onError: @escaping SalemoveSDK.ErrorBlock, onUpdate: @escaping SalemoveSDK.QueueUpdateBlock) -> Swift.String?
  @objc final public func unsubscribeFromUpdates(queueCallbackId: Swift.String, onError: @escaping SalemoveSDK.ErrorBlock)
}
@_hasMissingDesignatedInitializers open class PanEvent : SalemoveSDK.MacawEvent {
  final public let dx: Swift.Double
  final public let dy: Swift.Double
  final public let count: Swift.Int
  @objc deinit
}
@objc public enum SocketEnginePacketType : Swift.Int {
  case open
  case close
  case ping
  case pong
  case message
  case upgrade
  case noop
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public let WebsocketDidConnectNotification: Swift.String
public let WebsocketDidDisconnectNotification: Swift.String
public let WebsocketDisconnectionErrorKeyName: Swift.String
public enum CloseCode : Swift.UInt16 {
  case normal
  case goingAway
  case protocolError
  case protocolUnhandledType
  case noStatusReceived
  case encoding
  case policyViolated
  case messageTooBig
  public init?(rawValue: Swift.UInt16)
  public typealias RawValue = Swift.UInt16
  public var rawValue: Swift.UInt16 {
    get
  }
}
public enum ErrorType : Swift.Error {
  case outputStreamWriteError
  case compressionError
  case invalidSSLError
  case writeTimeoutError
  case protocolError
  case upgradeError
  case closeError
  public static func == (a: SalemoveSDK.ErrorType, b: SalemoveSDK.ErrorType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct WSError : Swift.Error {
  public let type: SalemoveSDK.ErrorType
  public let message: Swift.String
  public let code: Swift.Int
}
public protocol WebSocketClient : AnyObject {
  var delegate: SalemoveSDK.WebSocketDelegate? { get set }
  var pongDelegate: SalemoveSDK.WebSocketPongDelegate? { get set }
  var disableSSLCertValidation: Swift.Bool { get set }
  var overrideTrustHostname: Swift.Bool { get set }
  var desiredTrustHostname: Swift.String? { get set }
  var sslClientCertificate: SalemoveSDK.SSLClientCertificate? { get set }
  var security: SalemoveSDK.SSLTrustValidator? { get set }
  var enabledSSLCipherSuites: [Security.SSLCipherSuite]? { get set }
  var isConnected: Swift.Bool { get }
  func connect()
  func disconnect(forceTimeout: Foundation.TimeInterval?, closeCode: Swift.UInt16)
  func write(string: Swift.String, completion: (() -> ())?)
  func write(data: Foundation.Data, completion: (() -> ())?)
  func write(ping: Foundation.Data, completion: (() -> ())?)
  func write(pong: Foundation.Data, completion: (() -> ())?)
}
extension WebSocketClient {
  public func write(string: Swift.String)
  public func write(data: Foundation.Data)
  public func write(ping: Foundation.Data)
  public func write(pong: Foundation.Data)
  public func disconnect()
}
public struct SSLSettings {
  public let useSSL: Swift.Bool
  public let disableCertValidation: Swift.Bool
  public var overrideTrustHostname: Swift.Bool
  public var desiredTrustHostname: Swift.String?
  public let sslClientCertificate: SalemoveSDK.SSLClientCertificate?
  public let cipherSuites: [Security.SSLCipherSuite]?
}
public protocol WSStreamDelegate : AnyObject {
  func newBytesInStream()
  func streamDidError(error: Swift.Error?)
}
public protocol WSStream {
  var delegate: SalemoveSDK.WSStreamDelegate? { get set }
  func connect(url: Foundation.URL, port: Swift.Int, timeout: Foundation.TimeInterval, ssl: SalemoveSDK.SSLSettings, completion: @escaping ((Swift.Error?) -> Swift.Void))
  func write(data: Foundation.Data) -> Swift.Int
  func read() -> Foundation.Data?
  func cleanup()
  func sslTrust() -> (trust: Security.SecTrust?, domain: Swift.String?)
}
@objc @_inheritsConvenienceInitializers open class FoundationStream : ObjectiveC.NSObject, SalemoveSDK.WSStream, Foundation.StreamDelegate {
  weak public var delegate: SalemoveSDK.WSStreamDelegate?
  public var enableSOCKSProxy: Swift.Bool
  public func connect(url: Foundation.URL, port: Swift.Int, timeout: Foundation.TimeInterval, ssl: SalemoveSDK.SSLSettings, completion: @escaping ((Swift.Error?) -> Swift.Void))
  public func write(data: Foundation.Data) -> Swift.Int
  public func read() -> Foundation.Data?
  public func cleanup()
  public func sslTrust() -> (trust: Security.SecTrust?, domain: Swift.String?)
  @objc open func stream(_ aStream: Foundation.Stream, handle eventCode: Foundation.Stream.Event)
  @objc override dynamic public init()
  @objc deinit
}
public protocol WebSocketDelegate : AnyObject {
  func websocketDidConnect(socket: SalemoveSDK.WebSocketClient)
  func websocketDidDisconnect(socket: SalemoveSDK.WebSocketClient, error: Swift.Error?)
  func websocketDidReceiveMessage(socket: SalemoveSDK.WebSocketClient, text: Swift.String)
  func websocketDidReceiveData(socket: SalemoveSDK.WebSocketClient, data: Foundation.Data)
}
public protocol WebSocketPongDelegate : AnyObject {
  func websocketDidReceivePong(socket: SalemoveSDK.WebSocketClient, data: Foundation.Data?)
}
public protocol WebSocketAdvancedDelegate : AnyObject {
  func websocketDidConnect(socket: SalemoveSDK.WebSocket)
  func websocketDidDisconnect(socket: SalemoveSDK.WebSocket, error: Swift.Error?)
  func websocketDidReceiveMessage(socket: SalemoveSDK.WebSocket, text: Swift.String, response: SalemoveSDK.WebSocket.WSResponse)
  func websocketDidReceiveData(socket: SalemoveSDK.WebSocket, data: Foundation.Data, response: SalemoveSDK.WebSocket.WSResponse)
  func websocketHttpUpgrade(socket: SalemoveSDK.WebSocket, request: Swift.String)
  func websocketHttpUpgrade(socket: SalemoveSDK.WebSocket, response: Swift.String)
}
@objc open class WebSocket : ObjectiveC.NSObject, Foundation.StreamDelegate, SalemoveSDK.WebSocketClient, SalemoveSDK.WSStreamDelegate {
  public enum OpCode : Swift.UInt8 {
    case continueFrame
    case textFrame
    case binaryFrame
    case connectionClose
    case ping
    case pong
    public init?(rawValue: Swift.UInt8)
    public typealias RawValue = Swift.UInt8
    public var rawValue: Swift.UInt8 {
      get
    }
  }
  public static let ErrorDomain: Swift.String
  public var callbackQueue: Dispatch.DispatchQueue
  @_hasMissingDesignatedInitializers public class WSResponse {
    public var code: SalemoveSDK.WebSocket.OpCode
    public var frameCount: Swift.Int
    public var buffer: Foundation.NSMutableData?
    final public let firstFrame: Foundation.Date
    @objc deinit
  }
  weak public var delegate: SalemoveSDK.WebSocketDelegate?
  weak public var advancedDelegate: SalemoveSDK.WebSocketAdvancedDelegate?
  weak public var pongDelegate: SalemoveSDK.WebSocketPongDelegate?
  public var onConnect: (() -> Swift.Void)?
  public var onDisconnect: ((Swift.Error?) -> Swift.Void)?
  public var onText: ((Swift.String) -> Swift.Void)?
  public var onData: ((Foundation.Data) -> Swift.Void)?
  public var onPong: ((Foundation.Data?) -> Swift.Void)?
  public var onHttpResponseHeaders: (([Swift.String : Swift.String]) -> Swift.Void)?
  public var disableSSLCertValidation: Swift.Bool
  public var overrideTrustHostname: Swift.Bool
  public var desiredTrustHostname: Swift.String?
  public var sslClientCertificate: SalemoveSDK.SSLClientCertificate?
  public var enableCompression: Swift.Bool
  public var security: SalemoveSDK.SSLTrustValidator?
  public var enabledSSLCipherSuites: [Security.SSLCipherSuite]?
  public var isConnected: Swift.Bool {
    get
  }
  public var request: Foundation.URLRequest
  public var currentURL: Foundation.URL {
    get
  }
  public var respondToPingWithPong: Swift.Bool
  public init(request: Foundation.URLRequest, protocols: [Swift.String]? = nil, stream: SalemoveSDK.WSStream = FoundationStream())
  convenience public init(url: Foundation.URL, protocols: [Swift.String]? = nil)
  convenience public init(url: Foundation.URL, writeQueueQOS: Foundation.QualityOfService, protocols: [Swift.String]? = nil)
  open func connect()
  open func disconnect(forceTimeout: Foundation.TimeInterval? = nil, closeCode: Swift.UInt16 = CloseCode.normal.rawValue)
  open func write(string: Swift.String, completion: (() -> ())? = nil)
  open func write(data: Foundation.Data, completion: (() -> ())? = nil)
  open func write(ping: Foundation.Data, completion: (() -> ())? = nil)
  open func write(pong: Foundation.Data, completion: (() -> ())? = nil)
  public func newBytesInStream()
  public func streamDidError(error: Swift.Error?)
  @objc deinit
  @objc override dynamic public init()
}
public func == (lhs: SalemoveSDK.Node, rhs: SalemoveSDK.Node) -> Swift.Bool
@objc public enum ScreenSharingStatus : Swift.Int {
  case sharing
  case notSharing
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers @objc public class VisitorScreenSharingState : ObjectiveC.NSObject {
  @objc public var status: SalemoveSDK.ScreenSharingStatus {
    get
  }
  @objc public var localScreen: SalemoveSDK.LocalScreen? {
    get
  }
  @objc override dynamic public init()
  @objc deinit
}
public protocol SocketEngineWebsocket : SalemoveSDK.SocketEngineSpec, SalemoveSDK.SocketIOWebSocketDelegate {
  func sendWebSocketMessage(_ str: Swift.String, withType type: SalemoveSDK.SocketEnginePacketType, withData datas: [Foundation.Data])
}
extension SocketEngineWebsocket {
  public func sendWebSocketMessage(_ str: Swift.String, withType type: SalemoveSDK.SocketEnginePacketType, withData datas: [Foundation.Data])
  public func websocketDidReceiveMessage(socket: SalemoveSDK.SocketIOWebSocket, text: Swift.String)
  public func websocketDidReceiveData(socket: SalemoveSDK.SocketIOWebSocket, data: Foundation.Data)
}
@objc public protocol SocketEngineSpec {
  @objc weak var client: SalemoveSDK.SocketEngineClient? { get set }
  @objc var closed: Swift.Bool { get }
  @objc var connected: Swift.Bool { get }
  @objc var connectParams: [Swift.String : Any]? { get set }
  @objc var doubleEncodeUTF8: Swift.Bool { get }
  @objc var cookies: [Foundation.HTTPCookie]? { get }
  @objc var engineQueue: Dispatch.DispatchQueue { get }
  @objc var extraHeaders: [Swift.String : Swift.String]? { get }
  @objc var fastUpgrade: Swift.Bool { get }
  @objc var forcePolling: Swift.Bool { get }
  @objc var forceWebsockets: Swift.Bool { get }
  @objc var polling: Swift.Bool { get }
  @objc var probing: Swift.Bool { get }
  @objc var sid: Swift.String { get }
  @objc var socketPath: Swift.String { get }
  @objc var urlPolling: Foundation.URL { get }
  @objc var urlWebSocket: Foundation.URL { get }
  @objc var websocket: Swift.Bool { get }
  @objc var ws: SalemoveSDK.SocketIOWebSocket? { get }
  @objc init(client: SalemoveSDK.SocketEngineClient, url: Foundation.URL, options: Foundation.NSDictionary?)
  @objc func connect()
  @objc func didError(reason: Swift.String)
  @objc func disconnect(reason: Swift.String)
  @objc func doFastUpgrade()
  @objc func flushWaitingForPostToWebSocket()
  @objc func parseEngineData(_ data: Foundation.Data)
  @objc func parseEngineMessage(_ message: Swift.String, fromPolling: Swift.Bool)
  @objc func write(_ msg: Swift.String, withType type: SalemoveSDK.SocketEnginePacketType, withData data: [Foundation.Data])
}
@_hasMissingDesignatedInitializers open class SVGSerializer {
  open class func serialize(node: SalemoveSDK.Node, width: Swift.Int? = nil, height: Swift.Int? = nil, id: Swift.String? = nil) -> Swift.String
  @objc deinit
}
@_inheritsConvenienceInitializers open class AlphaEffect : SalemoveSDK.Effect {
  override public init(input: SalemoveSDK.Effect?)
  @objc deinit
}
public typealias MoyaMethod = SalemoveSDK.AlamofireHTTPMethod
public typealias ParameterEncoding = SalemoveSDK.AlamofireParameterEncoding
public typealias JSONEncoding = SalemoveSDK.AlamofireJSONEncoding
public typealias URLEncoding = SalemoveSDK.AlamofireURLEncoding
public typealias RequestMultipartFormData = SalemoveSDK.AlamofireMultipartFormData
public typealias DownloadDestination = SalemoveSDK.AlamofireDownloadRequest.Destination
extension AlamofireRequest : SalemoveSDK.RequestType {
  public var sessionHeaders: [Swift.String : Swift.String] {
    get
  }
}
public typealias RequestInterceptor = SalemoveSDK.AlamofireRequestInterceptor
@_hasMissingDesignatedInitializers final public class CancellableToken : SalemoveSDK.Cancellable, Swift.CustomDebugStringConvertible {
  final public var isCancelled: Swift.Bool {
    get
  }
  final public func cancel()
  public init(action: @escaping () -> Swift.Void)
  final public var debugDescription: Swift.String {
    get
  }
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers @objcMembers public class Engagement : ObjectiveC.NSObject {
  @objc final public let id: Swift.String
  @objc final public let engagedOperator: SalemoveSDK.Operator?
  @objc override dynamic public init()
  @objc deinit
}
@_hasMissingDesignatedInitializers open class PinchEvent : SalemoveSDK.MacawEvent {
  final public let scale: Swift.Double
  @objc deinit
}
public typealias AFResult<Success> = Swift.Result<Success, SalemoveSDK.AFError>
public typealias AFDataResponse<Success> = SalemoveSDK.DataResponse<Success, SalemoveSDK.AFError>
public typealias AFDownloadResponse<Success> = SalemoveSDK.DownloadResponse<Success, SalemoveSDK.AFError>
public struct DataResponse<Success, Failure> where Failure : Swift.Error {
  public let request: Foundation.URLRequest?
  public let response: Foundation.HTTPURLResponse?
  public let data: Foundation.Data?
  public let metrics: Foundation.URLSessionTaskMetrics?
  public let serializationDuration: Foundation.TimeInterval
  public let result: Swift.Result<Success, Failure>
  public var value: Success? {
    get
  }
  public var error: Failure? {
    get
  }
  public init(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, data: Foundation.Data?, metrics: Foundation.URLSessionTaskMetrics?, serializationDuration: Foundation.TimeInterval, result: Swift.Result<Success, Failure>)
}
extension DataResponse : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension DataResponse {
  public func map<NewSuccess>(_ transform: (Success) -> NewSuccess) -> SalemoveSDK.DataResponse<NewSuccess, Failure>
  public func tryMap<NewSuccess>(_ transform: (Success) throws -> NewSuccess) -> SalemoveSDK.DataResponse<NewSuccess, Swift.Error>
  public func mapError<NewFailure>(_ transform: (Failure) -> NewFailure) -> SalemoveSDK.DataResponse<Success, NewFailure> where NewFailure : Swift.Error
  public func tryMapError<NewFailure>(_ transform: (Failure) throws -> NewFailure) -> SalemoveSDK.DataResponse<Success, Swift.Error> where NewFailure : Swift.Error
}
public struct DownloadResponse<Success, Failure> where Failure : Swift.Error {
  public let request: Foundation.URLRequest?
  public let response: Foundation.HTTPURLResponse?
  public let fileURL: Foundation.URL?
  public let resumeData: Foundation.Data?
  public let metrics: Foundation.URLSessionTaskMetrics?
  public let serializationDuration: Foundation.TimeInterval
  public let result: Swift.Result<Success, Failure>
  public var value: Success? {
    get
  }
  public var error: Failure? {
    get
  }
  public init(request: Foundation.URLRequest?, response: Foundation.HTTPURLResponse?, fileURL: Foundation.URL?, resumeData: Foundation.Data?, metrics: Foundation.URLSessionTaskMetrics?, serializationDuration: Foundation.TimeInterval, result: Swift.Result<Success, Failure>)
}
extension DownloadResponse : Swift.CustomStringConvertible, Swift.CustomDebugStringConvertible {
  public var description: Swift.String {
    get
  }
  public var debugDescription: Swift.String {
    get
  }
}
extension DownloadResponse {
  public func map<NewSuccess>(_ transform: (Success) -> NewSuccess) -> SalemoveSDK.DownloadResponse<NewSuccess, Failure>
  public func tryMap<NewSuccess>(_ transform: (Success) throws -> NewSuccess) -> SalemoveSDK.DownloadResponse<NewSuccess, Swift.Error>
  public func mapError<NewFailure>(_ transform: (Failure) -> NewFailure) -> SalemoveSDK.DownloadResponse<Success, NewFailure> where NewFailure : Swift.Error
  public func tryMapError<NewFailure>(_ transform: (Failure) throws -> NewFailure) -> SalemoveSDK.DownloadResponse<Success, Swift.Error> where NewFailure : Swift.Error
}
extension Signal {
  public enum Event {
    case value(Value)
    case failed(Error)
    case completed
    case interrupted
    public var isCompleted: Swift.Bool {
      get
    }
    public var isTerminating: Swift.Bool {
      get
    }
    public func map<U>(_ f: (Value) -> U) -> SalemoveSDK.Signal<U, Error>.Event
    public func mapError<F>(_ f: (Error) -> F) -> SalemoveSDK.Signal<Value, F>.Event where F : Swift.Error
    public var value: Value? {
      get
    }
    public var error: Error? {
      get
    }
  }
}
extension Signal.Event where Value : Swift.Equatable, Error : Swift.Equatable {
  public static func == (lhs: SalemoveSDK.Signal<Value, Error>.Event, rhs: SalemoveSDK.Signal<Value, Error>.Event) -> Swift.Bool
}
extension Signal.Event : Swift.Equatable where Value : Swift.Equatable, Error : Swift.Equatable {
}
extension Signal.Event : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public protocol EventProtocol {
  associatedtype Value
  associatedtype Error : Swift.Error
  var event: SalemoveSDK.Signal<Self.Value, Self.Error>.Event { get }
}
extension Signal.Event : SalemoveSDK.EventProtocol {
  public var event: SalemoveSDK.Signal<Value, Error>.Event {
    get
  }
}
public enum PathSegmentType {
  case M
  case L
  case C
  case Q
  case A
  case z
  case H
  case V
  case S
  case T
  case m
  case l
  case c
  case q
  case a
  case h
  case v
  case s
  case t
  case E
  case e
  public static func == (a: SalemoveSDK.PathSegmentType, b: SalemoveSDK.PathSegmentType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers public class AlamofireRequest {
  public enum State {
    case initialized
    case resumed
    case suspended
    case cancelled
    case finished
    public static func == (a: SalemoveSDK.AlamofireRequest.State, b: SalemoveSDK.AlamofireRequest.State) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  final public let id: Foundation.UUID
  final public let underlyingQueue: Dispatch.DispatchQueue
  final public let serializationQueue: Dispatch.DispatchQueue
  final public let eventMonitor: SalemoveSDK.EventMonitor?
  final public let interceptor: SalemoveSDK.AlamofireRequestInterceptor?
  weak public var delegate: SalemoveSDK.RequestDelegate? {
    get
  }
  public var state: SalemoveSDK.AlamofireRequest.State {
    get
  }
  public var isInitialized: Swift.Bool {
    get
  }
  public var isResumed: Swift.Bool {
    get
  }
  public var isSuspended: Swift.Bool {
    get
  }
  public var isCancelled: Swift.Bool {
    get
  }
  public var isFinished: Swift.Bool {
    get
  }
  public typealias ProgressHandler = (Foundation.Progress) -> Swift.Void
  final public let uploadProgress: Foundation.Progress
  final public let downloadProgress: Foundation.Progress
  public var redirectHandler: SalemoveSDK.RedirectHandler? {
    get
  }
  public var cachedResponseHandler: SalemoveSDK.CachedResponseHandler? {
    get
  }
  public var credential: Foundation.URLCredential? {
    get
  }
  public var requests: [Foundation.URLRequest] {
    get
  }
  public var firstRequest: Foundation.URLRequest? {
    get
  }
  public var lastRequest: Foundation.URLRequest? {
    get
  }
  public var request: Foundation.URLRequest? {
    get
  }
  public var performedRequests: [Foundation.URLRequest] {
    get
  }
  public var response: Foundation.HTTPURLResponse? {
    get
  }
  public var tasks: [Foundation.URLSessionTask] {
    get
  }
  public var firstTask: Foundation.URLSessionTask? {
    get
  }
  public var lastTask: Foundation.URLSessionTask? {
    get
  }
  public var task: Foundation.URLSessionTask? {
    get
  }
  public var allMetrics: [Foundation.URLSessionTaskMetrics] {
    get
  }
  public var firstMetrics: Foundation.URLSessionTaskMetrics? {
    get
  }
  public var lastMetrics: Foundation.URLSessionTaskMetrics? {
    get
  }
  public var metrics: Foundation.URLSessionTaskMetrics? {
    get
  }
  public var retryCount: Swift.Int {
    get
  }
  public var error: SalemoveSDK.AFError? {
    get
  }
  @discardableResult
  public func cancel() -> Self
  @discardableResult
  public func suspend() -> Self
  @discardableResult
  public func resume() -> Self
  @discardableResult
  public func authenticate(username: Swift.String, password: Swift.String, persistence: Foundation.URLCredential.Persistence = .forSession) -> Self
  @discardableResult
  public func authenticate(with credential: Foundation.URLCredential) -> Self
  @discardableResult
  public func downloadProgress(queue: Dispatch.DispatchQueue = .main, closure: @escaping SalemoveSDK.AlamofireRequest.ProgressHandler) -> Self
  @discardableResult
  public func uploadProgress(queue: Dispatch.DispatchQueue = .main, closure: @escaping SalemoveSDK.AlamofireRequest.ProgressHandler) -> Self
  @discardableResult
  public func redirect(using handler: SalemoveSDK.RedirectHandler) -> Self
  @discardableResult
  public func cacheResponse(using handler: SalemoveSDK.CachedResponseHandler) -> Self
  @discardableResult
  public func cURLDescription(on queue: Dispatch.DispatchQueue, calling handler: @escaping (Swift.String) -> Swift.Void) -> Self
  @discardableResult
  public func cURLDescription(calling handler: @escaping (Swift.String) -> Swift.Void) -> Self
  @discardableResult
  public func onURLRequestCreation(on queue: Dispatch.DispatchQueue = .main, perform handler: @escaping (Foundation.URLRequest) -> Swift.Void) -> Self
  @discardableResult
  public func onURLSessionTaskCreation(on queue: Dispatch.DispatchQueue = .main, perform handler: @escaping (Foundation.URLSessionTask) -> Swift.Void) -> Self
  @objc deinit
}
extension AlamofireRequest : Swift.Equatable {
  public static func == (lhs: SalemoveSDK.AlamofireRequest, rhs: SalemoveSDK.AlamofireRequest) -> Swift.Bool
}
extension AlamofireRequest : Swift.Hashable {
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension AlamofireRequest : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension AlamofireRequest {
  public func cURLDescription() -> Swift.String
}
public protocol RequestDelegate : AnyObject {
  var sessionConfiguration: Foundation.URLSessionConfiguration { get }
  var startImmediately: Swift.Bool { get }
  func cleanup(after request: SalemoveSDK.AlamofireRequest)
  func retryResult(for request: SalemoveSDK.AlamofireRequest, dueTo error: SalemoveSDK.AFError, completion: @escaping (SalemoveSDK.RetryResult) -> Swift.Void)
  func retryRequest(_ request: SalemoveSDK.AlamofireRequest, withDelay timeDelay: Foundation.TimeInterval?)
}
@_hasMissingDesignatedInitializers public class AlamofireDataRequest : SalemoveSDK.AlamofireRequest {
  final public let convertible: SalemoveSDK.AlamofireURLRequestConvertible
  public var data: Foundation.Data? {
    get
  }
  @discardableResult
  public func validate(_ validation: @escaping SalemoveSDK.AlamofireDataRequest.Validation) -> Self
  @objc deinit
}
@_hasMissingDesignatedInitializers final public class DataStreamRequest : SalemoveSDK.AlamofireRequest {
  public typealias Handler<Success, Failure> = (SalemoveSDK.DataStreamRequest.Stream<Success, Failure>) throws -> Swift.Void where Failure : Swift.Error
  public struct Stream<Success, Failure> where Failure : Swift.Error {
    public let event: SalemoveSDK.DataStreamRequest.Event<Success, Failure>
    public let token: SalemoveSDK.DataStreamRequest.CancellationToken
    public func cancel()
  }
  public enum Event<Success, Failure> where Failure : Swift.Error {
    case stream(Swift.Result<Success, Failure>)
    case complete(SalemoveSDK.DataStreamRequest.Completion)
  }
  public struct Completion {
    public let request: Foundation.URLRequest?
    public let response: Foundation.HTTPURLResponse?
    public let metrics: Foundation.URLSessionTaskMetrics?
    public let error: SalemoveSDK.AFError?
  }
  public struct CancellationToken {
    public func cancel()
  }
  final public let convertible: SalemoveSDK.AlamofireURLRequestConvertible
  final public let automaticallyCancelOnStreamError: Swift.Bool
  @discardableResult
  final public func validate(_ validation: @escaping SalemoveSDK.DataStreamRequest.Validation) -> Self
  final public func asInputStream(bufferSize: Swift.Int = 1024) -> Foundation.InputStream?
  @objc deinit
}
extension DataStreamRequest.Stream {
  public var result: Swift.Result<Success, Failure>? {
    get
  }
  public var value: Success? {
    get
  }
  public var error: Failure? {
    get
  }
  public var completion: SalemoveSDK.DataStreamRequest.Completion? {
    get
  }
}
@_hasMissingDesignatedInitializers public class AlamofireDownloadRequest : SalemoveSDK.AlamofireRequest {
  public struct Options : Swift.OptionSet {
    public static let createIntermediateDirectories: SalemoveSDK.AlamofireDownloadRequest.Options
    public static let removePreviousFile: SalemoveSDK.AlamofireDownloadRequest.Options
    public let rawValue: Swift.Int
    public init(rawValue: Swift.Int)
    public typealias ArrayLiteralElement = SalemoveSDK.AlamofireDownloadRequest.Options
    public typealias Element = SalemoveSDK.AlamofireDownloadRequest.Options
    public typealias RawValue = Swift.Int
  }
  public typealias Destination = (Foundation.URL, Foundation.HTTPURLResponse) -> (destinationURL: Foundation.URL, options: SalemoveSDK.AlamofireDownloadRequest.Options)
  public class func suggestedDownloadDestination(for directory: Foundation.FileManager.SearchPathDirectory = .documentDirectory, in domain: Foundation.FileManager.SearchPathDomainMask = .userDomainMask, options: SalemoveSDK.AlamofireDownloadRequest.Options = []) -> SalemoveSDK.AlamofireDownloadRequest.Destination
  public enum Downloadable {
    case request(SalemoveSDK.AlamofireURLRequestConvertible)
    case resumeData(Foundation.Data)
  }
  public var resumeData: Foundation.Data? {
    get
  }
  public var fileURL: Foundation.URL? {
    get
  }
  final public let downloadable: SalemoveSDK.AlamofireDownloadRequest.Downloadable
  public func task(forResumeData data: Foundation.Data, using session: Foundation.URLSession) -> Foundation.URLSessionTask
  @discardableResult
  override public func cancel() -> Self
  @discardableResult
  public func cancel(producingResumeData shouldProduceResumeData: Swift.Bool) -> Self
  @discardableResult
  public func cancel(byProducingResumeData completionHandler: @escaping (Foundation.Data?) -> Swift.Void) -> Self
  @discardableResult
  public func validate(_ validation: @escaping SalemoveSDK.AlamofireDownloadRequest.Validation) -> Self
  @objc deinit
}
@_hasMissingDesignatedInitializers public class AlamofireUploadRequest : SalemoveSDK.AlamofireDataRequest {
  public enum Uploadable {
    case data(Foundation.Data)
    case file(Foundation.URL, shouldRemove: Swift.Bool)
    case stream(Foundation.InputStream)
  }
  final public let upload: SalemoveSDK.UploadableConvertible
  final public let fileManager: Foundation.FileManager
  public var uploadable: SalemoveSDK.AlamofireUploadRequest.Uploadable?
  public func cleanup()
  @objc deinit
}
public protocol UploadableConvertible {
  func createUploadable() throws -> SalemoveSDK.AlamofireUploadRequest.Uploadable
}
extension AlamofireUploadRequest.Uploadable : SalemoveSDK.UploadableConvertible {
  public func createUploadable() throws -> SalemoveSDK.AlamofireUploadRequest.Uploadable
}
public protocol UploadConvertible : SalemoveSDK.AlamofireURLRequestConvertible, SalemoveSDK.UploadableConvertible {
}
extension URLSessionConfiguration : SalemoveSDK.AlamofireExtended {
  public typealias ExtendedType = Foundation.URLSessionConfiguration
}
extension AlamofireExtension where ExtendedType : Foundation.URLSessionConfiguration {
  public static var `default`: Foundation.URLSessionConfiguration {
    get
  }
}
@objc public class MediaUpgradeOffer : ObjectiveC.NSObject {
  final public let type: SalemoveSDK.MediaType
  final public let direction: SalemoveSDK.MediaDirection
  public init(type: SalemoveSDK.MediaType, direction: SalemoveSDK.MediaDirection) throws
  @objc override dynamic public init()
  @objc deinit
}
public enum MediaDirection : Swift.String {
  case oneWay
  case twoWay
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public protocol Scheduler : AnyObject {
  @discardableResult
  func schedule(_ action: @escaping () -> Swift.Void) -> SalemoveSDK.Disposable?
}
public protocol DateScheduler : SalemoveSDK.Scheduler {
  var currentDate: Foundation.Date { get }
  @discardableResult
  func schedule(after date: Foundation.Date, action: @escaping () -> Swift.Void) -> SalemoveSDK.Disposable?
  @discardableResult
  func schedule(after date: Foundation.Date, interval: Dispatch.DispatchTimeInterval, leeway: Dispatch.DispatchTimeInterval, action: @escaping () -> Swift.Void) -> SalemoveSDK.Disposable?
}
final public class ImmediateScheduler : SalemoveSDK.Scheduler {
  public init()
  @discardableResult
  final public func schedule(_ action: @escaping () -> Swift.Void) -> SalemoveSDK.Disposable?
  @objc deinit
}
final public class UIScheduler : SalemoveSDK.Scheduler {
  @objc deinit
  public init()
  @discardableResult
  final public func schedule(_ action: @escaping () -> Swift.Void) -> SalemoveSDK.Disposable?
}
@_hasMissingDesignatedInitializers final public class QueueScheduler : SalemoveSDK.DateScheduler {
  public static let main: SalemoveSDK.QueueScheduler
  final public var currentDate: Foundation.Date {
    get
  }
  final public let queue: Dispatch.DispatchQueue
  @available(macOS, deprecated: 10.10, obsoleted: 10.11, message: "Use init(qos:name:targeting:) instead")
  @available(iOS, deprecated: 8.0, obsoleted: 9.0, message: "Use init(qos:name:targeting:) instead.")
  convenience public init(queue: Dispatch.DispatchQueue, name: Swift.String = "org.reactivecocoa.ReactiveSwift.QueueScheduler")
  @available(macOS 10.10, *)
  convenience public init(qos: Dispatch.DispatchQoS = .default, name: Swift.String = "org.reactivecocoa.ReactiveSwift.QueueScheduler", targeting targetQueue: Dispatch.DispatchQueue? = nil)
  @discardableResult
  final public func schedule(_ action: @escaping () -> Swift.Void) -> SalemoveSDK.Disposable?
  @discardableResult
  final public func schedule(after date: Foundation.Date, action: @escaping () -> Swift.Void) -> SalemoveSDK.Disposable?
  @discardableResult
  final public func schedule(after date: Foundation.Date, interval: Dispatch.DispatchTimeInterval, action: @escaping () -> Swift.Void) -> SalemoveSDK.Disposable?
  @discardableResult
  final public func schedule(after date: Foundation.Date, interval: Dispatch.DispatchTimeInterval, leeway: Dispatch.DispatchTimeInterval, action: @escaping () -> Swift.Void) -> SalemoveSDK.Disposable?
  @objc deinit
}
final public class TestScheduler : SalemoveSDK.DateScheduler {
  final public var currentDate: Foundation.Date {
    get
  }
  public init(startDate: Foundation.Date = Date(timeIntervalSinceReferenceDate: 0))
  @discardableResult
  final public func schedule(_ action: @escaping () -> Swift.Void) -> SalemoveSDK.Disposable?
  @discardableResult
  final public func schedule(after delay: Dispatch.DispatchTimeInterval, action: @escaping () -> Swift.Void) -> SalemoveSDK.Disposable?
  @discardableResult
  final public func schedule(after date: Foundation.Date, action: @escaping () -> Swift.Void) -> SalemoveSDK.Disposable?
  @discardableResult
  final public func schedule(after delay: Dispatch.DispatchTimeInterval, interval: Dispatch.DispatchTimeInterval, leeway: Dispatch.DispatchTimeInterval = .seconds(0), action: @escaping () -> Swift.Void) -> SalemoveSDK.Disposable?
  final public func schedule(after date: Foundation.Date, interval: Dispatch.DispatchTimeInterval, leeway: Dispatch.DispatchTimeInterval = .seconds(0), action: @escaping () -> Swift.Void) -> SalemoveSDK.Disposable?
  final public func advance()
  final public func advance(by interval: Dispatch.DispatchTimeInterval)
  final public func advance(to newDate: Foundation.Date)
  final public func run()
  final public func rewind(by interval: Dispatch.DispatchTimeInterval)
  @objc deinit
}
public enum NetworkActivityChangeType {
  case began, ended
  public static func == (a: SalemoveSDK.NetworkActivityChangeType, b: SalemoveSDK.NetworkActivityChangeType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
final public class NetworkActivityPlugin : SalemoveSDK.PluginType {
  public typealias NetworkActivityClosure = (SalemoveSDK.NetworkActivityChangeType, SalemoveSDK.TargetType) -> Swift.Void
  public init(networkActivityClosure: @escaping SalemoveSDK.NetworkActivityPlugin.NetworkActivityClosure)
  final public func willSend(_ request: SalemoveSDK.RequestType, target: SalemoveSDK.TargetType)
  final public func didReceive(_ result: Swift.Result<SalemoveSDK.MoyaResponse, SalemoveSDK.MoyaError>, target: SalemoveSDK.TargetType)
  @objc deinit
}
extension URL {
  public init<T>(target: T) where T : SalemoveSDK.TargetType
}
open class GaussianBlur : SalemoveSDK.Effect {
  final public let r: Swift.Double
  public init(r: Swift.Double = 0, input: SalemoveSDK.Effect? = nil)
  override public init(input: SalemoveSDK.Effect?)
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers final public class SocketAckEmitter : ObjectiveC.NSObject {
  final public var expected: Swift.Bool {
    get
  }
  final public func with(_ items: SalemoveSDK.SocketData...)
  final public func with(_ items: [Any])
  @objc override dynamic public init()
  @objc deinit
}
@objc @_hasMissingDesignatedInitializers final public class OnAckCallback : ObjectiveC.NSObject {
  @objc deinit
  final public func timingOut(after seconds: Swift.Int, callback: @escaping SalemoveSDK.AckCallback)
  @objc override dynamic public init()
}
extension SalemoveSDK.AttachmentType : Swift.Equatable {}
extension SalemoveSDK.AttachmentType : Swift.Hashable {}
extension SalemoveSDK.AttachmentType : Swift.RawRepresentable {}
extension SalemoveSDK.URLEncodedFormEncoder.ArrayEncoding : Swift.Equatable {}
extension SalemoveSDK.URLEncodedFormEncoder.ArrayEncoding : Swift.Hashable {}
extension SalemoveSDK.URLEncodedFormEncoder.BoolEncoding : Swift.Equatable {}
extension SalemoveSDK.URLEncodedFormEncoder.BoolEncoding : Swift.Hashable {}
extension SalemoveSDK.URLEncodedFormEncoder.SpaceEncoding : Swift.Equatable {}
extension SalemoveSDK.URLEncodedFormEncoder.SpaceEncoding : Swift.Hashable {}
extension SalemoveSDK.PushNotificationType : Swift.Equatable {}
extension SalemoveSDK.PushNotificationType : Swift.Hashable {}
extension SalemoveSDK.PushNotificationType : Swift.RawRepresentable {}
extension SalemoveSDK.Relativity : Swift.Equatable {}
extension SalemoveSDK.Relativity : Swift.Hashable {}
extension SalemoveSDK.Presence.Events : Swift.Equatable {}
extension SalemoveSDK.Presence.Events : Swift.Hashable {}
extension SalemoveSDK.Presence.Events : Swift.RawRepresentable {}
extension SalemoveSDK.LineJoin : Swift.Equatable {}
extension SalemoveSDK.LineJoin : Swift.Hashable {}
extension SalemoveSDK.MessageSender : Swift.Equatable {}
extension SalemoveSDK.MessageSender : Swift.Hashable {}
extension SalemoveSDK.SocketIOClientStatus : Swift.Equatable {}
extension SalemoveSDK.SocketIOClientStatus : Swift.Hashable {}
extension SalemoveSDK.SocketIOClientStatus : Swift.RawRepresentable {}
extension SalemoveSDK.SocketIOWebSocket.CloseCode : Swift.Equatable {}
extension SalemoveSDK.SocketIOWebSocket.CloseCode : Swift.Hashable {}
extension SalemoveSDK.SocketIOWebSocket.CloseCode : Swift.RawRepresentable {}
extension SalemoveSDK.ChannelState : Swift.Equatable {}
extension SalemoveSDK.ChannelState : Swift.Hashable {}
extension SalemoveSDK.ChannelState : Swift.RawRepresentable {}
extension SalemoveSDK.AnimationState : Swift.Equatable {}
extension SalemoveSDK.AnimationState : Swift.Hashable {}
extension SalemoveSDK.SocketIOClientOption : Swift.Equatable {}
extension SalemoveSDK.SocketIOClientOption : Swift.CustomStringConvertible {}
extension SalemoveSDK.LineCap : Swift.Equatable {}
extension SalemoveSDK.LineCap : Swift.Hashable {}
extension SalemoveSDK.Baseline : Swift.Equatable {}
extension SalemoveSDK.Baseline : Swift.Hashable {}
extension SalemoveSDK.ContextType : Swift.Equatable {}
extension SalemoveSDK.ContextType : Swift.Hashable {}
extension SalemoveSDK.ContextType : Swift.RawRepresentable {}
extension SalemoveSDK.URLEncodedFormParameterEncoder.Destination : Swift.Equatable {}
extension SalemoveSDK.URLEncodedFormParameterEncoder.Destination : Swift.Hashable {}
extension SalemoveSDK.MediaType : Swift.Equatable {}
extension SalemoveSDK.MediaType : Swift.Hashable {}
extension SalemoveSDK.MediaType : Swift.RawRepresentable {}
extension SalemoveSDK.PushType : Swift.Equatable {}
extension SalemoveSDK.PushType : Swift.Hashable {}
extension SalemoveSDK.PushType : Swift.RawRepresentable {}
extension SalemoveSDK.SocketClientEvent : Swift.Equatable {}
extension SalemoveSDK.SocketClientEvent : Swift.Hashable {}
extension SalemoveSDK.SocketClientEvent : Swift.RawRepresentable {}
extension SalemoveSDK.AlamofireURLEncoding.Destination : Swift.Equatable {}
extension SalemoveSDK.AlamofireURLEncoding.Destination : Swift.Hashable {}
extension SalemoveSDK.AlamofireURLEncoding.ArrayEncoding : Swift.Equatable {}
extension SalemoveSDK.AlamofireURLEncoding.ArrayEncoding : Swift.Hashable {}
extension SalemoveSDK.AlamofireURLEncoding.BoolEncoding : Swift.Equatable {}
extension SalemoveSDK.AlamofireURLEncoding.BoolEncoding : Swift.Hashable {}
extension SalemoveSDK.FillRule : Swift.Equatable {}
extension SalemoveSDK.FillRule : Swift.Hashable {}
extension SalemoveSDK.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType : Swift.Equatable {}
extension SalemoveSDK.NetworkReachabilityManager.NetworkReachabilityStatus.ConnectionType : Swift.Hashable {}
extension SalemoveSDK.VideoScalingOptions : Swift.Equatable {}
extension SalemoveSDK.VideoScalingOptions : Swift.Hashable {}
extension SalemoveSDK.VideoScalingOptions : Swift.RawRepresentable {}
extension SalemoveSDK.LogLevel : Swift.Equatable {}
extension SalemoveSDK.LogLevel : Swift.Hashable {}
extension SalemoveSDK.LogLevel : Swift.RawRepresentable {}
extension SalemoveSDK.GeneralError : Swift.Equatable {}
extension SalemoveSDK.GeneralError : Swift.Hashable {}
extension SalemoveSDK.GeneralError : Swift.RawRepresentable {}
extension SalemoveSDK.ContextError : Swift.Equatable {}
extension SalemoveSDK.ContextError : Swift.Hashable {}
extension SalemoveSDK.ContextError : Swift.RawRepresentable {}
extension SalemoveSDK.ConfigurationError : Swift.Equatable {}
extension SalemoveSDK.ConfigurationError : Swift.Hashable {}
extension SalemoveSDK.ConfigurationError : Swift.RawRepresentable {}
extension SalemoveSDK.MediaUpgradeError : Swift.Equatable {}
extension SalemoveSDK.MediaUpgradeError : Swift.Hashable {}
extension SalemoveSDK.MediaUpgradeError : Swift.RawRepresentable {}
extension SalemoveSDK.EngagementError : Swift.Equatable {}
extension SalemoveSDK.EngagementError : Swift.Hashable {}
extension SalemoveSDK.EngagementError : Swift.RawRepresentable {}
extension SalemoveSDK.MediaError : Swift.Equatable {}
extension SalemoveSDK.MediaError : Swift.Hashable {}
extension SalemoveSDK.MediaError : Swift.RawRepresentable {}
extension SalemoveSDK.QueueError : Swift.Equatable {}
extension SalemoveSDK.QueueError : Swift.Hashable {}
extension SalemoveSDK.QueueError : Swift.RawRepresentable {}
extension SalemoveSDK.FileError : Swift.Equatable {}
extension SalemoveSDK.FileError : Swift.Hashable {}
extension SalemoveSDK.FileError : Swift.RawRepresentable {}
extension SalemoveSDK.QueueStatus : Swift.Equatable {}
extension SalemoveSDK.QueueStatus : Swift.Hashable {}
extension SalemoveSDK.QueueStatus : Swift.RawRepresentable {}
extension SalemoveSDK.AuthenticationError : Swift.Equatable {}
extension SalemoveSDK.AuthenticationError : Swift.Hashable {}
extension SalemoveSDK.LoggingEvent.Signal : Swift.Equatable {}
extension SalemoveSDK.LoggingEvent.Signal : Swift.Hashable {}
extension SalemoveSDK.LoggingEvent.Signal : Swift.RawRepresentable {}
extension SalemoveSDK.LoggingEvent.SignalProducer : Swift.Equatable {}
extension SalemoveSDK.LoggingEvent.SignalProducer : Swift.Hashable {}
extension SalemoveSDK.LoggingEvent.SignalProducer : Swift.RawRepresentable {}
extension SalemoveSDK.SocketAckStatus : Swift.Equatable {}
extension SalemoveSDK.SocketAckStatus : Swift.Hashable {}
extension SalemoveSDK.SocketAckStatus : Swift.RawRepresentable {}
extension SalemoveSDK.SocketEnginePacketType : Swift.Equatable {}
extension SalemoveSDK.SocketEnginePacketType : Swift.Hashable {}
extension SalemoveSDK.SocketEnginePacketType : Swift.RawRepresentable {}
extension SalemoveSDK.CloseCode : Swift.Equatable {}
extension SalemoveSDK.CloseCode : Swift.Hashable {}
extension SalemoveSDK.CloseCode : Swift.RawRepresentable {}
extension SalemoveSDK.ErrorType : Swift.Equatable {}
extension SalemoveSDK.ErrorType : Swift.Hashable {}
extension SalemoveSDK.WebSocket.OpCode : Swift.Equatable {}
extension SalemoveSDK.WebSocket.OpCode : Swift.Hashable {}
extension SalemoveSDK.WebSocket.OpCode : Swift.RawRepresentable {}
extension SalemoveSDK.ScreenSharingStatus : Swift.Equatable {}
extension SalemoveSDK.ScreenSharingStatus : Swift.Hashable {}
extension SalemoveSDK.ScreenSharingStatus : Swift.RawRepresentable {}
extension SalemoveSDK.PathSegmentType : Swift.Equatable {}
extension SalemoveSDK.PathSegmentType : Swift.Hashable {}
extension SalemoveSDK.AlamofireRequest.State : Swift.Equatable {}
extension SalemoveSDK.AlamofireRequest.State : Swift.Hashable {}
extension SalemoveSDK.MediaDirection : Swift.Equatable {}
extension SalemoveSDK.MediaDirection : Swift.Hashable {}
extension SalemoveSDK.MediaDirection : Swift.RawRepresentable {}
extension SalemoveSDK.NetworkActivityChangeType : Swift.Equatable {}
extension SalemoveSDK.NetworkActivityChangeType : Swift.Hashable {}
