// Generated by Apple Swift version 5.4.2 (swiftlang-1205.0.28.2 clang-1205.0.19.57)
#ifndef SALEMOVESDK_SWIFT_H
#define SALEMOVESDK_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(ns_consumed)
# define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
#else
# define SWIFT_RELEASES_ARGUMENT
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import CoreGraphics;
@import Dispatch;
@import Foundation;
@import ObjectiveC;
@import UIKit;
@import UserNotifications;
@import WebRTC;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="SalemoveSDK",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif


/// Attachment included in a <code>Message</code>.
SWIFT_CLASS("_TtC11SalemoveSDK10Attachment")
@interface Attachment : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// The type of the attachment.
typedef SWIFT_ENUM(NSInteger, AttachmentType, open) {
/// Attachment has files.
  AttachmentTypeFiles = 0,
/// Attachment has a single choice questionnaire.
  AttachmentTypeSingleChoice = 1,
/// Attachment has the response to a single choice questionnaire.
  AttachmentTypeSingleChoiceResponse = 2,
};

@class NSNumber;

/// Audio stream, that can be used to control operator and visitor audio during an engagement
SWIFT_PROTOCOL("_TtP11SalemoveSDK15AudioStreamable_")
@protocol AudioStreamable
/// Play the incoming/outgoing audio stream
- (void)playAudio SWIFT_AVAILABILITY(ios,obsoleted=10.0,message="Audio is now played automatically when media is established");
/// Mute the outgoing audio stream
- (void)mute;
/// Unmute the outgoing audio stream
- (void)unmute;
/// State of the audio stream
///
/// returns:
/// bool indicating if the stream is muted or not
@property (nonatomic, readonly) BOOL isMuted;
/// Source of the audio stream
///
/// returns:
/// bool indicating if the stream is local or remote
@property (nonatomic, readonly) BOOL isRemote;
@end





/// Error of the configuration of the sdk
typedef SWIFT_ENUM(NSInteger, ConfigurationError, open) {
/// The site ID is invalid.
  ConfigurationErrorInvalidSite = 0,
/// The environemnt is invalid.
  ConfigurationErrorInvalidEnvironment = 1,
/// The app token is invalid.
  ConfigurationErrorInvalidAppToken = 2,
/// The api token is invalid.
  ConfigurationErrorInvalidApiToken = 3,
};
static NSString * _Nonnull const ConfigurationErrorDomain = @"SalemoveSDK.ConfigurationError";

/// Error of the visitor context
typedef SWIFT_ENUM(NSInteger, ContextError, open) {
/// The context URL is invalid.
  ContextErrorInvalidURL = 0,
};
static NSString * _Nonnull const ContextErrorDomain = @"SalemoveSDK.ContextError";




SWIFT_CLASS("_TtC11SalemoveSDK8Drawable")
@interface Drawable : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class NSString;
@class Operator;

/// Representation of an engagement in Glia.
SWIFT_CLASS("_TtC11SalemoveSDK10Engagement")
@interface Engagement : NSObject
/// The ID of the engagement.
@property (nonatomic, readonly, copy) NSString * _Nonnull id;
/// The operator that is currently engaged with the visitor.
@property (nonatomic, readonly, strong) Operator * _Nullable engagedOperator;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// Error of the Engagement
typedef SWIFT_ENUM(NSInteger, EngagementError, open) {
/// The Operator is unavailable for an Engagement.
  EngagementErrorOperatorUnavailable = 0,
/// Engagement request timeout.
  EngagementErrorTimeout = 1,
/// Engagement request rejected by the Operator.
  EngagementErrorRejected = 2,
/// Engagment request cancelled by the Visitor.
  EngagementErrorVisitorCanceled = 3,
/// Engagmenet request cancelled by Operator.
  EngagementErrorOperatorCanceled = 4,
/// Engagmenet request aborted by Operator leaving.
  EngagementErrorOperatorLeft = 5,
};
static NSString * _Nonnull const EngagementErrorDomain = @"SalemoveSDK.EngagementError";

@class NSURL;

/// A file that is part of an engagement.
SWIFT_CLASS("_TtC11SalemoveSDK14EngagementFile")
@interface EngagementFile : NSObject
/// ID of the file. Used only when receiving a message.
@property (nonatomic, readonly, copy) NSString * _Nullable id;
/// File mimetype, for example <code>application/pdf</code>. Used only when receiving a message.
@property (nonatomic, readonly, copy) NSString * _Nullable contentType;
/// Name of the file.
@property (nonatomic, readonly, copy) NSString * _Nonnull name;
/// The URL of the file. When downloading, it is the endpoint to be used to retrieve the file,
/// and is nil if <code>isDeleted</code> is true. When uploading, it is the URL of the file in the device.
@property (nonatomic, readonly, copy) NSURL * _Nullable url;
/// Creates an object with information for uploading a file to Glia’s servers.
/// \param name The HTTP body parameter to which the file should be assigned. This value is <code>"content"</code> by default.
///
/// \param url The file’s URL in the device’s internal memory.
///
- (nonnull instancetype)initWithName:(NSString * _Nonnull)name url:(NSURL * _Nonnull)url OBJC_DESIGNATED_INITIALIZER;
/// Creates an object with information for uploading a file to Glia’s servers.
/// \param id The ID of a file.
///
- (nonnull instancetype)initWithId:(NSString * _Nonnull)id OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class NSData;

/// The information about files shared or uploaded during an engagement.
SWIFT_CLASS("_TtC11SalemoveSDK18EngagementFileData")
@interface EngagementFileData : NSObject
/// The data of the file.
@property (nonatomic, readonly, copy) NSData * _Nonnull data;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// The information of a file uploaded during an engagement.
SWIFT_CLASS("_TtC11SalemoveSDK25EngagementFileInformation")
@interface EngagementFileInformation : NSObject
@end


/// The progress of a file upload during the engagement.
SWIFT_CLASS("_TtC11SalemoveSDK22EngagementFileProgress")
@interface EngagementFileProgress : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class VisitorContext;
@class SalemoveError;

/// Basic for interacting with the Engagement
SWIFT_PROTOCOL("_TtP11SalemoveSDK18EngagementHandling_")
@protocol EngagementHandling
/// Engagement request was accepted and interaction can be started
- (void)start;
/// Engagement request / active engagement was closed or declined
- (void)end;
/// Incoming engagement request
/// remark:
///
/// If the request is unsuccessful for any reason then the <code>SuccessBlock</code> inside <code>RequestAnswerBlock</code>  will have an Error.
/// The Error may have one of the following causes:
/// <ul>
///   <li>
///     <code>GeneralError.internalError</code>
///   </li>
///   <li>
///     <code>GeneralError.networkError</code>
///   </li>
///   <li>
///     <code>ContextError.invalidURL</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidSite</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidEnvironment</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidAppToken</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidApiToken</code>
///   </li>
/// </ul>
@property (nonatomic, readonly, copy) void (^ _Nonnull onEngagementRequest)(void (^ _Nonnull)(VisitorContext * _Nonnull, BOOL, void (^ _Nonnull)(BOOL, SalemoveError * _Nullable)));
/// Called after an engagement has been transferred successfully to another operator.
@property (nonatomic, readonly, copy) void (^ _Nonnull onEngagementTransfer)(NSArray<Operator *> * _Nullable);
@end


/// Engagement request sent to an Operator
SWIFT_CLASS("_TtC11SalemoveSDK17EngagementRequest")
@interface EngagementRequest : NSObject
/// The amount of time in seconds the Operator has to respond to this engagement request
@property (nonatomic, readonly) NSInteger timeout;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Basic protocol for selecting an Operator
SWIFT_PROTOCOL("_TtP11SalemoveSDK13ErrorHandling_")
@protocol ErrorHandling
/// Called when there is a failure in the client library or in the Engagement flow
/// The Error may have one of the following causes:
/// <ul>
///   <li>
///     <code>GeneralError.internalError</code> - in the case when there is an internal error
///   </li>
///   <li>
///     <code>EngagementError.timeout</code> - in the case when an Engagement request was not accepted in time by the Operator
///   </li>
///   <li>
///     <code>EngagementError.rejected</code> - in the case when an Engagement request was rejected by the Operator
///   </li>
///   <li>
///     <code>EngagementError.visitorCanceled</code> - in the case when the Visitor cancels an Engagement request
///   </li>
///   <li>
///     <code>EngagementError.operatorCanceled</code> - in the case when Operator cancels an Engagement request
///   </li>
///   <li>
///     <code>EngagementError.operatorLeft</code> - in the case when Operator leaves an active Engagement
///   </li>
/// </ul>
/// \param error the <code>SalemoveError</code>
///
- (void)failWithError:(SalemoveError * _Nonnull)error;
@end

/// Error related to files.
typedef SWIFT_ENUM(NSInteger, FileError, open) {
/// A file uploaded to Glia’s servers has been identified as infected by our security check.
  FileErrorInfected = 0,
/// The file type is unsupported by Glia.
  FileErrorUnsupportedFileType = 1,
/// The file is too big to be uploaded.
  FileErrorFileTooBig = 2,
/// The provided file URL is invalid.
  FileErrorInvalidFileURL = 3,
/// The file is unavailable. For example, the file might have been deleted.
  FileErrorFileUnavailable = 4,
};
static NSString * _Nonnull const FileErrorDomain = @"SalemoveSDK.FileError";

@class NSStream;

SWIFT_CLASS("_TtC11SalemoveSDK16FoundationStream")
@interface FoundationStream : NSObject <NSStreamDelegate>
/// Delegate for the stream methods. Processes incoming bytes
- (void)stream:(NSStream * _Nonnull)aStream handleEvent:(NSStreamEvent)eventCode;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

/// General error of the client library
typedef SWIFT_ENUM(NSInteger, GeneralError, open) {
/// Internal error
  GeneralErrorInternalError = 0,
/// Networking error
  GeneralErrorNetworkError = 1,
};
static NSString * _Nonnull const GeneralErrorDomain = @"SalemoveSDK.GeneralError";


SWIFT_CLASS("_TtC11SalemoveSDK4Node")
@interface Node : Drawable
@property (nonatomic, readonly) NSUInteger hash;
- (BOOL)isEqual:(id _Nullable)object SWIFT_WARN_UNUSED_RESULT;
@end


SWIFT_CLASS("_TtC11SalemoveSDK5Group")
@interface Group : Node
@end


@class MediaUpgradeOffer;
@protocol VideoStreamable;
@class VisitorScreenSharingState;

/// Basic protocol for handling incoming media
SWIFT_PROTOCOL("_TtP11SalemoveSDK13MediaHandling_")
@protocol MediaHandling
/// Handling the incoming media upgrade offer
/// Provide a block that accepts:
/// <ul>
///   <li>
///     <code>offer</code> - an instance of <code>MediaUpgradeOffer</code>
///   </li>
///   <li>
///     <code>answer</code> - a block that must be called with:
///     <ul>
///       <li>
///         <code>accepted</code> - <code>true</code> when the offer is accepted or <code>false</code> when the offer is declined
///       </li>
///       <li>
///         <code>success block</code> - a <code>SuccessBlock</code> that is called with the accept/decline result
///       </li>
///     </ul>
///   </li>
/// </ul>
/// If the accepting/declining is unsuccessful for any reason then <code>SuccessBlock</code> is called with an Error.
/// The Error may have one of the following causes:
/// <ul>
///   <li>
///     <code>GeneralError.networkError</code> - in the case there is a connection issue
///   </li>
///   <li>
///     <code>GeneralError.internalError</code> - in the case when there is an internal error
///   </li>
/// </ul>
@property (nonatomic, readonly, copy) void (^ _Nonnull onMediaUpgradeOffer)(MediaUpgradeOffer * _Nonnull, void (^ _Nonnull)(BOOL, void (^ _Nullable)(BOOL, SalemoveError * _Nullable)));
/// Handling the incoming screen share offer. Screen sharing is not supported on simulators, only on real devices.
@property (nonatomic, readonly, copy) void (^ _Nonnull onScreenSharingOffer)(void (^ _Nonnull)(BOOL));
/// Handling the incoming video stream
/// The Error may have one of the following causes:
/// <ul>
///   <li>
///     <code>GeneralError.internalError</code> - in the case when there is an internal error
///   </li>
///   <li>
///     <code>MediaError.permissionDenied</code> - in the case when the Visitor denies the permission to use the camera to record the video
///   </li>
/// </ul>
@property (nonatomic, readonly, copy) void (^ _Nonnull onVideoStreamAdded)(id <VideoStreamable> _Nullable, SalemoveError * _Nullable);
/// Handling the incoming audio stream
/// The Error may have one of the following causes:
/// <ul>
///   <li>
///     <code>GeneralError.internalError</code> - in the case when there is an internal error
///   </li>
///   <li>
///     <code>MediaError.permissionDenied</code> - in the case when the Visitor denies the permission to record the audio using the microphone
///   </li>
/// </ul>
@property (nonatomic, readonly, copy) void (^ _Nonnull onAudioStreamAdded)(id <AudioStreamable> _Nullable, SalemoveError * _Nullable);
/// Handling the visitor screensharing state changes
/// The Error may have one of the following causes:
/// <ul>
///   <li>
///     <code>GeneralError.internalError</code> - in the case when there is an internal error
///   </li>
///   <li>
///     <code>MediaError.screenSharingNotAvailable</code> - in the case there is an active Screencast, Airplay or Quicktime mirroring enabled on the device
///   </li>
///   <li>
///     <code>MediaError.notAvailableOnIOSVersion</code> - in the case when the deivice is running older iOS version than 11.0
///   </li>
///   <li>
///     <code>MediaError.permissionDenied</code> - in the case when the Visitor denies the permission to record the screen
///   </li>
/// </ul>
@property (nonatomic, readonly, copy) void (^ _Nonnull onVisitorScreenSharingStateChange)(VisitorScreenSharingState * _Nonnull, SalemoveError * _Nullable);
@end

@class Message;
@class OperatorTypingStatus;

/// Basic protocol for handling chat incoming messages
SWIFT_PROTOCOL("_TtP11SalemoveSDK15MessageHandling_")
@protocol MessageHandling
/// Receiving a message from an Operator, or a Visitor in the case the message was successfully delivered
/// after sending it using <code>Salemove.send(message:)</code>.
/// \param message Instance of <code>Message</code>
///
- (void)receiveWithMessage:(Message * _Nonnull)message;
/// Receiving an <code>OperatorTypingStatusUpdate</code> when the Operator starts or stops writing a chat message
@property (nonatomic, readonly, copy) void (^ _Nonnull onOperatorTypingStatusUpdate)(OperatorTypingStatus * _Nonnull);
/// Handling the incoming messages updates that happens when
/// the client library fetches new information on ‘UIApplicationDidBecomeActive’
@property (nonatomic, readonly, copy) void (^ _Nonnull onMessagesUpdated)(NSArray<Message *> * _Nonnull);
@end


/// Basic protocol that requires implementation before passing over to the client library
SWIFT_PROTOCOL("_TtP11SalemoveSDK12Interactable_")
@protocol Interactable <EngagementHandling, ErrorHandling, MediaHandling, MessageHandling>
@end

@class StreamView;

/// LocalScreen provides an ability to stop a screen shared by a Visitor during an Engagement.
SWIFT_CLASS("_TtC11SalemoveSDK11LocalScreen")
@interface LocalScreen : NSObject
/// Stop sharing Visitor screen with Operator
- (void)stopSharing;
/// Access the stream view
///
/// returns:
/// ‘StreamView’ that contains the the screen stream
- (StreamView * _Nonnull)getStreamView SWIFT_WARN_UNUSED_RESULT;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// Available log levels. This can be configured by <code>Salemove.sharedIsntance.configureLogLevel(level: LogLevel)</code>
typedef SWIFT_ENUM(NSInteger, LogLevel, open) {
/// The SDK will not produce any logs
  LogLevelNone = 0,
/// Prints: error
  LogLevelError = 1,
/// Prints: warning, error
  LogLevelWarning = 2,
/// Prints: info, warning, error
  LogLevelInfo = 3,
/// Prints all the logs
  LogLevelDebug = 4,
};

@class UITouch;
@class UIEvent;
@class NSCoder;

SWIFT_CLASS("_TtC11SalemoveSDK5MView")
@interface MView : UIView
- (void)touchesBegan:(NSSet<UITouch *> * _Nonnull)touches withEvent:(UIEvent * _Nullable)event;
- (void)touchesMoved:(NSSet<UITouch *> * _Nonnull)touches withEvent:(UIEvent * _Nullable)event;
- (void)touchesEnded:(NSSet<UITouch *> * _Nonnull)touches withEvent:(UIEvent * _Nullable)event;
- (void)touchesCancelled:(NSSet<UITouch *> * _Nonnull)touches withEvent:(UIEvent * _Nullable)event;
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)coder OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC11SalemoveSDK10MacawImage")
@interface MacawImage : Node
@end

@class UIGestureRecognizer;

/// MacawView is a main class used to embed Macaw scene into your Cocoa UI.
/// You could create your own view extended from MacawView with predefined scene.
SWIFT_CLASS("_TtC11SalemoveSDK9MacawView")
@interface MacawView : MView <UIGestureRecognizerDelegate>
@property (nonatomic) UIViewContentMode contentMode;
@property (nonatomic) CGRect frame;
@property (nonatomic, readonly) CGSize intrinsicContentSize;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder;
- (nullable instancetype)initWithNode:(Node * _Nonnull)node coder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (BOOL)gestureRecognizer:(UIGestureRecognizer * _Nonnull)gestureRecognizer shouldReceiveTouch:(UITouch * _Nonnull)touch SWIFT_WARN_UNUSED_RESULT;
- (BOOL)gestureRecognizer:(UIGestureRecognizer * _Nonnull)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer * _Nonnull)otherGestureRecognizer SWIFT_WARN_UNUSED_RESULT;
@end


/// Error of the media
typedef SWIFT_ENUM(NSInteger, MediaError, open) {
/// When the user has explicitly denied the permission to work with the media
  MediaErrorPermissionDenied = 0,
/// When there is an active screensharing session but does not allow screensharing to start
  MediaErrorScreenSharingNotAvailable = 1,
/// When the Visitor is using an older iOS version that 11.0
  MediaErrorNotAvailableOnIOSVersion = 2,
};
static NSString * _Nonnull const MediaErrorDomain = @"SalemoveSDK.MediaError";


/// Error of the media upgrade request
typedef SWIFT_ENUM(NSInteger, MediaUpgradeError, open) {
/// Upgrade to requested media failed.
  MediaUpgradeErrorRequestError = 0,
/// Received unexpected arguments or unexpected response from server.
  MediaUpgradeErrorUnsupportedRequest = 1,
};
static NSString * _Nonnull const MediaUpgradeErrorDomain = @"SalemoveSDK.MediaUpgradeError";


/// MediaUpgradeOffer object sent by the client library
SWIFT_CLASS("_TtC11SalemoveSDK17MediaUpgradeOffer")
@interface MediaUpgradeOffer : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



/// Chat message sent by an Operator or a Visitor
SWIFT_CLASS("_TtC11SalemoveSDK7Message")
@interface Message : NSObject
/// Identifier of the message. This identifier can be used to track a single message.
@property (nonatomic, readonly, copy) NSString * _Nonnull id;
/// Content of the message
@property (nonatomic, readonly, copy) NSString * _Nonnull content;
/// Attachment
@property (nonatomic, readonly, strong) Attachment * _Nullable attachment;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end















/// A class that represents an emit that will request an ack that has not yet been sent.
/// Call <code>timingOut(after:callback:)</code> to complete the emit
/// Example:
/// \code
/// socket.emitWithAck("myEvent").timingOut(after: 1) {data in
///     ...
/// }
///
/// \endcode
SWIFT_CLASS("_TtC11SalemoveSDK13OnAckCallback")
@interface OnAckCallback : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


@class OperatorPicture;

/// An Operator for an Engagement
SWIFT_CLASS("_TtC11SalemoveSDK8Operator")
@interface Operator : NSObject
/// Operator name
@property (nonatomic, readonly, copy) NSString * _Nonnull name;
/// Operator picture, see OperatorPicture class for more details
@property (nonatomic, readonly, strong) OperatorPicture * _Nullable picture;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// <ul>
///   <li>
///     Operator picture information
///   </li>
/// </ul>
SWIFT_CLASS("_TtC11SalemoveSDK15OperatorPicture")
@interface OperatorPicture : NSObject
/// <ul>
///   <li>
///     Returns The Operator picture URL if exists
///   </li>
/// </ul>
@property (nonatomic, readonly, copy) NSString * _Nullable url;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Operator typing status
SWIFT_CLASS("_TtC11SalemoveSDK20OperatorTypingStatus")
@interface OperatorTypingStatus : NSObject
/// True if the Operator has written or is writing a message but has not sent it yet, false otherwise.
@property (nonatomic, readonly) BOOL isTyping;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

enum PushType : NSInteger;

/// Push object sent by the client library
SWIFT_CLASS("_TtC11SalemoveSDK4Push")
@interface Push : NSObject
/// UNNotificationResponse.actionIdentifier that is returned by the system
@property (nonatomic, readonly, copy) NSString * _Nonnull actionIdentifier;
/// Push type. One of <code>PushType</code> values.
@property (nonatomic, readonly) enum PushType type;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class UNUserNotificationCenter;
@class UNNotification;
@class UNNotificationResponse;

/// The protocol to be used to notify the SDK about push notifications.
SWIFT_PROTOCOL("_TtP11SalemoveSDK24PushNotificationHandling_")
@protocol PushNotificationHandling
/// Call this method when <code>userNotificationCenter:willPresent:withCompletionHandler:</code> is called
/// from <code>UNUserNotificationCenterDelegate</code>.
/// Send all parameters that you receive in the delegate method as they are, without modifying them. By default, the completion
/// handler will not be called by the SDK, which means that iOS will not present a notification banner. If you wish to do so,
/// call the completion handler manually after calling this method.
/// <h1>Reference</h1>
/// <a href="https://developer.apple.com/documentation/usernotifications/unusernotificationcenterdelegate">UNUserNotificationCenterDelegate</a>
/// \param center The instance of <code>UNUserNotificationCenter</code>.
///
/// \param notification The notification, exactly as received from the delegate method.
///
/// \param completionHandler The completion handler, exactly as received from the delegate method.
///
- (void)userNotificationCenter:(UNUserNotificationCenter * _Nonnull)center willPresent:(UNNotification * _Nonnull)notification withCompletionHandler:(void (^ _Nonnull)(UNNotificationPresentationOptions))completionHandler;
/// Call this method when <code>userNotificationCenter:didReceive:withCompletionHandler:</code> is called
/// from <code>UNUserNotificationCenterDelegate</code>.
/// Send all parameters that you receive in the delegate method as they are, without modifying them. By default, the completion
/// handler will be called by the SDK, which means that iOS will present a notification banner.
/// <h1>Reference</h1>
/// <a href="https://developer.apple.com/documentation/usernotifications/unusernotificationcenterdelegate">UNUserNotificationCenterDelegate</a>
/// \param center The instance of <code>UNUserNotificationCenter</code>.
///
/// \param response The notification response, exactly as received from the delegate method.
///
/// \param completionHandler The completion handler, exactly as received from the delegate method.
///
- (void)userNotificationCenter:(UNUserNotificationCenter * _Nonnull)center didReceive:(UNNotificationResponse * _Nonnull)response withCompletionHandler:(void (^ _Nonnull)(void))completionHandler;
@end

/// Available push notification types.
typedef SWIFT_ENUM(NSInteger, PushNotificationType, open) {
/// The SDK will subscribe to push notifications for when the engagement starts.
  PushNotificationTypeStart = 0,
/// The SDK will subscribe to push notifications for when the engagement ends.
  PushNotificationTypeEnd = 1,
/// The SDK will subscribe to push notifications for when the engagement fails.
  PushNotificationTypeFailed = 2,
/// The SDK will subscribe to push notifications for when a new message is received.
  PushNotificationTypeMessage = 3,
/// The SDK will subscribe to push notifications for when the engagement is transferred to another operator.
  PushNotificationTypeTransfer = 4,
};

/// Available push notification types
typedef SWIFT_ENUM(NSInteger, PushType, open) {
/// Unknown type
  PushTypeUnidentified = 0,
/// Chat type
  PushTypeChatMessage = 1,
};

@class QueueState;

/// A Queue for an Engagement
SWIFT_CLASS("_TtC11SalemoveSDK5Queue")
@interface Queue : NSObject
/// Queue identifier
@property (nonatomic, readonly, copy) NSString * _Nonnull id;
/// Queue name
@property (nonatomic, readonly, copy) NSString * _Nonnull name;
/// Queue state
@property (nonatomic, readonly, strong) QueueState * _Nonnull state;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// Error of the Queue
typedef SWIFT_ENUM(NSInteger, QueueError, open) {
/// The Queue is closed for an Engagement.
  QueueErrorQueueClosed = 0,
/// The Queue is full.
  QueueErrorQueueFull = 1,
/// The Queue ID is invalid.
  QueueErrorInvalidId = 2,
/// The visitor is already enqueued.
  QueueErrorAlreadyEnqueued = 3,
};
static NSString * _Nonnull const QueueErrorDomain = @"SalemoveSDK.QueueError";


SWIFT_CLASS("_TtC11SalemoveSDK10QueueState")
@interface QueueState : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// A token for Visitor’s spot in the queue. This ticket can also be used to cancel queueing
SWIFT_CLASS("_TtC11SalemoveSDK11QueueTicket")
@interface QueueTicket : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end




SWIFT_CLASS("_TtC11SalemoveSDK7SVGView")
@interface SVGView : MacawView
@property (nonatomic, copy) IBInspectable NSString * _Nullable fileName;
- (nullable instancetype)initWithNode:(Node * _Nonnull)node coder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder;
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
@end


/// Shared instance that can be accessed across all the application
SWIFT_CLASS("_TtC11SalemoveSDK8Salemove")
@interface Salemove : NSObject
/// Use this to access the client library, avoid creating the instance manually
SWIFT_CLASS_PROPERTY(@property (nonatomic, class, readonly, strong) Salemove * _Nonnull sharedInstance;)
+ (Salemove * _Nonnull)sharedInstance SWIFT_WARN_UNUSED_RESULT;
/// The current interactor that the SDK is forwarding the events to
@property (nonatomic, weak) id <Interactable> _Nullable currentInteractor;
/// The current handler that the SDK is forwarding the UNNotificationResponse.actionIdentifier to
@property (nonatomic, copy) void (^ _Nullable pushHandler)(Push * _Nonnull);
/// The current selected environment
@property (nonatomic, readonly, copy) NSString * _Nonnull environment;
/// The current selected site
@property (nonatomic, readonly, copy) NSString * _Nonnull site;
/// The current provided app token
@property (nonatomic, readonly, copy) NSString * _Nonnull appToken;
/// The current provided api token
@property (nonatomic, readonly, copy) NSString * _Nonnull apiToken;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



@interface Salemove (SWIFT_EXTENSION(SalemoveSDK))
/// Deprecated. Use <code>fetchFile(engagementFile:progress:completion:)</code> instead
- (void)fetchFile:(NSString * _Nonnull)id progress:(void (^ _Nullable)(EngagementFileProgress * _Nonnull))progress completion:(void (^ _Nonnull)(EngagementFileData * _Nullable, SalemoveError * _Nullable))completion SWIFT_DEPRECATED_MSG("Use fetchFile(engagementFile:progress:completion:) instead");
@end






@interface Salemove (SWIFT_EXTENSION(SalemoveSDK))
/// Request media upgrade with specific offer
/// <ul>
///   <li>
///     parameters:
///   </li>
///   <li>
///     offer: The `MediaUpgradeOffer’ that is used for the request
///   </li>
///   <li>
///     completion: A callback that returns the upgrade result or <code>SalemoveError</code>
///   </li>
/// </ul>
/// If the request is unsuccessful for any reason then the completion will have an Error.
/// The Error may have one of the following causes:
/// <ul>
///   <li>
///     <code>GeneralError.internalError</code>
///   </li>
///   <li>
///     <code>GeneralError.networkError</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidSite</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidEnvironment</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidAppToken</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidApiToken</code>
///   </li>
///   <li>
///     <code>MediaUpgradeError.requestError</code>
///   </li>
/// </ul>
- (void)requestMediaUpgradeWithOffer:(MediaUpgradeOffer * _Nonnull)offer completion:(void (^ _Nonnull)(BOOL, SalemoveError * _Nullable))completion;
@end


@interface Salemove (SWIFT_EXTENSION(SalemoveSDK))
/// Clear the use session of the client library
- (void)clearSession;
@end


@interface Salemove (SWIFT_EXTENSION(SalemoveSDK))
/// Request a VisitorCode for current Visitor
/// A Visitor code can be displayed to the Visitor. The Visitor can then inform OmniBrowse Operators of their code. OmniBrowse Operators use the Visitor’s code to start an OmniBrowse Engagement with the Visitor.
/// Each Visitor code is generated on demand and is unique for every Visitor on a particular site. Upon the first time this function is called for a Visitor the code is generated and returned. For each successive call thereafter the same code will be returned as long as the code has not expired. The expiration time for Visitor codes is 3 hours. During that time the code can be used to initiate an engagement. Once Operator uses the Visitor code to initiate an engagement, the code will expire immediately. When the Visitor Code expires this function will return a new Visitor code.
/// The expiration time is important to take note of if you plan on retrieving the code only once during the Visitor’s session. A new code should be requested once the initial one has expired. When Visitor provides an expired code to Operator the Operator will not be able to connect with the Visitor.
/// <ul>
///   <li>
///     parameters:
///   </li>
///   <li>
///     completion: A callback that will return the visitor code or <code>SalemoveError</code>
///   </li>
/// </ul>
/// If the request is unsuccessful for any reason then the completion will have an Error.
/// The Error may have one of the following causes:
/// <ul>
///   <li>
///     <code>GeneralError.internalError</code>
///   </li>
///   <li>
///     <code>GeneralError.networkError</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidSite</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidEnvironment</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidAppToken</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidApiToken</code>
///   </li>
/// </ul>
- (void)requestVisitorCodeWithCompletion:(void (^ _Nonnull)(NSString * _Nullable, SalemoveError * _Nullable))completion;
@end



@interface Salemove (SWIFT_EXTENSION(SalemoveSDK))
/// Update current Visitor’s information.
/// The information provided by this endpoint is available to all the Operators observing or interacting with the Visitor. This means that this endpoint can be used to provide additional context about the Visitor to the Operators. For example, if a Visitor is logged into the current site and their name and email are recorded on their profile, then taking the data from the profile and passing it into this endpoint helps the Operators see the real names and emails of every logged in Visitor even before they start a conversation.
/// In a similar manner custom attributes can be also be used to provide additional context. For example, if your site separates paying users from free users, then setting a custom attribute of ‘user_type’ with a value of either ‘free’ or ‘paying’ depending on the Visitor’s account can help Operators prioritize different Visitors.
/// <ul>
///   <li>
///     parameters:
///   </li>
///   <li>
///     name: The Visitor’s name
///   </li>
///   <li>
///     email: The Visitor’s email address
///   </li>
///   <li>
///     phone: The Visitor’s phone number
///   </li>
///   <li>
///     customAttributes: An object with custom key-value pairs to be assigned to the Visitor. The server treats all keys and values as strings and also returns them as strings. Nested key-value pairs are not supported.
///   </li>
///   <li>
///     externalId: The Visitor’s unique identifier in scope of the current Site. Valuable information about the current Visitor may often be available in CRMs and other systems external to SaleMove. This field allows matching the Visitor to their record in such CRMs and other external systems. For example, a Visitor can have an ID within Salesforce. By setting the ‘external_id’ to the current Visitor’s Salesforce ID, they can easily be matched to their record within Salesforce.
///   </li>
///   <li>
///     completion: A callback that will return the update result or <code>SalemoveError</code>
///   </li>
/// </ul>
/// If the request is unsuccessful for any reason then the completion will have an Error.
/// The Error may have one of the following causes:
/// <ul>
///   <li>
///     <code>GeneralError.internalError</code>
///   </li>
///   <li>
///     <code>GeneralError.networkError</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidSite</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidEnvironment</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidAppToken</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidApiToken</code>
///   </li>
/// </ul>
- (void)updateInformationWithName:(NSString * _Nullable)name email:(NSString * _Nullable)email phone:(NSString * _Nullable)phone externalID:(NSString * _Nullable)externalID customAttributes:(NSDictionary<NSString *, NSString *> * _Nullable)customAttributes completion:(void (^ _Nonnull)(BOOL, SalemoveError * _Nullable))completion;
@end





@interface Salemove (SWIFT_EXTENSION(SalemoveSDK)) <PushNotificationHandling>
/// See the method description in <a href="x-source-tag://PushNotificationHandlingWillPresent">PushNotificationHandling</a>.
- (void)userNotificationCenter:(UNUserNotificationCenter * _Nonnull)center willPresent:(UNNotification * _Nonnull)notification withCompletionHandler:(void (^ _Nonnull)(UNNotificationPresentationOptions))completionHandler;
/// See the method description in <a href="x-source-tag://PushNotificationHandlingDidReceive">PushNotificationHandling</a>.
- (void)userNotificationCenter:(UNUserNotificationCenter * _Nonnull)center didReceive:(UNNotificationResponse * _Nonnull)response withCompletionHandler:(void (^ _Nonnull)(void))completionHandler;
@end


@interface Salemove (SWIFT_EXTENSION(SalemoveSDK))
/// Configure log level
/// \param level One of the ‘LogLevel’ values that the logger should use
///
- (void)configureLogLevelWithLevel:(enum LogLevel)level;
@end


@interface Salemove (SWIFT_EXTENSION(SalemoveSDK))
/// Uploads a file to an engagement. The uploaded file can be later sent as part of a chat message attachments.
/// If Glia’s servers require a security check for the uploaded file, then it will be triggered automatically. The completion
/// will be called with the file information once the check succeeds and reports that the file is clean. If the security
/// check fails, then the completion will be called with <code>FileError.infected</code>. In case the security scan is not
/// needed, the completion will be called right after the file upload is completed.
/// The error inside the completion may have one of the following causes:
/// <ul>
///   <li>
///     <code>GeneralError.internalError</code>
///   </li>
///   <li>
///     <code>GeneralError.networkError</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidSite</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidEnvironment</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidAppToken</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidApiToken</code>
///   </li>
///   <li>
///     <code>FileError.infected</code>
///   </li>
///   <li>
///     <code>FileError.unsupportedFileType</code>
///   </li>
///   <li>
///     <code>FileError.fileTooBig</code>
///   </li>
/// </ul>
/// \param file The file that will be uploaded.
///
/// \param progress A callback that reports the upload progress of the file.
///
/// \param completion A callback that will return <code>EngagementFileInformation</code> at the end of successful upload and security scan (if needed), or <code>SalemoveError</code>.
///
- (void)uploadFileToEngagement:(EngagementFile * _Nonnull)file progress:(void (^ _Nullable)(EngagementFileProgress * _Nonnull))progress completion:(void (^ _Nonnull)(EngagementFileInformation * _Nullable, SalemoveError * _Nullable))completion;
/// Retrieves a file from Glia’s servers.
/// The error inside the completion may have one of the following causes:
/// <ul>
///   <li>
///     <code>GeneralError.internalError</code>
///   </li>
///   <li>
///     <code>GeneralError.networkError</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidSite</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidEnvironment</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidAppToken</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidApiToken</code>
///   </li>
/// </ul>
/// \param engagementFile A instance of EngagementFile.
///
/// \param progress A callback that reports the upload progress of the file.
///
/// \param completion A callback that will return an <code>EngagementFileData</code> object if successful, or <code>InternalError</code>.
///
- (void)fetchFileWithEngagementFile:(EngagementFile * _Nonnull)engagementFile progress:(void (^ _Nullable)(EngagementFileProgress * _Nonnull))progress completion:(void (^ _Nonnull)(EngagementFileData * _Nullable, SalemoveError * _Nullable))completion;
@end




@interface Salemove (SWIFT_EXTENSION(SalemoveSDK))
/// Send single choice response with the selected option.
/// Adds attachment with selected option to message.
/// \param selectedOptionValue value of SingleChoiceOption selected by the user
///
/// \param messageId messageId of the message with single choice options.
///
/// \param completion A callback that will return the <code>Message</code> or <code>SalemoveError</code>
/// If the request is unsuccessful for any reason then the completion will have an Error.
/// The Error may have one of the following causes:
/// <ul>
///   <li>
///     <code>GeneralError.internalError</code>
///   </li>
///   <li>
///     <code>GeneralError.networkError</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidSite</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidEnvironment</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidAppToken</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidApiToken</code>
///   </li>
/// </ul>
///
- (void)sendWithSelectedOptionValue:(NSString * _Nonnull)selectedOptionValue messageId:(NSString * _Nonnull)messageId completion:(void (^ _Nonnull)(Message * _Nullable, SalemoveError * _Nullable))completion;
/// Send a chat message.
/// If the request is unsuccessful for any reason then the completion will have an Error.
/// The Error may have one of the following causes:
/// <ul>
///   <li>
///     <code>GeneralError.internalError</code>
///   </li>
///   <li>
///     <code>GeneralError.networkError</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidSite</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidEnvironment</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidAppToken</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidApiToken</code>
///   </li>
/// </ul>
/// \param message The content of the message that should be sent to the operator.
///
/// \param attachment An optional attachment to be sent to the operator. It is <code>nil</code> by default.
///
/// \param completion A callback that will return the <code>Message</code> or <code>SalemoveError</code>.
///
- (void)sendWithMessage:(NSString * _Nonnull)message attachment:(Attachment * _Nullable)attachment completion:(void (^ _Nonnull)(Message * _Nullable, SalemoveError * _Nullable))completion;
/// Send a chat message
/// <ul>
///   <li>
///     parameters:
///   </li>
///   <li>
///     message: A content of the message that should be queued
///   </li>
///   <li>
///     queueID: The ID of the queue to which the message is sent
///   </li>
///   <li>
///     completion: A callback that will return the <code>Message</code> or <code>SalemoveError</code>
///   </li>
/// </ul>
/// If the request is unsuccessful for any reason then the completion will have an Error.
/// The Error may have one of the following causes:
/// <ul>
///   <li>
///     <code>GeneralError.internalError</code>
///   </li>
///   <li>
///     <code>GeneralError.networkError</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidSite</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidEnvironment</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidAppToken</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidApiToken</code>
///   </li>
/// </ul>
- (void)sendWithMessage:(NSString * _Nonnull)message queueID:(NSString * _Nonnull)queueID completion:(void (^ _Nonnull)(Message * _Nullable, SalemoveError * _Nullable))completion;
/// Send a message preview to the Operator.
/// The latest preview message will always be visible to the Operator. This means that Operators can use the
/// preview messages as an indication of Visitor activity. The Operator could also use the preview messages to
/// start preparing a response before the Visitor finishes typing, ensuring a fast and seamless communication
/// experience.
/// <ul>
///   <li>
///     parameters:
///   </li>
///   <li>
///     message: The content of the message preview
///   </li>
///   <li>
///     completion: A callback that will return the sending result or <code>SalemoveError</code>
///   </li>
/// </ul>
/// If the request is unsuccessful for any reason then the completion will have an Error.
/// The Error may have one of the following causes:
/// <ul>
///   <li>
///     <code>GeneralError.internalError</code>
///   </li>
///   <li>
///     <code>GeneralError.networkError</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidSite</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidEnvironment</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidAppToken</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidApiToken</code>
///   </li>
/// </ul>
- (void)sendMessagePreviewWithMessage:(NSString * _Nonnull)message completion:(void (^ _Nonnull)(BOOL, SalemoveError * _Nullable))completion;
@end


@interface Salemove (SWIFT_EXTENSION(SalemoveSDK))
/// Change the site used by the client library
/// <ul>
///   <li>
///     parameters:
///   </li>
///   <li>
///     site: The siteID that should be selected
///   </li>
/// </ul>
///
/// throws:
/// <code>ConfigurationError.invalidSite</code>
- (BOOL)configureWithSite:(NSString * _Nonnull)site error:(NSError * _Nullable * _Nullable)error;
/// Change the environment used by the client library
/// <ul>
///   <li>
///     parameters:
///   </li>
///   <li>
///     environment: The environment baseURL that should be selected
///   </li>
/// </ul>
///
/// throws:
/// <code>ConfigurationError.invalidEnvironment</code>
- (BOOL)configureWithEnvironment:(NSString * _Nonnull)environment error:(NSError * _Nullable * _Nullable)error;
/// Change the interactor used by the client library
/// <ul>
///   <li>
///     parameters:
///   </li>
///   <li>
///     interactor: Interactable instance that the client library will communicate with
///   </li>
/// </ul>
- (void)configureWithInteractor:(id <Interactable> _Nonnull)interactor;
/// Change the appToken used by the client library
/// <ul>
///   <li>
///     parameters:
///   </li>
///   <li>
///     appToken: The token that is going to be used by the client library
///   </li>
/// </ul>
///
/// throws:
/// <code>ConfigurationError.invalidAppToken</code>
- (BOOL)configureWithAppToken:(NSString * _Nonnull)appToken error:(NSError * _Nullable * _Nullable)error;
/// Change the apiToken used by the client library
/// <ul>
///   <li>
///     parameters:
///   </li>
///   <li>
///     apiToken: The token that is going to be used by the client library
///   </li>
/// </ul>
///
/// throws:
/// <code>ConfigurationError.invalidApiToken</code>
- (BOOL)configureWithApiToken:(NSString * _Nonnull)apiToken error:(NSError * _Nullable * _Nullable)error;
@end


@interface Salemove (SWIFT_EXTENSION(SalemoveSDK))
/// Waits until there is an active engagement handled by the SDK.
/// If the SDK already has an active engagement present, then it returns information about it through
/// the <code>completion</code> block. Otherwise, it waits until the SDK receives information about an active engagement.
/// This method is useful to decide if touching on a push notification after the app has been force closed should open
/// an engagement screen. If there is an engagement restored by the SDK, then this method will notify soon after the
/// SDK is initialized, and you can show an engagement screen. Otherwise, then you should do nothing about the push
/// notification.
/// \param completion The closure that will be called once the SDK detects an active engagement.
///
- (void)waitForActiveEngagementWithCompletion:(void (^ _Nonnull)(Engagement * _Nullable, SalemoveError * _Nullable))completion;
/// Request an Engagement with a selected Operator
/// <ul>
///   <li>
///     parameters:
///   </li>
///   <li>
///     selectedOperator: The Operator that will be selected
///   </li>
///   <li>
///     visitorContext: The visitor context that should be displayed
///   </li>
///   <li>
///     completion: A callback that will return the <code>EngagementRequest</code> or <code>SalemoveError</code>
///   </li>
/// </ul>
/// If the request is unsuccessful for any reason then the completion will have an Error.
/// The Error may have one of the following causes:
/// <ul>
///   <li>
///     <code>GeneralError.internalError</code>
///   </li>
///   <li>
///     <code>GeneralError.networkError</code>
///   </li>
///   <li>
///     <code>ContextError.invalidURL</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidSite</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidEnvironment</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidAppToken</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidApiToken</code>
///   </li>
///   <li>
///     <code>EngagementError.operatorUnavailable</code>
///   </li>
/// </ul>
- (void)requestEngagementWithSelectedOperator:(Operator * _Nonnull)selectedOperator visitorContext:(VisitorContext * _Nonnull)visitorContext completion:(void (^ _Nonnull)(EngagementRequest * _Nullable, SalemoveError * _Nullable))completion;
/// Cancel an ongoing EngagementRequest
/// <ul>
///   <li>
///     parameters:
///   </li>
///   <li>
///     engagementRequest: The ongoing EngagementRequest to be canceled
///   </li>
///   <li>
///     completion: A callback that will return the canceling result or <code>SalemoveError</code>
///   </li>
/// </ul>
/// If the request is unsuccessful for any reason then the completion will have an Error.
/// The Error may have one of the following causes:
/// <ul>
///   <li>
///     <code>GeneralError.internalError</code>
///   </li>
///   <li>
///     <code>GeneralError.networkError</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidSite</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidEnvironment</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidAppToken</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidApiToken</code>
///   </li>
/// </ul>
- (void)cancelWithEngagementRequest:(EngagementRequest * _Nonnull)engagementRequest completion:(void (^ _Nonnull)(BOOL, SalemoveError * _Nullable))completion;
/// Request an Operator for an Engagement
/// <ul>
///   <li>
///     parameter:
///   </li>
///   <li>
///     completion: A callback that will return the ‘Operator’ list or <code>SalemoveError</code>
///   </li>
/// </ul>
/// If the request is unsuccessful for any reason then the completion will have an Error.
/// The Error may have one of the following causes:
/// <ul>
///   <li>
///     <code>GeneralError.internalError</code>
///   </li>
///   <li>
///     <code>GeneralError.networkError</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidSite</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidEnvironment</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidAppToken</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidApiToken</code>
///   </li>
/// </ul>
- (void)requestOperatorsWithCompletion:(void (^ _Nonnull)(NSArray<Operator *> * _Nullable, SalemoveError * _Nullable))completion;
/// Requests information of the Operator(s) that are currently engaged with the Visitor
/// <ul>
///   <li>
///     parameter:
///   </li>
///   <li>
///     completion: A callback that will return a list of all ‘Operator’s in engagement  or <code>SalemoveError</code>
///   </li>
/// </ul>
/// If the request is unsuccessful for any reason then the completion will have an Error.
/// The Error may have one of the following causes:
/// <ul>
///   <li>
///     <code>GeneralError.internalError</code>
///   </li>
///   <li>
///     <code>GeneralError.networkError</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidSite</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidEnvironment</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidAppToken</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidApiToken</code>
///   </li>
/// </ul>
- (void)requestEngagedOperatorWithCompletion:(void (^ _Nonnull)(NSArray<Operator *> * _Nullable, SalemoveError * _Nullable))completion;
/// End an Engagement
/// <ul>
///   <li>
///     parameters:
///   </li>
///   <li>
///     completion: A callback that will return the ending result or <code>SalemoveError</code>
///   </li>
/// </ul>
/// If the request is unsuccessful for any reason then the completion will have an Error.
/// The Error may have one of the following causes:
/// <ul>
///   <li>
///     <code>GeneralError.internalError</code>
///   </li>
///   <li>
///     <code>GeneralError.networkError</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidSite</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidEnvironment</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidAppToken</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidApiToken</code>
///   </li>
/// </ul>
- (void)endEngagementWithCompletion:(void (^ _Nonnull)(BOOL, SalemoveError * _Nullable))completion;
@end



@interface Salemove (SWIFT_EXTENSION(SalemoveSDK))
/// Queue for an Engagement with a specific queue.
/// If you decide to use this method with <code>shouldCloseAllQueues</code> as <code>false</code>, please note that you will
/// need to cancel any active queue tickets yourself. This can be done by calling <code>dequeueFromActiveQueueTickets</code>.
/// If the request is unsuccessful for any reason then the completion will have an Error.
/// The Error may have one of the following causes:
/// <ul>
///   <li>
///     <code>GeneralError.internalError</code>
///   </li>
///   <li>
///     <code>GeneralError.networkError</code>
///   </li>
///   <li>
///     <code>ContextError.invalidURL</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidSite</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidEnvironment</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidAppToken</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidApiToken</code>
///   </li>
///   <li>
///     <code>QueueError.queueClosed</code>
///   </li>
///   <li>
///     <code>QueueError.queueFull</code>
///   </li>
///   <li>
///     <code>QueueError.invalidId</code>
///   </li>
///   <li>
///     parameters:
///   </li>
///   <li>
///     queueID: The ID that will be used by the client library
///   </li>
///   <li>
///     visitorContext: The visitor context that should be displayed
///   </li>
///   <li>
///     shouldCloseAllQueues: If <code>true</code>, the method closes all active queue tickets. The default value is <code>true</code>.
///   </li>
///   <li>
///     completion: A callback that will return the <code>QueueTicket</code> or <code>SalemoveError</code>
///   </li>
/// </ul>
- (void)queueForEngagementWithQueueID:(NSString * _Nonnull)queueID visitorContext:(VisitorContext * _Nonnull)visitorContext shouldCloseAllQueues:(BOOL)shouldCloseAllQueues completion:(void (^ _Nonnull)(QueueTicket * _Nullable, SalemoveError * _Nullable))completion;
/// Cancels all active queue tickets that the current visitor has.
/// Use this method to avoid attempting to enter a queue while the visitor is already enqueued. If you call <code>queueForEngagement</code>
/// with <code>shouldCloseAllQueues</code> set to <code>true</code>, this method is called for you before attempting to enqueue into a new queue.
/// If the request is unsuccessful for any reason then the completion will have an Error.
/// The Error may have one of the following causes:
/// <ul>
///   <li>
///     <code>GeneralError.internalError</code>
///   </li>
///   <li>
///     <code>GeneralError.networkError</code>
///   </li>
///   <li>
///     <code>ContextError.invalidURL</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidSite</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidEnvironment</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidAppToken</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidApiToken</code>
///   </li>
///   <li>
///     <code>QueueError.queueClosed</code>
///   </li>
///   <li>
///     <code>QueueError.queueFull</code>
///   </li>
///   <li>
///     <code>QueueError.invalidId</code>
///   </li>
/// </ul>
/// \param completion A callback that will return <code>true</code> if successful, or <code>false</code> and a <code>SalemoveError</code> if it fails.
///
- (void)dequeueFromActiveTicketsWithCompletion:(void (^ _Nonnull)(BOOL, SalemoveError * _Nullable))completion;
/// Cancel the Engagement queueing with specific ticket
/// <ul>
///   <li>
///     parameters:
///   </li>
///   <li>
///     queueTicket: The <code>QueueTicket</code> that was used to enqueue
///   </li>
///   <li>
///     completion: A callback that will return the dequeuing result or <code>SalemoveError</code>
///   </li>
/// </ul>
/// If the request is unsuccessful for any reason then the completion will have an Error.
/// The Error may have one of the following causes:
/// <ul>
///   <li>
///     <code>GeneralError.internalError</code>
///   </li>
///   <li>
///     <code>GeneralError.networkError</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidSite</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidEnvironment</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidAppToken</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidApiToken</code>
///   </li>
/// </ul>
- (void)cancelWithQueueTicket:(QueueTicket * _Nonnull)queueTicket completion:(void (^ _Nonnull)(BOOL, SalemoveError * _Nullable))completion;
/// It is also possible to monitor Queues changes with <a href="x-source-tag://subscribeForUpdates">subscribeForUpdates</a> method.
/// <ul>
///   <li>
///     parameters:
///   </li>
///   <li>
///     completion: A callback that will return the <code>Queue</code> list or <code>SalemoveError</code>
///   </li>
/// </ul>
/// If the request is unsuccessful for any reason then the completion will have an Error.
/// The Error may have one of the following causes:
/// <ul>
///   <li>
///     <code>GeneralError.internalError</code>
///   </li>
///   <li>
///     <code>GeneralError.networkError</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidSite</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidEnvironment</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidAppToken</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidApiToken</code>
///   </li>
/// </ul>
- (void)listQueuesWithCompletion:(void (^ _Nonnull)(NSArray<Queue *> * _Nullable, SalemoveError * _Nullable))completion;
/// Registers Queue change listener for Queues with specified ID’s. It is possible to retrieve Queue ID’s with the <a href="x-source-tag://listQueues">listQueues</a> method.
/// To unsubscribe from receiving this changes <a href="x-source-tag://unsubscribeFromUpdates">unsubscribeFromUpdates</a> method can be used.
/// <hr/>
/// Example:
/// \code
/// let queueUpdatesCallbackId = Salemove.sharedInstance.subscribeForUpdates(
///     forQueue: [QUEUE_ID_1, QUEUE_ID_2],
///     onError: showError(salemoveError:),
///     onUpdate: updateQueueInfo(newQueue:)
/// )
///
/// \endcode\param for Array of strings represinting Queue IDs that you want to get updates for
///
/// \param onUpdate A callback that returns a new instance of <code>Queue</code> every time its info is changed
///
/// \param onError A callback that returns <code>SalemoveError</code> which could have one of the reasons:
/// <ul>
///   <li>
///     <code>GeneralError.internalError</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidSite</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidEnvironment</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidAppToken</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidApiToken</code>
///   </li>
///   <li>
///     <code>QueueError.invalidId</code>
///   </li>
/// </ul>
///
///
/// returns:
///
/// A unique callback ID or <code>nil</code> if callback was not registered due to error.
/// This callback ID could be used to usubscribe from Queue updates.
- (NSString * _Nullable)subscribeForUpdatesForQueue:(NSArray<NSString *> * _Nonnull)queueIds onError:(void (^ _Nonnull)(SalemoveError * _Nonnull))onError onUpdate:(void (^ _Nonnull)(Queue * _Nonnull))onUpdate SWIFT_WARN_UNUSED_RESULT;
/// \param queueCallbackId ID of callback for which you would like to stop receiving updates.
///
/// \param onError A callback that returns <code>SalemoveError</code> which could have one of the reasons:
/// <ul>
///   <li>
///     <code>GeneralError.internalError</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidSite</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidEnvironment</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidAppToken</code>
///   </li>
///   <li>
///     <code>ConfigurationError.invalidApiToken</code>
///   </li>
/// </ul>
///
- (void)unsubscribeFromUpdatesWithQueueCallbackId:(NSString * _Nonnull)queueCallbackId onError:(void (^ _Nonnull)(SalemoveError * _Nonnull))onError;
@end


@class UIApplication;

/// The basic gateway class that interacts with the client library through the app delegate
SWIFT_CLASS("_TtC11SalemoveSDK19SalemoveAppDelegate")
@interface SalemoveAppDelegate : NSObject <UIApplicationDelegate>
/// Handle the application active state and setup the internals.
/// \param application The current application.
///
- (void)applicationDidBecomeActive:(UIApplication * _Nonnull)application;
/// Call this method when <code>application:didRegisterForRemoteNotificationsWithDeviceToken:</code> is called
/// from <code>UNUserNotificationCenterDelegate</code>.
/// Send all parameters that you receive in the delegate method as they are, without modifying them.
/// <h1>Reference</h1>
/// <a href="https://developer.apple.com/documentation/usernotifications/unusernotificationcenterdelegate">UNUserNotificationCenterDelegate</a>
/// \param application The current application.
///
/// \param deviceToken The data that holds the push notification device token.
///
- (void)application:(UIApplication * _Nonnull)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData * _Nonnull)deviceToken;
/// Call this method when <code>application:didFailToRegisterForRemoteNotificationsWithError:</code> is called
/// from <code>UNUserNotificationCenterDelegate</code>.
/// Send all parameters that you receive in the delegate method as they are, without modifying them.
/// <h1>Reference</h1>
/// <a href="https://developer.apple.com/documentation/usernotifications/unusernotificationcenterdelegate">UNUserNotificationCenterDelegate</a>
/// \param application The current application.
///
/// \param error The error describing the push notification registration failure.
///
- (void)application:(UIApplication * _Nonnull)application didFailToRegisterForRemoteNotificationsWithError:(NSError * _Nonnull)error;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


/// Wrapped error object
SWIFT_CLASS("_TtC11SalemoveSDK13SalemoveError")
@interface SalemoveError : NSObject
/// Human readable string that explains what went wrong
@property (nonatomic, readonly, copy) NSString * _Nonnull reason;
/// Underlying error object
@property (nonatomic, readonly) NSError * _Nullable error;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// List of available screen sharing statuses
typedef SWIFT_ENUM(NSInteger, ScreenSharingStatus, open) {
/// There is an ongoing screen sharing session
  ScreenSharingStatusSharing = 0,
/// No ongoing screensharing session
  ScreenSharingStatusNotSharing = 1,
};


/// Class which implements the various <code>URLSessionDelegate</code> methods to connect various Alamofire features.
SWIFT_CLASS("_TtC11SalemoveSDK15SessionDelegate")
@interface SessionDelegate : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

@class NSURLSession;

@interface SessionDelegate (SWIFT_EXTENSION(SalemoveSDK)) <NSURLSessionDelegate>
- (void)URLSession:(NSURLSession * _Nonnull)session didBecomeInvalidWithError:(NSError * _Nullable)error;
@end

@class NSURLSessionDataTask;
@class NSCachedURLResponse;

@interface SessionDelegate (SWIFT_EXTENSION(SalemoveSDK)) <NSURLSessionDataDelegate>
- (void)URLSession:(NSURLSession * _Nonnull)session dataTask:(NSURLSessionDataTask * _Nonnull)dataTask didReceiveData:(NSData * _Nonnull)data;
- (void)URLSession:(NSURLSession * _Nonnull)session dataTask:(NSURLSessionDataTask * _Nonnull)dataTask willCacheResponse:(NSCachedURLResponse * _Nonnull)proposedResponse completionHandler:(void (^ _Nonnull)(NSCachedURLResponse * _Nullable))completionHandler;
@end

@class NSURLSessionDownloadTask;

@interface SessionDelegate (SWIFT_EXTENSION(SalemoveSDK)) <NSURLSessionDownloadDelegate>
- (void)URLSession:(NSURLSession * _Nonnull)session downloadTask:(NSURLSessionDownloadTask * _Nonnull)downloadTask didResumeAtOffset:(int64_t)fileOffset expectedTotalBytes:(int64_t)expectedTotalBytes;
- (void)URLSession:(NSURLSession * _Nonnull)session downloadTask:(NSURLSessionDownloadTask * _Nonnull)downloadTask didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite;
- (void)URLSession:(NSURLSession * _Nonnull)session downloadTask:(NSURLSessionDownloadTask * _Nonnull)downloadTask didFinishDownloadingToURL:(NSURL * _Nonnull)location;
@end

@class NSURLSessionTask;
@class NSURLAuthenticationChallenge;
@class NSURLCredential;
@class NSInputStream;
@class NSHTTPURLResponse;
@class NSURLRequest;
@class NSURLSessionTaskMetrics;

@interface SessionDelegate (SWIFT_EXTENSION(SalemoveSDK)) <NSURLSessionTaskDelegate>
- (void)URLSession:(NSURLSession * _Nonnull)session task:(NSURLSessionTask * _Nonnull)task didReceiveChallenge:(NSURLAuthenticationChallenge * _Nonnull)challenge completionHandler:(void (^ _Nonnull)(NSURLSessionAuthChallengeDisposition, NSURLCredential * _Nullable))completionHandler;
- (void)URLSession:(NSURLSession * _Nonnull)session task:(NSURLSessionTask * _Nonnull)task didSendBodyData:(int64_t)bytesSent totalBytesSent:(int64_t)totalBytesSent totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend;
- (void)URLSession:(NSURLSession * _Nonnull)session task:(NSURLSessionTask * _Nonnull)task needNewBodyStream:(void (^ _Nonnull)(NSInputStream * _Nullable))completionHandler;
- (void)URLSession:(NSURLSession * _Nonnull)session task:(NSURLSessionTask * _Nonnull)task willPerformHTTPRedirection:(NSHTTPURLResponse * _Nonnull)response newRequest:(NSURLRequest * _Nonnull)request completionHandler:(void (^ _Nonnull)(NSURLRequest * _Nullable))completionHandler;
- (void)URLSession:(NSURLSession * _Nonnull)session task:(NSURLSessionTask * _Nonnull)task didFinishCollectingMetrics:(NSURLSessionTaskMetrics * _Nonnull)metrics;
- (void)URLSession:(NSURLSession * _Nonnull)session task:(NSURLSessionTask * _Nonnull)task didCompleteWithError:(NSError * _Nullable)error;
- (void)URLSession:(NSURLSession * _Nonnull)session taskIsWaitingForConnectivity:(NSURLSessionTask * _Nonnull)task SWIFT_AVAILABILITY(watchos,introduced=4.0) SWIFT_AVAILABILITY(tvos,introduced=11.0) SWIFT_AVAILABILITY(ios,introduced=11.0) SWIFT_AVAILABILITY(macos,introduced=10.13);
@end


SWIFT_CLASS("_TtC11SalemoveSDK5Shape")
@interface Shape : Node
@end



/// Option for single choice messages.
SWIFT_CLASS("_TtC11SalemoveSDK18SingleChoiceOption")
@interface SingleChoiceOption : NSObject
/// Text displayed to the user as a choice label.
@property (nonatomic, copy) NSString * _Nullable text;
/// Value of the choice sent as a response on user interaction.
@property (nonatomic, copy) NSString * _Nullable value;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// A class that represents a waiting ack call.
/// <em>NOTE</em>: You should not store this beyond the life of the event handler.
SWIFT_CLASS("_TtC11SalemoveSDK16SocketAckEmitter")
@interface SocketAckEmitter : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Represents some event that was received.
SWIFT_CLASS("_TtC11SalemoveSDK14SocketAnyEvent")
@interface SocketAnyEvent : NSObject
/// The description of this event.
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


/// Experimental socket manager.
/// API subject to change.
/// Can be used to persist sockets across ViewControllers.
/// Sockets are strongly stored, so be sure to remove them once they are no
/// longer needed.
/// Example usage:
/// \code
/// let manager = SocketClientManager.sharedManager
/// manager["room1"] = socket1
/// manager["room2"] = socket2
/// manager.removeSocket(socket: socket2)
/// manager["room1"]?.emit("hello")
///
/// \endcode
SWIFT_CLASS("_TtC11SalemoveSDK19SocketClientManager")
@interface SocketClientManager : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class NSHTTPCookie;
@class SocketIOWebSocket;
@protocol SocketEngineClient;
enum SocketEnginePacketType : NSInteger;

/// The class that handles the engine.io protocol and transports.
/// See <code>SocketEnginePollable</code> and <code>SocketEngineWebsocket</code> for transport specific methods.
SWIFT_CLASS("_TtC11SalemoveSDK12SocketEngine")
@interface SocketEngine : NSObject <NSURLSessionDelegate>
/// The queue that all engine actions take place on.
@property (nonatomic, readonly, strong) dispatch_queue_t _Nonnull engineQueue;
/// The connect parameters sent during a connect.
@property (nonatomic, copy) NSDictionary<NSString *, id> * _Nullable connectParams;
/// <code>true</code> if this engine is closed.
@property (nonatomic, readonly) BOOL closed;
/// <code>true</code> if this engine is connected. Connected means that the initial poll connect has succeeded.
@property (nonatomic, readonly) BOOL connected;
/// An array of HTTPCookies that are sent during the connection.
@property (nonatomic, readonly, copy) NSArray<NSHTTPCookie *> * _Nullable cookies;
/// Set to <code>true</code> if using the node.js version of socket.io. The node.js version of socket.io
/// handles utf8 incorrectly.
@property (nonatomic, readonly) BOOL doubleEncodeUTF8;
/// A dictionary of extra http headers that will be set during connection.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, NSString *> * _Nullable extraHeaders;
/// When <code>true</code>, the engine is in the process of switching to WebSockets.
/// <em>Do not touch this directly</em>
@property (nonatomic, readonly) BOOL fastUpgrade;
/// When <code>true</code>, the engine will only use HTTP long-polling as a transport.
@property (nonatomic, readonly) BOOL forcePolling;
/// When <code>true</code>, the engine will only use WebSockets as a transport.
@property (nonatomic, readonly) BOOL forceWebsockets;
/// If <code>true</code>, the engine is currently in HTTP long-polling mode.
@property (nonatomic, readonly) BOOL polling;
/// If <code>true</code>, the engine is currently seeing whether it can upgrade to WebSockets.
@property (nonatomic, readonly) BOOL probing;
/// The session id for this engine.
@property (nonatomic, readonly, copy) NSString * _Nonnull sid;
/// The path to engine.io.
@property (nonatomic, readonly, copy) NSString * _Nonnull socketPath;
/// The url for polling.
@property (nonatomic, readonly, copy) NSURL * _Nonnull urlPolling;
/// The url for WebSockets.
@property (nonatomic, readonly, copy) NSURL * _Nonnull urlWebSocket;
/// If <code>true</code>, then the engine is currently in WebSockets mode.
@property (nonatomic, readonly) BOOL websocket;
/// The SocketIOWebSocket for this engine.
@property (nonatomic, readonly, strong) SocketIOWebSocket * _Nullable ws;
/// The client for this engine.
@property (nonatomic, weak) id <SocketEngineClient> _Nullable client;
/// Creates a new engine.
/// \param client The client for this engine.
///
/// \param url The url for this engine.
///
/// \param options The options for this engine.
///
- (nonnull instancetype)initWithClient:(id <SocketEngineClient> _Nonnull)client url:(NSURL * _Nonnull)url options:(NSDictionary * _Nullable)options;
/// Starts the connection to the server.
- (void)connect;
/// Called when an error happens during execution. Causes a disconnection.
- (void)didErrorWithReason:(NSString * _Nonnull)reason;
/// Disconnects from the server.
/// \param reason The reason for the disconnection. This is communicated up to the client.
///
- (void)disconnectWithReason:(NSString * _Nonnull)reason;
/// Called to switch from HTTP long-polling to WebSockets. After calling this method the engine will be in
/// SocketIOWebSocket mode.
/// <em>You shouldn’t call this directly</em>
- (void)doFastUpgrade;
/// Causes any packets that were waiting for POSTing to be sent through the SocketIOWebSocket. This happens because when
/// the engine is attempting to upgrade to SocketIOWebSocket it does not do any POSTing.
/// <em>You shouldn’t call this directly</em>
- (void)flushWaitingForPostToWebSocket;
/// Parses raw binary received from engine.io.
/// \param data The data to parse.
///
- (void)parseEngineData:(NSData * _Nonnull)data;
/// Parses a raw engine.io packet.
/// \param message The message to parse.
///
/// \param fromPolling Whether this message is from long-polling.
/// If <code>true</code> we might have to fix utf8 encoding.
///
- (void)parseEngineMessage:(NSString * _Nonnull)message fromPolling:(BOOL)fromPolling;
/// Writes a message to engine.io, independent of transport.
/// \param msg The message to send.
///
/// \param withType The type of this message.
///
/// \param withData Any data that this message has.
///
- (void)write:(NSString * _Nonnull)msg withType:(enum SocketEnginePacketType)type withData:(NSArray<NSData *> * _Nonnull)data;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end



/// Declares that a type will be a delegate to an engine.
SWIFT_PROTOCOL("_TtP11SalemoveSDK18SocketEngineClient_")
@protocol SocketEngineClient
/// Called when the engine errors.
/// \param reason The reason the engine errored.
///
- (void)engineDidErrorWithReason:(NSString * _Nonnull)reason;
/// Called when the engine closes.
/// \param reason The reason that the engine closed.
///
- (void)engineDidCloseWithReason:(NSString * _Nonnull)reason;
/// Called when the engine opens.
/// \param reason The reason the engine opened.
///
- (void)engineDidOpenWithReason:(NSString * _Nonnull)reason;
/// Called when the engine has a message that must be parsed.
/// \param msg The message that needs parsing.
///
- (void)parseEngineMessage:(NSString * _Nonnull)msg;
/// Called when the engine receives binary data.
/// \param data The data the engine received.
///
- (void)parseEngineBinaryData:(NSData * _Nonnull)data;
@end

/// Represents the type of engine.io packet types.
typedef SWIFT_ENUM(NSInteger, SocketEnginePacketType, open) {
/// Open message.
  SocketEnginePacketTypeOpen = 0,
/// Close message.
  SocketEnginePacketTypeClose = 1,
/// Ping message.
  SocketEnginePacketTypePing = 2,
/// Pong message.
  SocketEnginePacketTypePong = 3,
/// Regular message.
  SocketEnginePacketTypeMessage = 4,
/// Upgrade message.
  SocketEnginePacketTypeUpgrade = 5,
/// NOOP.
  SocketEnginePacketTypeNoop = 6,
};


/// Specifies a SocketEngine.
SWIFT_PROTOCOL("_TtP11SalemoveSDK16SocketEngineSpec_")
@protocol SocketEngineSpec
/// The client for this engine.
@property (nonatomic, weak) id <SocketEngineClient> _Nullable client;
/// <code>true</code> if this engine is closed.
@property (nonatomic, readonly) BOOL closed;
/// <code>true</code> if this engine is connected. Connected means that the initial poll connect has succeeded.
@property (nonatomic, readonly) BOOL connected;
/// The connect parameters sent during a connect.
@property (nonatomic, copy) NSDictionary<NSString *, id> * _Nullable connectParams;
/// Set to <code>true</code> if using the node.js version of socket.io. The node.js version of socket.io
/// handles utf8 incorrectly.
@property (nonatomic, readonly) BOOL doubleEncodeUTF8;
/// An array of HTTPCookies that are sent during the connection.
@property (nonatomic, readonly, copy) NSArray<NSHTTPCookie *> * _Nullable cookies;
/// The queue that all engine actions take place on.
@property (nonatomic, readonly, strong) dispatch_queue_t _Nonnull engineQueue;
/// A dictionary of extra http headers that will be set during connection.
@property (nonatomic, readonly, copy) NSDictionary<NSString *, NSString *> * _Nullable extraHeaders;
/// When <code>true</code>, the engine is in the process of switching to WebSockets.
@property (nonatomic, readonly) BOOL fastUpgrade;
/// When <code>true</code>, the engine will only use HTTP long-polling as a transport.
@property (nonatomic, readonly) BOOL forcePolling;
/// When <code>true</code>, the engine will only use WebSockets as a transport.
@property (nonatomic, readonly) BOOL forceWebsockets;
/// If <code>true</code>, the engine is currently in HTTP long-polling mode.
@property (nonatomic, readonly) BOOL polling;
/// If <code>true</code>, the engine is currently seeing whether it can upgrade to WebSockets.
@property (nonatomic, readonly) BOOL probing;
/// The session id for this engine.
@property (nonatomic, readonly, copy) NSString * _Nonnull sid;
/// The path to engine.io.
@property (nonatomic, readonly, copy) NSString * _Nonnull socketPath;
/// The url for polling.
@property (nonatomic, readonly, copy) NSURL * _Nonnull urlPolling;
/// The url for WebSockets.
@property (nonatomic, readonly, copy) NSURL * _Nonnull urlWebSocket;
/// If <code>true</code>, then the engine is currently in WebSockets mode.
@property (nonatomic, readonly) BOOL websocket;
/// The SocketIOWebSocket for this engine.
@property (nonatomic, readonly, strong) SocketIOWebSocket * _Nullable ws;
/// Creates a new engine.
/// \param client The client for this engine.
///
/// \param url The url for this engine.
///
/// \param options The options for this engine.
///
- (nonnull instancetype)initWithClient:(id <SocketEngineClient> _Nonnull)client url:(NSURL * _Nonnull)url options:(NSDictionary * _Nullable)options;
/// Starts the connection to the server.
- (void)connect;
/// Called when an error happens during execution. Causes a disconnection.
- (void)didErrorWithReason:(NSString * _Nonnull)reason;
/// Disconnects from the server.
/// \param reason The reason for the disconnection. This is communicated up to the client.
///
- (void)disconnectWithReason:(NSString * _Nonnull)reason;
/// Called to switch from HTTP long-polling to WebSockets. After calling this method the engine will be in
/// SocketIOWebSocket mode.
/// <em>You shouldn’t call this directly</em>
- (void)doFastUpgrade;
/// Causes any packets that were waiting for POSTing to be sent through the SocketIOWebSocket. This happens because when
/// the engine is attempting to upgrade to SocketIOWebSocket it does not do any POSTing.
/// <em>You shouldn’t call this directly</em>
- (void)flushWaitingForPostToWebSocket;
/// Parses raw binary received from engine.io.
/// \param data The data to parse.
///
- (void)parseEngineData:(NSData * _Nonnull)data;
/// Parses a raw engine.io packet.
/// \param message The message to parse.
///
/// \param fromPolling Whether this message is from long-polling.
/// If <code>true</code> we might have to fix utf8 encoding.
///
- (void)parseEngineMessage:(NSString * _Nonnull)message fromPolling:(BOOL)fromPolling;
/// Writes a message to engine.io, independent of transport.
/// \param msg The message to send.
///
/// \param withType The type of this message.
///
/// \param withData Any data that this message has.
///
- (void)write:(NSString * _Nonnull)msg withType:(enum SocketEnginePacketType)type withData:(NSArray<NSData *> * _Nonnull)data;
@end


/// The main class for SocketIOClientSwift.
/// Represents a socket.io-client. Most interaction with socket.io will be through this class.
SWIFT_CLASS("_TtC11SalemoveSDK14SocketIOClient")
@interface SocketIOClient : NSObject <SocketEngineClient>
/// Called when the engine closes.
/// \param reason The reason that the engine closed.
///
- (void)engineDidCloseWithReason:(NSString * _Nonnull)reason;
/// Called when the engine errors.
/// \param reason The reason the engine errored.
///
- (void)engineDidErrorWithReason:(NSString * _Nonnull)reason;
/// Called when the engine opens.
/// \param reason The reason the engine opened.
///
- (void)engineDidOpenWithReason:(NSString * _Nonnull)reason;
/// Called when the engine has a message that must be parsed.
/// \param msg The message that needs parsing.
///
- (void)parseEngineMessage:(NSString * _Nonnull)msg;
/// Called when the engine receives binary data.
/// \param data The data the engine received.
///
- (void)parseEngineBinaryData:(NSData * _Nonnull)data;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

/// Represents the state of the client.
typedef SWIFT_ENUM(NSInteger, SocketIOClientStatus, open) {
/// The client has never been connected. Or the client has been reset.
  SocketIOClientStatusNotConnected = 0,
/// The client was once connected, but not anymore.
  SocketIOClientStatusDisconnected = 1,
/// The client is in the process of connecting.
  SocketIOClientStatusConnecting = 2,
/// The client is currently connected.
  SocketIOClientStatusConnected = 3,
};


SWIFT_CLASS("_TtC11SalemoveSDK15SocketIOSSLCert")
@interface SocketIOSSLCert : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC11SalemoveSDK17SocketIOWebSocket")
@interface SocketIOWebSocket : NSObject <NSStreamDelegate>
/// Delegate for the stream methods. Processes incoming bytes
- (void)stream:(NSStream * _Nonnull)aStream handleEvent:(NSStreamEvent)eventCode;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

enum VideoScalingOptions : NSInteger;

/// View that displays video stream. This can be added as a subview or insereted into a UIStackView for resizing.
SWIFT_CLASS("_TtC11SalemoveSDK10StreamView")
@interface StreamView : UIView
/// This modifies the internal constrains to change the view bounds.
/// One of the <code>VideoScalingOptions</code>
@property (nonatomic) enum VideoScalingOptions scale;
- (nonnull instancetype)initWithFrame:(CGRect)frame SWIFT_UNAVAILABLE;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder SWIFT_UNAVAILABLE;
@end


@protocol RTCVideoRenderer;

@interface StreamView (SWIFT_EXTENSION(SalemoveSDK)) <RTCVideoViewDelegate>
/// :nodoc:
- (void)videoView:(id <RTCVideoRenderer> _Nonnull)videoView didChangeVideoSize:(CGSize)size;
@end


SWIFT_CLASS("_TtC11SalemoveSDK4Text")
@interface Text : Node
@end





















/// Video scaling options, can be used to specify desired resize options
typedef SWIFT_ENUM(NSInteger, VideoScalingOptions, open) {
/// Scales the video to the screen bounds by changing the aspect ratio if needed.
  VideoScalingOptionsFill = 0,
/// Scales the video to fit the bounds by maintaining the aspect ratio. Any remaining area is transparent.
  VideoScalingOptionsAspectFit = 1,
/// Scales the video to fill the screen bounds. Some portion of the content maybe be clipped.
  VideoScalingOptionsAspectFill = 2,
};


/// Video stream, that can be used to display and control operator and visitor video during an engagement
SWIFT_PROTOCOL("_TtP11SalemoveSDK15VideoStreamable_")
@protocol VideoStreamable
/// Access the stream view
///
/// returns:
/// <code>StreamView</code> that contains the video stream
- (StreamView * _Nonnull)getStreamView SWIFT_WARN_UNUSED_RESULT;
/// Play the incoming/outgoing video stream
- (void)playVideo;
/// Pause the incoming/outgoing video stream
- (void)pause;
/// Resume the incoming/outgoing video stream
- (void)resume;
/// Stop the incoming/outgoing video stream
- (void)stop;
/// State of the video stream
///
/// returns:
/// bool indicating if the stream is paused or not
@property (nonatomic, readonly) BOOL isPaused;
/// Source of the video stream
///
/// returns:
/// bool indicating if the stream is local or remote
@property (nonatomic, readonly) BOOL isRemote;
@end


/// Visitor context specifies a content that can be shown to an Operator during an Engagement
/// on the place of CoBrowsing section in Operator App
SWIFT_CLASS("_TtC11SalemoveSDK14VisitorContext")
@interface VisitorContext : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC11SalemoveSDK25VisitorScreenSharingState")
@interface VisitorScreenSharingState : NSObject
/// ScreenSharing status, which is one of <code>ScreenSharingStatus</code>
@property (nonatomic, readonly) enum ScreenSharingStatus status;
/// <code>LocalScreen</code> can be used to stop screen sharing.
@property (nonatomic, readonly, strong) LocalScreen * _Nullable localScreen;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC11SalemoveSDK9WebSocket")
@interface WebSocket : NSObject <NSStreamDelegate>
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_UNAVAILABLE_MSG("-init is unavailable");
@end

#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
#endif
