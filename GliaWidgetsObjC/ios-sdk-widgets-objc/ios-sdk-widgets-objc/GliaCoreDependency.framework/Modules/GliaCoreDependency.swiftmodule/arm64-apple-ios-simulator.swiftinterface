// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.8.1 (swiftlang-5.8.0.124.5 clang-1403.0.22.11.100)
// swift-module-flags: -target arm64-apple-ios13.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name GliaCoreDependency
// swift-module-flags-ignorable: -enable-bare-slash-regex
import Darwin
import Dispatch
import Foundation
@_exported import GliaCoreDependency
import MachO
import Swift
import _Concurrency
import _StringProcessing
import Darwin.POSIX.pthread
extension GliaCoreDependency.ReactiveSwift {
  @_hasMissingDesignatedInitializers final public class Lifetime {
    final public var ended: GliaCoreDependency.ReactiveSwiftSignal<Swift.Never, Swift.Never> {
      get
    }
    final public var hasEnded: Swift.Bool {
      get
    }
    convenience public init(_ token: GliaCoreDependency.ReactiveSwift.Lifetime.Token)
    @discardableResult
    final public func observeEnded(_ action: @escaping () -> Swift.Void) -> (any GliaCoreDependency.ReactiveSwiftDisposable)?
    @discardableResult
    public static func += (lifetime: GliaCoreDependency.ReactiveSwift.Lifetime, disposable: (any GliaCoreDependency.ReactiveSwiftDisposable)?) -> (any GliaCoreDependency.ReactiveSwiftDisposable)?
    @objc deinit
  }
}
extension GliaCoreDependency.ReactiveSwift.Lifetime {
  public static func make() -> (lifetime: GliaCoreDependency.ReactiveSwift.Lifetime, token: GliaCoreDependency.ReactiveSwift.Lifetime.Token)
  public static let empty: GliaCoreDependency.ReactiveSwift.Lifetime
}
extension GliaCoreDependency.ReactiveSwift.Lifetime {
  final public class Token {
    public init()
    final public func dispose()
    @objc deinit
  }
}
extension GliaCoreDependency.SwiftPhoenixClient {
  @_hasMissingDesignatedInitializers public class Defaults {
    public static let timeoutInterval: Swift.Double
    public static let heartbeatInterval: Swift.Double
    public static let heartbeatLeeway: Dispatch.DispatchTimeInterval
    public static let reconnectSteppedBackOff: (_ tries: Swift.Int) -> Foundation.TimeInterval
    public static let rejoinSteppedBackOff: (_ tries: Swift.Int) -> Foundation.TimeInterval
    public static let vsn: Swift.String
    public static let encode: (_ json: Any) -> Foundation.Data
    public static let decode: (_ data: Foundation.Data) -> Any?
    public static let heartbeatQueue: Dispatch.DispatchQueue
    @objc deinit
  }
  public enum ChannelState : Swift.String {
    case closed
    case errored
    case joined
    case joining
    case leaving
    public init?(rawValue: Swift.String)
    public typealias RawValue = Swift.String
    public var rawValue: Swift.String {
      get
    }
  }
  public struct ChannelEvent {
    public static let heartbeat: Swift.String
    public static let join: Swift.String
    public static let leave: Swift.String
    public static let reply: Swift.String
    public static let error: Swift.String
    public static let close: Swift.String
  }
}
final public class ReactiveSwiftSignal<Value, Error> where Error : Swift.Error {
  public typealias Bag = GliaCoreDependency.ReactiveSwift.Bag
  public typealias AnyDisposable = GliaCoreDependency.ReactiveSwift.AnyDisposable
  public typealias Atomic = GliaCoreDependency.ReactiveSwift.Atomic
  public typealias Disposable = GliaCoreDependency.ReactiveSwift.Disposable
  public typealias Lifetime = GliaCoreDependency.ReactiveSwift.Lifetime
  public typealias DateScheduler = GliaCoreDependency.ReactiveSwift.DateScheduler
  public typealias Scheduler = GliaCoreDependency.ReactiveSwift.Scheduler
  public typealias SignalProducer = GliaCoreDependency.ReactiveSwift.SignalProducer
  public typealias SerialDisposable = GliaCoreDependency.ReactiveSwift.SerialDisposable
  public init(_ generator: (GliaCoreDependency.ReactiveSwiftSignal<Value, Error>.Observer, GliaCoreDependency.ReactiveSwiftSignal<Value, Error>.Lifetime) -> Swift.Void)
  @objc deinit
}
extension GliaCoreDependency.ReactiveSwiftSignal {
  public static var never: GliaCoreDependency.ReactiveSwiftSignal<Value, Error> {
    get
  }
  public static var empty: GliaCoreDependency.ReactiveSwiftSignal<Value, Error> {
    get
  }
  public static func pipe(disposable: (any GliaCoreDependency.ReactiveSwiftDisposable)? = nil) -> (output: GliaCoreDependency.ReactiveSwiftSignal<Value, Error>, input: GliaCoreDependency.ReactiveSwiftSignal<Value, Error>.Observer)
}
public protocol ReactiveSwiftSignalProtocol : AnyObject {
  associatedtype Value
  associatedtype Error : Swift.Error
  var signal: GliaCoreDependency.ReactiveSwiftSignal<Self.Value, Self.Error> { get }
}
extension GliaCoreDependency.ReactiveSwiftSignal : GliaCoreDependency.ReactiveSwiftSignalProtocol {
  final public var signal: GliaCoreDependency.ReactiveSwiftSignal<Value, Error> {
    get
  }
}
extension GliaCoreDependency.ReactiveSwiftSignal : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible {
  final public var producer: GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error> {
    get
  }
}
extension GliaCoreDependency.ReactiveSwiftSignal {
  @discardableResult
  final public func observe(_ action: @escaping GliaCoreDependency.ReactiveSwiftSignal<Value, Error>.Observer.Action) -> (any GliaCoreDependency.ReactiveSwiftDisposable)?
  @discardableResult
  final public func observeResult(_ action: @escaping (Swift.Result<Value, Error>) -> Swift.Void) -> (any GliaCoreDependency.ReactiveSwiftDisposable)?
  @discardableResult
  final public func observeCompleted(_ action: @escaping () -> Swift.Void) -> (any GliaCoreDependency.ReactiveSwiftDisposable)?
  @discardableResult
  final public func observeFailed(_ action: @escaping (Error) -> Swift.Void) -> (any GliaCoreDependency.ReactiveSwiftDisposable)?
  @discardableResult
  final public func observeInterrupted(_ action: @escaping () -> Swift.Void) -> (any GliaCoreDependency.ReactiveSwiftDisposable)?
}
extension GliaCoreDependency.ReactiveSwiftSignal where Error == Swift.Never {
  @discardableResult
  final public func observeValues(_ action: @escaping (Value) -> Swift.Void) -> (any GliaCoreDependency.ReactiveSwiftDisposable)?
}
extension GliaCoreDependency.ReactiveSwiftSignal {
  final public func map<U>(_ transform: @escaping (Value) -> U) -> GliaCoreDependency.ReactiveSwiftSignal<U, Error>
  final public func map<U>(value: U) -> GliaCoreDependency.ReactiveSwiftSignal<U, Error>
  final public func map<U>(_ keyPath: Swift.KeyPath<Value, U>) -> GliaCoreDependency.ReactiveSwiftSignal<U, Error>
  final public func mapError<F>(_ transform: @escaping (Error) -> F) -> GliaCoreDependency.ReactiveSwiftSignal<Value, F> where F : Swift.Error
  final public func lazyMap<U>(on scheduler: any GliaCoreDependency.ReactiveSwiftScheduler, transform: @escaping (Value) -> U) -> GliaCoreDependency.ReactiveSwiftSignal<U, Error>
  final public func filter(_ isIncluded: @escaping (Value) -> Swift.Bool) -> GliaCoreDependency.ReactiveSwiftSignal<Value, Error>
  final public func compactMap<U>(_ transform: @escaping (Value) -> U?) -> GliaCoreDependency.ReactiveSwiftSignal<U, Error>
  @available(*, deprecated, renamed: "compactMap")
  final public func filterMap<U>(_ transform: @escaping (Value) -> U?) -> GliaCoreDependency.ReactiveSwiftSignal<U, Error>
}
extension GliaCoreDependency.ReactiveSwiftSignal where Value : GliaCoreDependency.ReactiveSwiftOptionalProtocol {
  final public func skipNil() -> GliaCoreDependency.ReactiveSwiftSignal<Value.Wrapped, Error>
}
extension GliaCoreDependency.ReactiveSwiftSignal {
  final public func take(first count: Swift.Int) -> GliaCoreDependency.ReactiveSwiftSignal<Value, Error>
  final public func collect() -> GliaCoreDependency.ReactiveSwiftSignal<[Value], Error>
  final public func collect(count: Swift.Int) -> GliaCoreDependency.ReactiveSwiftSignal<[Value], Error>
  final public func collect(_ shouldEmit: @escaping (_ collectedValues: [Value]) -> Swift.Bool) -> GliaCoreDependency.ReactiveSwiftSignal<[Value], Error>
  final public func collect(_ shouldEmit: @escaping (_ collected: [Value], _ latest: Value) -> Swift.Bool) -> GliaCoreDependency.ReactiveSwiftSignal<[Value], Error>
  final public func collect(every interval: Dispatch.DispatchTimeInterval, on scheduler: any GliaCoreDependency.ReactiveSwiftDateScheduler, skipEmpty: Swift.Bool = false, discardWhenCompleted: Swift.Bool = true) -> GliaCoreDependency.ReactiveSwiftSignal<[Value], Error>
  final public func observe(on scheduler: any GliaCoreDependency.ReactiveSwiftScheduler) -> GliaCoreDependency.ReactiveSwiftSignal<Value, Error>
}
extension GliaCoreDependency.ReactiveSwiftSignal {
  final public func combineLatest<U>(with other: GliaCoreDependency.ReactiveSwiftSignal<U, Error>) -> GliaCoreDependency.ReactiveSwiftSignal<(Value, U), Error>
  final public func merge(with other: GliaCoreDependency.ReactiveSwiftSignal<Value, Error>) -> GliaCoreDependency.ReactiveSwiftSignal<Value, Error>
  final public func delay(_ interval: Foundation.TimeInterval, on scheduler: any GliaCoreDependency.ReactiveSwiftDateScheduler) -> GliaCoreDependency.ReactiveSwiftSignal<Value, Error>
  final public func skip(first count: Swift.Int) -> GliaCoreDependency.ReactiveSwiftSignal<Value, Error>
  final public func materialize() -> GliaCoreDependency.ReactiveSwiftSignal<GliaCoreDependency.ReactiveSwiftSignal<Value, Error>.Event, Swift.Never>
  final public func materializeResults() -> GliaCoreDependency.ReactiveSwiftSignal<Swift.Result<Value, Error>, Swift.Never>
}
extension GliaCoreDependency.ReactiveSwiftSignal where Value : GliaCoreDependency.ReactiveSwiftEventProtocol, Error == Swift.Never {
  final public func dematerialize() -> GliaCoreDependency.ReactiveSwiftSignal<Value.Value, Value.Error>
}
extension GliaCoreDependency.ReactiveSwiftSignal where Error == Swift.Never {
  final public func dematerializeResults<Success, Failure>() -> GliaCoreDependency.ReactiveSwiftSignal<Success, Failure> where Value == Swift.Result<Success, Failure>, Failure : Swift.Error
}
extension GliaCoreDependency.ReactiveSwiftSignal {
  final public func on(event: ((GliaCoreDependency.ReactiveSwiftSignal<Value, Error>.Event) -> Swift.Void)? = nil, failed: ((Error) -> Swift.Void)? = nil, completed: (() -> Swift.Void)? = nil, interrupted: (() -> Swift.Void)? = nil, terminated: (() -> Swift.Void)? = nil, disposed: (() -> Swift.Void)? = nil, value: ((Value) -> Swift.Void)? = nil) -> GliaCoreDependency.ReactiveSwiftSignal<Value, Error>
}
extension GliaCoreDependency.ReactiveSwiftSignal {
  final public func sample<T>(with sampler: GliaCoreDependency.ReactiveSwiftSignal<T, Swift.Never>) -> GliaCoreDependency.ReactiveSwiftSignal<(Value, T), Error>
  final public func sample(on sampler: GliaCoreDependency.ReactiveSwiftSignal<(), Swift.Never>) -> GliaCoreDependency.ReactiveSwiftSignal<Value, Error>
  final public func withLatest<U>(from samplee: GliaCoreDependency.ReactiveSwiftSignal<U, Swift.Never>) -> GliaCoreDependency.ReactiveSwiftSignal<(Value, U), Error>
  final public func withLatest<U>(from samplee: GliaCoreDependency.ReactiveSwift.SignalProducer<U, Swift.Never>) -> GliaCoreDependency.ReactiveSwiftSignal<(Value, U), Error>
  final public func withLatest<Samplee>(from samplee: Samplee) -> GliaCoreDependency.ReactiveSwiftSignal<(Value, Samplee.Value), Error> where Samplee : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, Samplee.Error == Swift.Never
}
extension GliaCoreDependency.ReactiveSwiftSignal {
  final public func take(during lifetime: GliaCoreDependency.ReactiveSwiftSignal<Value, Error>.Lifetime) -> GliaCoreDependency.ReactiveSwiftSignal<Value, Error>
  final public func take(until trigger: GliaCoreDependency.ReactiveSwiftSignal<(), Swift.Never>) -> GliaCoreDependency.ReactiveSwiftSignal<Value, Error>
  final public func skip(until trigger: GliaCoreDependency.ReactiveSwiftSignal<(), Swift.Never>) -> GliaCoreDependency.ReactiveSwiftSignal<Value, Error>
  final public func combinePrevious(_ initial: Value) -> GliaCoreDependency.ReactiveSwiftSignal<(Value, Value), Error>
  final public func combinePrevious() -> GliaCoreDependency.ReactiveSwiftSignal<(Value, Value), Error>
  final public func reduce<U>(_ initialResult: U, _ nextPartialResult: @escaping (U, Value) -> U) -> GliaCoreDependency.ReactiveSwiftSignal<U, Error>
  final public func reduce<U>(into initialResult: U, _ nextPartialResult: @escaping (inout U, Value) -> Swift.Void) -> GliaCoreDependency.ReactiveSwiftSignal<U, Error>
  final public func scan<U>(_ initialResult: U, _ nextPartialResult: @escaping (U, Value) -> U) -> GliaCoreDependency.ReactiveSwiftSignal<U, Error>
  final public func scan<U>(into initialResult: U, _ nextPartialResult: @escaping (inout U, Value) -> Swift.Void) -> GliaCoreDependency.ReactiveSwiftSignal<U, Error>
  final public func scanMap<State, U>(_ initialState: State, _ next: @escaping (State, Value) -> (State, U)) -> GliaCoreDependency.ReactiveSwiftSignal<U, Error>
  final public func scanMap<State, U>(into initialState: State, _ next: @escaping (inout State, Value) -> U) -> GliaCoreDependency.ReactiveSwiftSignal<U, Error>
}
extension GliaCoreDependency.ReactiveSwiftSignal where Value : Swift.Equatable {
  final public func skipRepeats() -> GliaCoreDependency.ReactiveSwiftSignal<Value, Error>
}
extension GliaCoreDependency.ReactiveSwiftSignal {
  final public func skipRepeats(_ isEquivalent: @escaping (Value, Value) -> Swift.Bool) -> GliaCoreDependency.ReactiveSwiftSignal<Value, Error>
  final public func skip(while shouldContinue: @escaping (Value) -> Swift.Bool) -> GliaCoreDependency.ReactiveSwiftSignal<Value, Error>
  final public func take(untilReplacement signal: GliaCoreDependency.ReactiveSwiftSignal<Value, Error>) -> GliaCoreDependency.ReactiveSwiftSignal<Value, Error>
  final public func take(last count: Swift.Int) -> GliaCoreDependency.ReactiveSwiftSignal<Value, Error>
  final public func take(while shouldContinue: @escaping (Value) -> Swift.Bool) -> GliaCoreDependency.ReactiveSwiftSignal<Value, Error>
}
extension GliaCoreDependency.ReactiveSwiftSignal {
  final public func zip<U>(with other: GliaCoreDependency.ReactiveSwiftSignal<U, Error>) -> GliaCoreDependency.ReactiveSwiftSignal<(Value, U), Error>
  final public func throttle(_ interval: Foundation.TimeInterval, on scheduler: any GliaCoreDependency.ReactiveSwiftDateScheduler) -> GliaCoreDependency.ReactiveSwiftSignal<Value, Error>
  final public func throttle<P>(while shouldThrottle: P, on scheduler: any GliaCoreDependency.ReactiveSwiftScheduler) -> GliaCoreDependency.ReactiveSwiftSignal<Value, Error> where P : GliaCoreDependency.ReactiveSwiftPropertyProtocol, P.Value == Swift.Bool
  final public func debounce(_ interval: Foundation.TimeInterval, on scheduler: any GliaCoreDependency.ReactiveSwiftDateScheduler, discardWhenCompleted: Swift.Bool = true) -> GliaCoreDependency.ReactiveSwiftSignal<Value, Error>
}
extension GliaCoreDependency.ReactiveSwiftSignal {
  final public func uniqueValues<Identity>(_ transform: @escaping (Value) -> Identity) -> GliaCoreDependency.ReactiveSwiftSignal<Value, Error> where Identity : Swift.Hashable
}
extension GliaCoreDependency.ReactiveSwiftSignal where Value : Swift.Hashable {
  final public func uniqueValues() -> GliaCoreDependency.ReactiveSwiftSignal<Value, Error>
}
extension GliaCoreDependency.ReactiveSwiftSignal {
  public static func combineLatest<B>(_ a: GliaCoreDependency.ReactiveSwiftSignal<Value, Error>, _ b: GliaCoreDependency.ReactiveSwiftSignal<B, Error>) -> GliaCoreDependency.ReactiveSwiftSignal<(Value, B), Error>
  public static func combineLatest<B, C>(_ a: GliaCoreDependency.ReactiveSwiftSignal<Value, Error>, _ b: GliaCoreDependency.ReactiveSwiftSignal<B, Error>, _ c: GliaCoreDependency.ReactiveSwiftSignal<C, Error>) -> GliaCoreDependency.ReactiveSwiftSignal<(Value, B, C), Error>
  public static func combineLatest<B, C, D>(_ a: GliaCoreDependency.ReactiveSwiftSignal<Value, Error>, _ b: GliaCoreDependency.ReactiveSwiftSignal<B, Error>, _ c: GliaCoreDependency.ReactiveSwiftSignal<C, Error>, _ d: GliaCoreDependency.ReactiveSwiftSignal<D, Error>) -> GliaCoreDependency.ReactiveSwiftSignal<(Value, B, C, D), Error>
  public static func combineLatest<B, C, D, E>(_ a: GliaCoreDependency.ReactiveSwiftSignal<Value, Error>, _ b: GliaCoreDependency.ReactiveSwiftSignal<B, Error>, _ c: GliaCoreDependency.ReactiveSwiftSignal<C, Error>, _ d: GliaCoreDependency.ReactiveSwiftSignal<D, Error>, _ e: GliaCoreDependency.ReactiveSwiftSignal<E, Error>) -> GliaCoreDependency.ReactiveSwiftSignal<(Value, B, C, D, E), Error>
  public static func combineLatest<B, C, D, E, F>(_ a: GliaCoreDependency.ReactiveSwiftSignal<Value, Error>, _ b: GliaCoreDependency.ReactiveSwiftSignal<B, Error>, _ c: GliaCoreDependency.ReactiveSwiftSignal<C, Error>, _ d: GliaCoreDependency.ReactiveSwiftSignal<D, Error>, _ e: GliaCoreDependency.ReactiveSwiftSignal<E, Error>, _ f: GliaCoreDependency.ReactiveSwiftSignal<F, Error>) -> GliaCoreDependency.ReactiveSwiftSignal<(Value, B, C, D, E, F), Error>
  public static func combineLatest<B, C, D, E, F, G>(_ a: GliaCoreDependency.ReactiveSwiftSignal<Value, Error>, _ b: GliaCoreDependency.ReactiveSwiftSignal<B, Error>, _ c: GliaCoreDependency.ReactiveSwiftSignal<C, Error>, _ d: GliaCoreDependency.ReactiveSwiftSignal<D, Error>, _ e: GliaCoreDependency.ReactiveSwiftSignal<E, Error>, _ f: GliaCoreDependency.ReactiveSwiftSignal<F, Error>, _ g: GliaCoreDependency.ReactiveSwiftSignal<G, Error>) -> GliaCoreDependency.ReactiveSwiftSignal<(Value, B, C, D, E, F, G), Error>
  public static func combineLatest<B, C, D, E, F, G, H>(_ a: GliaCoreDependency.ReactiveSwiftSignal<Value, Error>, _ b: GliaCoreDependency.ReactiveSwiftSignal<B, Error>, _ c: GliaCoreDependency.ReactiveSwiftSignal<C, Error>, _ d: GliaCoreDependency.ReactiveSwiftSignal<D, Error>, _ e: GliaCoreDependency.ReactiveSwiftSignal<E, Error>, _ f: GliaCoreDependency.ReactiveSwiftSignal<F, Error>, _ g: GliaCoreDependency.ReactiveSwiftSignal<G, Error>, _ h: GliaCoreDependency.ReactiveSwiftSignal<H, Error>) -> GliaCoreDependency.ReactiveSwiftSignal<(Value, B, C, D, E, F, G, H), Error>
  public static func combineLatest<B, C, D, E, F, G, H, I>(_ a: GliaCoreDependency.ReactiveSwiftSignal<Value, Error>, _ b: GliaCoreDependency.ReactiveSwiftSignal<B, Error>, _ c: GliaCoreDependency.ReactiveSwiftSignal<C, Error>, _ d: GliaCoreDependency.ReactiveSwiftSignal<D, Error>, _ e: GliaCoreDependency.ReactiveSwiftSignal<E, Error>, _ f: GliaCoreDependency.ReactiveSwiftSignal<F, Error>, _ g: GliaCoreDependency.ReactiveSwiftSignal<G, Error>, _ h: GliaCoreDependency.ReactiveSwiftSignal<H, Error>, _ i: GliaCoreDependency.ReactiveSwiftSignal<I, Error>) -> GliaCoreDependency.ReactiveSwiftSignal<(Value, B, C, D, E, F, G, H, I), Error>
  public static func combineLatest<B, C, D, E, F, G, H, I, J>(_ a: GliaCoreDependency.ReactiveSwiftSignal<Value, Error>, _ b: GliaCoreDependency.ReactiveSwiftSignal<B, Error>, _ c: GliaCoreDependency.ReactiveSwiftSignal<C, Error>, _ d: GliaCoreDependency.ReactiveSwiftSignal<D, Error>, _ e: GliaCoreDependency.ReactiveSwiftSignal<E, Error>, _ f: GliaCoreDependency.ReactiveSwiftSignal<F, Error>, _ g: GliaCoreDependency.ReactiveSwiftSignal<G, Error>, _ h: GliaCoreDependency.ReactiveSwiftSignal<H, Error>, _ i: GliaCoreDependency.ReactiveSwiftSignal<I, Error>, _ j: GliaCoreDependency.ReactiveSwiftSignal<J, Error>) -> GliaCoreDependency.ReactiveSwiftSignal<(Value, B, C, D, E, F, G, H, I, J), Error>
  public static func combineLatest<S>(_ signals: S) -> GliaCoreDependency.ReactiveSwiftSignal<[Value], Error> where S : Swift.Sequence, S.Element == GliaCoreDependency.ReactiveSwiftSignal<Value, Error>
  public static func zip<B>(_ a: GliaCoreDependency.ReactiveSwiftSignal<Value, Error>, _ b: GliaCoreDependency.ReactiveSwiftSignal<B, Error>) -> GliaCoreDependency.ReactiveSwiftSignal<(Value, B), Error>
  public static func zip<B, C>(_ a: GliaCoreDependency.ReactiveSwiftSignal<Value, Error>, _ b: GliaCoreDependency.ReactiveSwiftSignal<B, Error>, _ c: GliaCoreDependency.ReactiveSwiftSignal<C, Error>) -> GliaCoreDependency.ReactiveSwiftSignal<(Value, B, C), Error>
  public static func zip<B, C, D>(_ a: GliaCoreDependency.ReactiveSwiftSignal<Value, Error>, _ b: GliaCoreDependency.ReactiveSwiftSignal<B, Error>, _ c: GliaCoreDependency.ReactiveSwiftSignal<C, Error>, _ d: GliaCoreDependency.ReactiveSwiftSignal<D, Error>) -> GliaCoreDependency.ReactiveSwiftSignal<(Value, B, C, D), Error>
  public static func zip<B, C, D, E>(_ a: GliaCoreDependency.ReactiveSwiftSignal<Value, Error>, _ b: GliaCoreDependency.ReactiveSwiftSignal<B, Error>, _ c: GliaCoreDependency.ReactiveSwiftSignal<C, Error>, _ d: GliaCoreDependency.ReactiveSwiftSignal<D, Error>, _ e: GliaCoreDependency.ReactiveSwiftSignal<E, Error>) -> GliaCoreDependency.ReactiveSwiftSignal<(Value, B, C, D, E), Error>
  public static func zip<B, C, D, E, F>(_ a: GliaCoreDependency.ReactiveSwiftSignal<Value, Error>, _ b: GliaCoreDependency.ReactiveSwiftSignal<B, Error>, _ c: GliaCoreDependency.ReactiveSwiftSignal<C, Error>, _ d: GliaCoreDependency.ReactiveSwiftSignal<D, Error>, _ e: GliaCoreDependency.ReactiveSwiftSignal<E, Error>, _ f: GliaCoreDependency.ReactiveSwiftSignal<F, Error>) -> GliaCoreDependency.ReactiveSwiftSignal<(Value, B, C, D, E, F), Error>
  public static func zip<B, C, D, E, F, G>(_ a: GliaCoreDependency.ReactiveSwiftSignal<Value, Error>, _ b: GliaCoreDependency.ReactiveSwiftSignal<B, Error>, _ c: GliaCoreDependency.ReactiveSwiftSignal<C, Error>, _ d: GliaCoreDependency.ReactiveSwiftSignal<D, Error>, _ e: GliaCoreDependency.ReactiveSwiftSignal<E, Error>, _ f: GliaCoreDependency.ReactiveSwiftSignal<F, Error>, _ g: GliaCoreDependency.ReactiveSwiftSignal<G, Error>) -> GliaCoreDependency.ReactiveSwiftSignal<(Value, B, C, D, E, F, G), Error>
  public static func zip<B, C, D, E, F, G, H>(_ a: GliaCoreDependency.ReactiveSwiftSignal<Value, Error>, _ b: GliaCoreDependency.ReactiveSwiftSignal<B, Error>, _ c: GliaCoreDependency.ReactiveSwiftSignal<C, Error>, _ d: GliaCoreDependency.ReactiveSwiftSignal<D, Error>, _ e: GliaCoreDependency.ReactiveSwiftSignal<E, Error>, _ f: GliaCoreDependency.ReactiveSwiftSignal<F, Error>, _ g: GliaCoreDependency.ReactiveSwiftSignal<G, Error>, _ h: GliaCoreDependency.ReactiveSwiftSignal<H, Error>) -> GliaCoreDependency.ReactiveSwiftSignal<(Value, B, C, D, E, F, G, H), Error>
  public static func zip<B, C, D, E, F, G, H, I>(_ a: GliaCoreDependency.ReactiveSwiftSignal<Value, Error>, _ b: GliaCoreDependency.ReactiveSwiftSignal<B, Error>, _ c: GliaCoreDependency.ReactiveSwiftSignal<C, Error>, _ d: GliaCoreDependency.ReactiveSwiftSignal<D, Error>, _ e: GliaCoreDependency.ReactiveSwiftSignal<E, Error>, _ f: GliaCoreDependency.ReactiveSwiftSignal<F, Error>, _ g: GliaCoreDependency.ReactiveSwiftSignal<G, Error>, _ h: GliaCoreDependency.ReactiveSwiftSignal<H, Error>, _ i: GliaCoreDependency.ReactiveSwiftSignal<I, Error>) -> GliaCoreDependency.ReactiveSwiftSignal<(Value, B, C, D, E, F, G, H, I), Error>
  public static func zip<B, C, D, E, F, G, H, I, J>(_ a: GliaCoreDependency.ReactiveSwiftSignal<Value, Error>, _ b: GliaCoreDependency.ReactiveSwiftSignal<B, Error>, _ c: GliaCoreDependency.ReactiveSwiftSignal<C, Error>, _ d: GliaCoreDependency.ReactiveSwiftSignal<D, Error>, _ e: GliaCoreDependency.ReactiveSwiftSignal<E, Error>, _ f: GliaCoreDependency.ReactiveSwiftSignal<F, Error>, _ g: GliaCoreDependency.ReactiveSwiftSignal<G, Error>, _ h: GliaCoreDependency.ReactiveSwiftSignal<H, Error>, _ i: GliaCoreDependency.ReactiveSwiftSignal<I, Error>, _ j: GliaCoreDependency.ReactiveSwiftSignal<J, Error>) -> GliaCoreDependency.ReactiveSwiftSignal<(Value, B, C, D, E, F, G, H, I, J), Error>
  public static func zip<S>(_ signals: S) -> GliaCoreDependency.ReactiveSwiftSignal<[Value], Error> where S : Swift.Sequence, S.Element == GliaCoreDependency.ReactiveSwiftSignal<Value, Error>
}
extension GliaCoreDependency.ReactiveSwiftSignal {
  final public func timeout(after interval: Foundation.TimeInterval, raising error: Error, on scheduler: any GliaCoreDependency.ReactiveSwiftDateScheduler) -> GliaCoreDependency.ReactiveSwiftSignal<Value, Error>
}
extension GliaCoreDependency.ReactiveSwiftSignal where Error == Swift.Never {
  final public func promoteError<F>(_: F.Type = F.self) -> GliaCoreDependency.ReactiveSwiftSignal<Value, F> where F : Swift.Error
  final public func promoteError(_: Error.Type = Error.self) -> GliaCoreDependency.ReactiveSwiftSignal<Value, Error>
  final public func timeout<NewError>(after interval: Foundation.TimeInterval, raising error: NewError, on scheduler: any GliaCoreDependency.ReactiveSwiftDateScheduler) -> GliaCoreDependency.ReactiveSwiftSignal<Value, NewError> where NewError : Swift.Error
}
extension GliaCoreDependency.ReactiveSwiftSignal where Value == Swift.Never {
  final public func promoteValue<U>(_: U.Type = U.self) -> GliaCoreDependency.ReactiveSwiftSignal<U, Error>
  final public func promoteValue(_: Value.Type = Value.self) -> GliaCoreDependency.ReactiveSwiftSignal<Value, Error>
}
extension GliaCoreDependency.ReactiveSwiftSignal where Value == Swift.Bool {
  final public func negate() -> GliaCoreDependency.ReactiveSwiftSignal<Value, Error>
  final public func and(_ signal: GliaCoreDependency.ReactiveSwiftSignal<Value, Error>) -> GliaCoreDependency.ReactiveSwiftSignal<Value, Error>
  public static func all<BooleansCollection>(_ booleans: BooleansCollection) -> GliaCoreDependency.ReactiveSwiftSignal<Value, Error> where BooleansCollection : Swift.Collection, BooleansCollection.Element == GliaCoreDependency.ReactiveSwiftSignal<Swift.Bool, Error>
  public static func all(_ booleans: GliaCoreDependency.ReactiveSwiftSignal<Value, Error>...) -> GliaCoreDependency.ReactiveSwiftSignal<Value, Error>
  final public func or(_ signal: GliaCoreDependency.ReactiveSwiftSignal<Value, Error>) -> GliaCoreDependency.ReactiveSwiftSignal<Value, Error>
  public static func any<BooleansCollection>(_ booleans: BooleansCollection) -> GliaCoreDependency.ReactiveSwiftSignal<Value, Error> where BooleansCollection : Swift.Collection, BooleansCollection.Element == GliaCoreDependency.ReactiveSwiftSignal<Swift.Bool, Error>
  public static func any(_ booleans: GliaCoreDependency.ReactiveSwiftSignal<Value, Error>...) -> GliaCoreDependency.ReactiveSwiftSignal<Value, Error>
}
extension GliaCoreDependency.ReactiveSwiftSignal {
  final public func attempt(_ action: @escaping (Value) -> Swift.Result<(), Error>) -> GliaCoreDependency.ReactiveSwiftSignal<Value, Error>
  final public func attemptMap<U>(_ transform: @escaping (Value) -> Swift.Result<U, Error>) -> GliaCoreDependency.ReactiveSwiftSignal<U, Error>
}
extension GliaCoreDependency.ReactiveSwiftSignal where Error == Swift.Never {
  final public func attempt(_ action: @escaping (Value) throws -> Swift.Void) -> GliaCoreDependency.ReactiveSwiftSignal<Value, any Swift.Error>
  final public func attemptMap<U>(_ transform: @escaping (Value) throws -> U) -> GliaCoreDependency.ReactiveSwiftSignal<U, any Swift.Error>
}
extension GliaCoreDependency.ReactiveSwiftSignal where Error == any Swift.Error {
  final public func attempt(_ action: @escaping (Value) throws -> Swift.Void) -> GliaCoreDependency.ReactiveSwiftSignal<Value, Error>
  final public func attemptMap<U>(_ transform: @escaping (Value) throws -> U) -> GliaCoreDependency.ReactiveSwiftSignal<U, Error>
}
extension GliaCoreDependency.ReactiveSwift {
  final public class Action<Input, Output, Error> where Error : Swift.Error {
    final public let lifetime: GliaCoreDependency.ReactiveSwift.Lifetime
    final public let events: GliaCoreDependency.ReactiveSwiftSignal<GliaCoreDependency.ReactiveSwiftSignal<Output, Error>.Event, Swift.Never>
    final public let values: GliaCoreDependency.ReactiveSwiftSignal<Output, Swift.Never>
    final public let errors: GliaCoreDependency.ReactiveSwiftSignal<Error, Swift.Never>
    final public let disabledErrors: GliaCoreDependency.ReactiveSwiftSignal<(), Swift.Never>
    final public let completed: GliaCoreDependency.ReactiveSwiftSignal<(), Swift.Never>
    final public let isExecuting: GliaCoreDependency.ReactiveSwift.Property<Swift.Bool>
    final public let isEnabled: GliaCoreDependency.ReactiveSwift.Property<Swift.Bool>
    public init<State>(state: State, enabledIf isEnabled: @escaping (State.Value) -> Swift.Bool, execute: @escaping (State.Value, Input) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Output, Error>) where State : GliaCoreDependency.ReactiveSwiftPropertyProtocol
    convenience public init<P>(state: P, execute: @escaping (P.Value, Input) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Output, Error>) where P : GliaCoreDependency.ReactiveSwiftPropertyProtocol
    convenience public init<P>(enabledIf isEnabled: P, execute: @escaping (Input) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Output, Error>) where P : GliaCoreDependency.ReactiveSwiftPropertyProtocol, P.Value == Swift.Bool
    convenience public init<P, T>(unwrapping state: P, execute: @escaping (T, Input) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Output, Error>) where P : GliaCoreDependency.ReactiveSwiftPropertyProtocol, P.Value == T?
    convenience public init<T, E>(validated state: GliaCoreDependency.ReactiveSwift.ValidatingProperty<T, E>, execute: @escaping (T, Input) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Output, Error>) where E : Swift.Error
    convenience public init(execute: @escaping (Input) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Output, Error>)
    @objc deinit
    final public func apply(_ input: Input) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Output, GliaCoreDependency.ReactiveSwift.ActionError<Error>>
  }
}
extension GliaCoreDependency.ReactiveSwift.Action : GliaCoreDependency.ReactiveSwiftBindingTargetProvider {
  final public var bindingTarget: GliaCoreDependency.ReactiveSwift.BindingTarget<Input> {
    get
  }
  public typealias Value = Input
}
extension GliaCoreDependency.ReactiveSwift.Action where Input == () {
  final public func apply() -> GliaCoreDependency.ReactiveSwift.SignalProducer<Output, GliaCoreDependency.ReactiveSwift.ActionError<Error>>
  convenience public init<P, T>(unwrapping state: P, execute: @escaping (T) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Output, Error>) where P : GliaCoreDependency.ReactiveSwiftPropertyProtocol, P.Value == T?
  convenience public init<T, E>(validated state: GliaCoreDependency.ReactiveSwift.ValidatingProperty<T, E>, execute: @escaping (T) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Output, Error>) where E : Swift.Error
  convenience public init<P, T>(state: P, execute: @escaping (T) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Output, Error>) where P : GliaCoreDependency.ReactiveSwiftPropertyProtocol, T == P.Value
}
extension GliaCoreDependency.ReactiveSwift {
  public enum ActionError<Error> : Swift.Error where Error : Swift.Error {
    case disabled
    case producerFailed(Error)
  }
}
extension GliaCoreDependency.ReactiveSwift.ActionError where Error : Swift.Equatable {
  public static func == (lhs: GliaCoreDependency.ReactiveSwift.ActionError<Error>, rhs: GliaCoreDependency.ReactiveSwift.ActionError<Error>) -> Swift.Bool
}
extension GliaCoreDependency.ReactiveSwift.ActionError : Swift.Equatable where Error : Swift.Equatable {
}
extension GliaCoreDependency.SwiftPhoenixClient {
  @_hasMissingDesignatedInitializers public class Channel {
    final public let topic: Swift.String
    public var params: GliaCoreDependency.SwiftPhoenixClient.Payload {
      get
      set
    }
    @objc deinit
    public var onMessage: (_ message: GliaCoreDependency.SwiftPhoenixClient.Message) -> GliaCoreDependency.SwiftPhoenixClient.Message
    @discardableResult
    public func join(timeout: Foundation.TimeInterval? = nil) -> GliaCoreDependency.SwiftPhoenixClient.Push
    @discardableResult
    public func onClose(_ callback: @escaping ((GliaCoreDependency.SwiftPhoenixClient.Message) -> Swift.Void)) -> Swift.Int
    @discardableResult
    public func delegateOnClose<Target>(to owner: Target, callback: @escaping ((Target, GliaCoreDependency.SwiftPhoenixClient.Message) -> Swift.Void)) -> Swift.Int where Target : AnyObject
    @discardableResult
    public func onError(_ callback: @escaping ((_ message: GliaCoreDependency.SwiftPhoenixClient.Message) -> Swift.Void)) -> Swift.Int
    @discardableResult
    public func delegateOnError<Target>(to owner: Target, callback: @escaping ((Target, GliaCoreDependency.SwiftPhoenixClient.Message) -> Swift.Void)) -> Swift.Int where Target : AnyObject
    @discardableResult
    public func on(_ event: Swift.String, callback: @escaping ((GliaCoreDependency.SwiftPhoenixClient.Message) -> Swift.Void)) -> Swift.Int
    @discardableResult
    public func delegateOn<Target>(_ event: Swift.String, to owner: Target, callback: @escaping ((Target, GliaCoreDependency.SwiftPhoenixClient.Message) -> Swift.Void)) -> Swift.Int where Target : AnyObject
    public func off(_ event: Swift.String, ref: Swift.Int? = nil)
    @discardableResult
    public func push(_ event: Swift.String, payload: GliaCoreDependency.SwiftPhoenixClient.Payload, timeout: Foundation.TimeInterval = Defaults.timeoutInterval) -> GliaCoreDependency.SwiftPhoenixClient.Push
    @discardableResult
    public func leave(timeout: Foundation.TimeInterval = Defaults.timeoutInterval) -> GliaCoreDependency.SwiftPhoenixClient.Push
    public func onMessage(callback: @escaping (GliaCoreDependency.SwiftPhoenixClient.Message) -> GliaCoreDependency.SwiftPhoenixClient.Message)
  }
}
extension GliaCoreDependency.SwiftPhoenixClient.Channel {
  public var isClosed: Swift.Bool {
    get
  }
  public var isErrored: Swift.Bool {
    get
  }
  public var isJoined: Swift.Bool {
    get
  }
  public var isJoining: Swift.Bool {
    get
  }
  public var isLeaving: Swift.Bool {
    get
  }
}
public protocol ReactiveSwiftDisposable : AnyObject {
  var isDisposed: Swift.Bool { get }
  func dispose()
}
extension GliaCoreDependency.ReactiveSwift {
  final public class AnyDisposable : GliaCoreDependency.ReactiveSwiftDisposable {
    final public var isDisposed: Swift.Bool {
      get
    }
    public init(_ action: @escaping () -> Swift.Void)
    public init()
    public init(_ disposable: any GliaCoreDependency.ReactiveSwiftDisposable)
    final public func dispose()
    @objc deinit
  }
  final public class CompositeDisposable : GliaCoreDependency.ReactiveSwiftDisposable {
    final public var isDisposed: Swift.Bool {
      get
    }
    public init<S>(_ disposables: S) where S : Swift.Sequence, S.Element == any GliaCoreDependency.ReactiveSwiftDisposable
    convenience public init<S>(_ disposables: S) where S : Swift.Sequence, S.Element == (any GliaCoreDependency.ReactiveSwiftDisposable)?
    convenience public init()
    final public func dispose()
    @discardableResult
    final public func add(_ disposable: (any GliaCoreDependency.ReactiveSwiftDisposable)?) -> (any GliaCoreDependency.ReactiveSwiftDisposable)?
    @discardableResult
    final public func add(_ action: @escaping () -> Swift.Void) -> (any GliaCoreDependency.ReactiveSwiftDisposable)?
    @objc deinit
    @discardableResult
    public static func += (lhs: GliaCoreDependency.ReactiveSwift.CompositeDisposable, rhs: (any GliaCoreDependency.ReactiveSwiftDisposable)?) -> (any GliaCoreDependency.ReactiveSwiftDisposable)?
    @discardableResult
    public static func += (lhs: GliaCoreDependency.ReactiveSwift.CompositeDisposable, rhs: @escaping () -> Swift.Void) -> (any GliaCoreDependency.ReactiveSwiftDisposable)?
  }
  final public class ScopedDisposable<Inner> : GliaCoreDependency.ReactiveSwiftDisposable where Inner : GliaCoreDependency.ReactiveSwiftDisposable {
    final public let inner: Inner
    final public var isDisposed: Swift.Bool {
      get
    }
    public init(_ disposable: Inner)
    @objc deinit
    final public func dispose()
  }
}
extension GliaCoreDependency.ReactiveSwift.ScopedDisposable where Inner == GliaCoreDependency.ReactiveSwift.AnyDisposable {
  convenience public init(_ disposable: any GliaCoreDependency.ReactiveSwiftDisposable)
}
extension GliaCoreDependency.ReactiveSwift.ScopedDisposable where Inner == GliaCoreDependency.ReactiveSwift.CompositeDisposable {
  @discardableResult
  public static func += (lhs: GliaCoreDependency.ReactiveSwift.ScopedDisposable<GliaCoreDependency.ReactiveSwift.CompositeDisposable>, rhs: (any GliaCoreDependency.ReactiveSwiftDisposable)?) -> (any GliaCoreDependency.ReactiveSwiftDisposable)?
  @discardableResult
  public static func += (lhs: GliaCoreDependency.ReactiveSwift.ScopedDisposable<GliaCoreDependency.ReactiveSwift.CompositeDisposable>, rhs: @escaping () -> Swift.Void) -> (any GliaCoreDependency.ReactiveSwiftDisposable)?
}
extension GliaCoreDependency.ReactiveSwift {
  final public class SerialDisposable : GliaCoreDependency.ReactiveSwiftDisposable {
    final public var isDisposed: Swift.Bool {
      get
    }
    final public var inner: (any GliaCoreDependency.ReactiveSwiftDisposable)? {
      get
      set(disposable)
    }
    public init(_ disposable: (any GliaCoreDependency.ReactiveSwiftDisposable)? = nil)
    final public func dispose()
    @objc deinit
  }
}
extension GliaCoreDependency.ReactiveSwift {
  public struct SignalProducer<Value, Error> where Error : Swift.Error {
    public typealias ProducedSignal = GliaCoreDependency.ReactiveSwiftSignal<Value, Error>
    public init<T>(_ base: T) where Value == T.Value, Error == T.Error, T : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible
    public init(_ signal: GliaCoreDependency.ReactiveSwiftSignal<Value, Error>)
    public init(_ startHandler: @escaping (GliaCoreDependency.ReactiveSwiftSignal<Value, Error>.Observer, GliaCoreDependency.ReactiveSwift.Lifetime) -> Swift.Void)
    public init(value: Value)
    public init(_ action: @escaping () -> Value)
    public init(_ action: @escaping () -> Swift.Result<Value, Error>)
    public init(error: Error)
    public init(result: Swift.Result<Value, Error>)
    public init<S>(_ values: S) where Value == S.Element, S : Swift.Sequence
    public init(values first: Value, _ second: Value, _ tail: Value...)
    public static var empty: GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error> {
      get
    }
    public static var never: GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error> {
      get
    }
  }
}
extension GliaCoreDependency.ReactiveSwift.SignalProducer where Error == Swift.Never {
  public init(value: Value)
  public init<S>(_ values: S) where Value == S.Element, S : Swift.Sequence
  public init(values first: Value, _ second: Value, _ tail: Value...)
}
extension GliaCoreDependency.ReactiveSwift.SignalProducer where Error == any Swift.Error {
  public init(_ action: @escaping () throws -> Value)
}
public protocol ReactiveSwiftSignalProducerConvertible {
  associatedtype Value
  associatedtype Error : Swift.Error
  var producer: GliaCoreDependency.ReactiveSwift.SignalProducer<Self.Value, Self.Error> { get }
}
public protocol ReactiveSwiftSignalProducerProtocol {
  associatedtype Value
  associatedtype Error : Swift.Error
  var producer: GliaCoreDependency.ReactiveSwift.SignalProducer<Self.Value, Self.Error> { get }
}
extension GliaCoreDependency.ReactiveSwift.SignalProducer : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, GliaCoreDependency.ReactiveSwiftSignalProducerProtocol {
  public var producer: GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error> {
    get
  }
}
extension GliaCoreDependency.ReactiveSwift.SignalProducer {
  @discardableResult
  public func start(_ observer: GliaCoreDependency.ReactiveSwiftSignal<Value, Error>.Observer = .init()) -> any GliaCoreDependency.ReactiveSwiftDisposable
  @discardableResult
  public func start(_ action: @escaping GliaCoreDependency.ReactiveSwiftSignal<Value, Error>.Observer.Action) -> any GliaCoreDependency.ReactiveSwiftDisposable
  @discardableResult
  public func startWithResult(_ action: @escaping (Swift.Result<Value, Error>) -> Swift.Void) -> any GliaCoreDependency.ReactiveSwiftDisposable
  @discardableResult
  public func startWithCompleted(_ action: @escaping () -> Swift.Void) -> any GliaCoreDependency.ReactiveSwiftDisposable
  @discardableResult
  public func startWithFailed(_ action: @escaping (Error) -> Swift.Void) -> any GliaCoreDependency.ReactiveSwiftDisposable
  @discardableResult
  public func startWithInterrupted(_ action: @escaping () -> Swift.Void) -> any GliaCoreDependency.ReactiveSwiftDisposable
}
extension GliaCoreDependency.ReactiveSwift.SignalProducer where Error == Swift.Never {
  @discardableResult
  public func startWithValues(_ action: @escaping (Value) -> Swift.Void) -> any GliaCoreDependency.ReactiveSwiftDisposable
}
extension GliaCoreDependency.ReactiveSwift.SignalProducer {
  public func lift<U, F>(_ transform: @escaping (GliaCoreDependency.ReactiveSwiftSignal<Value, Error>) -> GliaCoreDependency.ReactiveSwiftSignal<U, F>) -> GliaCoreDependency.ReactiveSwift.SignalProducer<U, F> where F : Swift.Error
  public func lift<U, F, V, G>(_ transform: @escaping (GliaCoreDependency.ReactiveSwiftSignal<Value, Error>) -> (GliaCoreDependency.ReactiveSwiftSignal<U, F>) -> GliaCoreDependency.ReactiveSwiftSignal<V, G>) -> (GliaCoreDependency.ReactiveSwift.SignalProducer<U, F>) -> GliaCoreDependency.ReactiveSwift.SignalProducer<V, G> where F : Swift.Error, G : Swift.Error
}
extension GliaCoreDependency.ReactiveSwift.SignalProducer {
  public func map<U>(_ transform: @escaping (Value) -> U) -> GliaCoreDependency.ReactiveSwift.SignalProducer<U, Error>
  public func map<U>(value: U) -> GliaCoreDependency.ReactiveSwift.SignalProducer<U, Error>
  public func map<U>(_ keyPath: Swift.KeyPath<Value, U>) -> GliaCoreDependency.ReactiveSwift.SignalProducer<U, Error>
  public func mapError<F>(_ transform: @escaping (Error) -> F) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, F> where F : Swift.Error
  public func lazyMap<U>(on scheduler: any GliaCoreDependency.ReactiveSwiftScheduler, transform: @escaping (Value) -> U) -> GliaCoreDependency.ReactiveSwift.SignalProducer<U, Error>
  public func filter(_ isIncluded: @escaping (Value) -> Swift.Bool) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>
  public func compactMap<U>(_ transform: @escaping (Value) -> U?) -> GliaCoreDependency.ReactiveSwift.SignalProducer<U, Error>
  @available(*, deprecated, renamed: "compactMap")
  public func filterMap<U>(_ transform: @escaping (Value) -> U?) -> GliaCoreDependency.ReactiveSwift.SignalProducer<U, Error>
  public func take(first count: Swift.Int) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>
  public func collect() -> GliaCoreDependency.ReactiveSwift.SignalProducer<[Value], Error>
  public func collect(count: Swift.Int) -> GliaCoreDependency.ReactiveSwift.SignalProducer<[Value], Error>
  public func collect(_ shouldEmit: @escaping (_ values: [Value]) -> Swift.Bool) -> GliaCoreDependency.ReactiveSwift.SignalProducer<[Value], Error>
  public func collect(_ shouldEmit: @escaping (_ collected: [Value], _ latest: Value) -> Swift.Bool) -> GliaCoreDependency.ReactiveSwift.SignalProducer<[Value], Error>
  public func collect(every interval: Dispatch.DispatchTimeInterval, on scheduler: any GliaCoreDependency.ReactiveSwiftDateScheduler, skipEmpty: Swift.Bool = false, discardWhenCompleted: Swift.Bool = true) -> GliaCoreDependency.ReactiveSwift.SignalProducer<[Value], Error>
  public func observe(on scheduler: any GliaCoreDependency.ReactiveSwiftScheduler) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>
  public func combineLatest<U>(with other: GliaCoreDependency.ReactiveSwift.SignalProducer<U, Error>) -> GliaCoreDependency.ReactiveSwift.SignalProducer<(Value, U), Error>
  public func combineLatest<Other>(with other: Other) -> GliaCoreDependency.ReactiveSwift.SignalProducer<(Value, Other.Value), Error> where Error == Other.Error, Other : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible
  public func merge(with other: GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>
  public func merge<Other>(with other: Other) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error> where Value == Other.Value, Error == Other.Error, Other : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible
  public func delay(_ interval: Foundation.TimeInterval, on scheduler: any GliaCoreDependency.ReactiveSwiftDateScheduler) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>
  public func skip(first count: Swift.Int) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>
  public func materialize() -> GliaCoreDependency.ReactiveSwift.SignalProducer<GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>.ProducedSignal.Event, Swift.Never>
  public func materializeResults() -> GliaCoreDependency.ReactiveSwift.SignalProducer<Swift.Result<Value, Error>, Swift.Never>
  public func sample<U>(with sampler: GliaCoreDependency.ReactiveSwift.SignalProducer<U, Swift.Never>) -> GliaCoreDependency.ReactiveSwift.SignalProducer<(Value, U), Error>
  public func sample<Sampler>(with sampler: Sampler) -> GliaCoreDependency.ReactiveSwift.SignalProducer<(Value, Sampler.Value), Error> where Sampler : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, Sampler.Error == Swift.Never
  public func sample(on sampler: GliaCoreDependency.ReactiveSwift.SignalProducer<(), Swift.Never>) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>
  public func sample<Sampler>(on sampler: Sampler) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error> where Sampler : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, Sampler.Error == Swift.Never, Sampler.Value == ()
  public func withLatest<U>(from samplee: GliaCoreDependency.ReactiveSwift.SignalProducer<U, Swift.Never>) -> GliaCoreDependency.ReactiveSwift.SignalProducer<(Value, U), Error>
  public func withLatest<Samplee>(from samplee: Samplee) -> GliaCoreDependency.ReactiveSwift.SignalProducer<(Value, Samplee.Value), Error> where Samplee : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, Samplee.Error == Swift.Never
  public func take(during lifetime: GliaCoreDependency.ReactiveSwift.Lifetime) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>
  public func take(until trigger: GliaCoreDependency.ReactiveSwift.SignalProducer<(), Swift.Never>) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>
  public func take<Trigger>(until trigger: Trigger) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error> where Trigger : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, Trigger.Error == Swift.Never, Trigger.Value == ()
  public func skip(until trigger: GliaCoreDependency.ReactiveSwift.SignalProducer<(), Swift.Never>) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>
  public func skip<Trigger>(until trigger: Trigger) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error> where Trigger : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, Trigger.Error == Swift.Never, Trigger.Value == ()
  public func combinePrevious(_ initial: Value) -> GliaCoreDependency.ReactiveSwift.SignalProducer<(Value, Value), Error>
  public func combinePrevious() -> GliaCoreDependency.ReactiveSwift.SignalProducer<(Value, Value), Error>
  public func reduce<U>(_ initialResult: U, _ nextPartialResult: @escaping (U, Value) -> U) -> GliaCoreDependency.ReactiveSwift.SignalProducer<U, Error>
  public func reduce<U>(into initialResult: U, _ nextPartialResult: @escaping (inout U, Value) -> Swift.Void) -> GliaCoreDependency.ReactiveSwift.SignalProducer<U, Error>
  public func scan<U>(_ initialResult: U, _ nextPartialResult: @escaping (U, Value) -> U) -> GliaCoreDependency.ReactiveSwift.SignalProducer<U, Error>
  public func scan<U>(into initialResult: U, _ nextPartialResult: @escaping (inout U, Value) -> Swift.Void) -> GliaCoreDependency.ReactiveSwift.SignalProducer<U, Error>
  public func scanMap<State, U>(_ initialState: State, _ next: @escaping (State, Value) -> (State, U)) -> GliaCoreDependency.ReactiveSwift.SignalProducer<U, Error>
  public func scanMap<State, U>(into initialState: State, _ next: @escaping (inout State, Value) -> U) -> GliaCoreDependency.ReactiveSwift.SignalProducer<U, Error>
  public func skipRepeats(_ isEquivalent: @escaping (Value, Value) -> Swift.Bool) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>
  public func skip(while shouldContinue: @escaping (Value) -> Swift.Bool) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>
  public func take(untilReplacement replacement: GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>
  public func take<Replacement>(untilReplacement replacement: Replacement) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error> where Value == Replacement.Value, Error == Replacement.Error, Replacement : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible
  public func take(last count: Swift.Int) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>
  public func take(while shouldContinue: @escaping (Value) -> Swift.Bool) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>
  public func zip<U>(with other: GliaCoreDependency.ReactiveSwift.SignalProducer<U, Error>) -> GliaCoreDependency.ReactiveSwift.SignalProducer<(Value, U), Error>
  public func zip<Other>(with other: Other) -> GliaCoreDependency.ReactiveSwift.SignalProducer<(Value, Other.Value), Error> where Error == Other.Error, Other : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible
  public func attempt(_ action: @escaping (Value) -> Swift.Result<(), Error>) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>
  public func attemptMap<U>(_ action: @escaping (Value) -> Swift.Result<U, Error>) -> GliaCoreDependency.ReactiveSwift.SignalProducer<U, Error>
  public func throttle(_ interval: Foundation.TimeInterval, on scheduler: any GliaCoreDependency.ReactiveSwiftDateScheduler) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>
  public func throttle<P>(while shouldThrottle: P, on scheduler: any GliaCoreDependency.ReactiveSwiftScheduler) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error> where P : GliaCoreDependency.ReactiveSwiftPropertyProtocol, P.Value == Swift.Bool
  public func debounce(_ interval: Foundation.TimeInterval, on scheduler: any GliaCoreDependency.ReactiveSwiftDateScheduler, discardWhenCompleted: Swift.Bool = true) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>
  public func timeout(after interval: Foundation.TimeInterval, raising error: Error, on scheduler: any GliaCoreDependency.ReactiveSwiftDateScheduler) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>
}
extension GliaCoreDependency.ReactiveSwift.SignalProducer where Value : GliaCoreDependency.ReactiveSwiftOptionalProtocol {
  public func skipNil() -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value.Wrapped, Error>
}
extension GliaCoreDependency.ReactiveSwift.SignalProducer where Value : GliaCoreDependency.ReactiveSwiftEventProtocol, Error == Swift.Never {
  public func dematerialize() -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value.Value, Value.Error>
}
extension GliaCoreDependency.ReactiveSwift.SignalProducer where Error == Swift.Never {
  public func dematerializeResults<Success, Failure>() -> GliaCoreDependency.ReactiveSwift.SignalProducer<Success, Failure> where Value == Swift.Result<Success, Failure>, Failure : Swift.Error
}
extension GliaCoreDependency.ReactiveSwift.SignalProducer where Error == Swift.Never {
  public func promoteError<F>(_: F.Type = F.self) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, F> where F : Swift.Error
  public func promoteError(_: Error.Type = Error.self) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>
  public func timeout<NewError>(after interval: Foundation.TimeInterval, raising error: NewError, on scheduler: any GliaCoreDependency.ReactiveSwiftDateScheduler) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, NewError> where NewError : Swift.Error
  public func attempt(_ action: @escaping (Value) throws -> Swift.Void) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, any Swift.Error>
  public func attemptMap<U>(_ action: @escaping (Value) throws -> U) -> GliaCoreDependency.ReactiveSwift.SignalProducer<U, any Swift.Error>
}
extension GliaCoreDependency.ReactiveSwift.SignalProducer where Error == any Swift.Error {
  public func attempt(_ action: @escaping (Value) throws -> Swift.Void) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>
  public func attemptMap<U>(_ transform: @escaping (Value) throws -> U) -> GliaCoreDependency.ReactiveSwift.SignalProducer<U, Error>
}
extension GliaCoreDependency.ReactiveSwift.SignalProducer where Value == Swift.Never {
  public func promoteValue<U>(_: U.Type = U.self) -> GliaCoreDependency.ReactiveSwift.SignalProducer<U, Error>
  public func promoteValue(_: Value.Type = Value.self) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>
}
extension GliaCoreDependency.ReactiveSwift.SignalProducer where Value : Swift.Equatable {
  public func skipRepeats() -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>
}
extension GliaCoreDependency.ReactiveSwift.SignalProducer {
  public func uniqueValues<Identity>(_ transform: @escaping (Value) -> Identity) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error> where Identity : Swift.Hashable
}
extension GliaCoreDependency.ReactiveSwift.SignalProducer where Value : Swift.Hashable {
  public func uniqueValues() -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>
}
extension GliaCoreDependency.ReactiveSwift.SignalProducer {
  public func on(starting: (() -> Swift.Void)? = nil, started: (() -> Swift.Void)? = nil, event: ((GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>.ProducedSignal.Event) -> Swift.Void)? = nil, failed: ((Error) -> Swift.Void)? = nil, completed: (() -> Swift.Void)? = nil, interrupted: (() -> Swift.Void)? = nil, terminated: (() -> Swift.Void)? = nil, disposed: (() -> Swift.Void)? = nil, value: ((Value) -> Swift.Void)? = nil) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>
  public func start(on scheduler: any GliaCoreDependency.ReactiveSwiftScheduler) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>
}
extension GliaCoreDependency.ReactiveSwift.SignalProducer {
  public static func combineLatest<A, B>(_ a: A, _ b: B) -> GliaCoreDependency.ReactiveSwift.SignalProducer<(Value, B.Value), Error> where Value == A.Value, Error == A.Error, A : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, B : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, A.Error == B.Error
  public static func combineLatest<A, B, C>(_ a: A, _ b: B, _ c: C) -> GliaCoreDependency.ReactiveSwift.SignalProducer<(Value, B.Value, C.Value), Error> where Value == A.Value, Error == A.Error, A : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, B : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, C : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, A.Error == B.Error, B.Error == C.Error
  public static func combineLatest<A, B, C, D>(_ a: A, _ b: B, _ c: C, _ d: D) -> GliaCoreDependency.ReactiveSwift.SignalProducer<(Value, B.Value, C.Value, D.Value), Error> where Value == A.Value, Error == A.Error, A : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, B : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, C : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, D : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error
  public static func combineLatest<A, B, C, D, E>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E) -> GliaCoreDependency.ReactiveSwift.SignalProducer<(Value, B.Value, C.Value, D.Value, E.Value), Error> where Value == A.Value, Error == A.Error, A : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, B : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, C : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, D : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, E : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error, D.Error == E.Error
  public static func combineLatest<A, B, C, D, E, F>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F) -> GliaCoreDependency.ReactiveSwift.SignalProducer<(Value, B.Value, C.Value, D.Value, E.Value, F.Value), Error> where Value == A.Value, Error == A.Error, A : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, B : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, C : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, D : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, E : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, F : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error, D.Error == E.Error, E.Error == F.Error
  public static func combineLatest<A, B, C, D, E, F, G>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F, _ g: G) -> GliaCoreDependency.ReactiveSwift.SignalProducer<(Value, B.Value, C.Value, D.Value, E.Value, F.Value, G.Value), Error> where Value == A.Value, Error == A.Error, A : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, B : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, C : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, D : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, E : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, F : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, G : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error, D.Error == E.Error, E.Error == F.Error, F.Error == G.Error
  public static func combineLatest<A, B, C, D, E, F, G, H>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F, _ g: G, _ h: H) -> GliaCoreDependency.ReactiveSwift.SignalProducer<(Value, B.Value, C.Value, D.Value, E.Value, F.Value, G.Value, H.Value), Error> where Value == A.Value, Error == A.Error, A : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, B : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, C : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, D : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, E : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, F : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, G : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, H : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error, D.Error == E.Error, E.Error == F.Error, F.Error == G.Error, G.Error == H.Error
  public static func combineLatest<A, B, C, D, E, F, G, H, I>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F, _ g: G, _ h: H, _ i: I) -> GliaCoreDependency.ReactiveSwift.SignalProducer<(Value, B.Value, C.Value, D.Value, E.Value, F.Value, G.Value, H.Value, I.Value), Error> where Value == A.Value, Error == A.Error, A : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, B : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, C : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, D : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, E : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, F : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, G : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, H : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, I : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error, D.Error == E.Error, E.Error == F.Error, F.Error == G.Error, G.Error == H.Error, H.Error == I.Error
  public static func combineLatest<A, B, C, D, E, F, G, H, I, J>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F, _ g: G, _ h: H, _ i: I, _ j: J) -> GliaCoreDependency.ReactiveSwift.SignalProducer<(Value, B.Value, C.Value, D.Value, E.Value, F.Value, G.Value, H.Value, I.Value, J.Value), Error> where Value == A.Value, Error == A.Error, A : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, B : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, C : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, D : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, E : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, F : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, G : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, H : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, I : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, J : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error, D.Error == E.Error, E.Error == F.Error, F.Error == G.Error, G.Error == H.Error, H.Error == I.Error, I.Error == J.Error
  public static func combineLatest<S>(_ producers: S) -> GliaCoreDependency.ReactiveSwift.SignalProducer<[Value], Error> where Value == S.Element.Value, Error == S.Element.Error, S : Swift.Sequence, S.Element : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible
  public static func combineLatest<S>(_ producers: S, emptySentinel: [S.Iterator.Element.Value]) -> GliaCoreDependency.ReactiveSwift.SignalProducer<[Value], Error> where Value == S.Element.Value, Error == S.Element.Error, S : Swift.Sequence, S.Element : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible
  public static func zip<A, B>(_ a: A, _ b: B) -> GliaCoreDependency.ReactiveSwift.SignalProducer<(Value, B.Value), Error> where Value == A.Value, Error == A.Error, A : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, B : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, A.Error == B.Error
  public static func zip<A, B, C>(_ a: A, _ b: B, _ c: C) -> GliaCoreDependency.ReactiveSwift.SignalProducer<(Value, B.Value, C.Value), Error> where Value == A.Value, Error == A.Error, A : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, B : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, C : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, A.Error == B.Error, B.Error == C.Error
  public static func zip<A, B, C, D>(_ a: A, _ b: B, _ c: C, _ d: D) -> GliaCoreDependency.ReactiveSwift.SignalProducer<(Value, B.Value, C.Value, D.Value), Error> where Value == A.Value, Error == A.Error, A : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, B : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, C : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, D : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error
  public static func zip<A, B, C, D, E>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E) -> GliaCoreDependency.ReactiveSwift.SignalProducer<(Value, B.Value, C.Value, D.Value, E.Value), Error> where Value == A.Value, Error == A.Error, A : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, B : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, C : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, D : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, E : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error, D.Error == E.Error
  public static func zip<A, B, C, D, E, F>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F) -> GliaCoreDependency.ReactiveSwift.SignalProducer<(Value, B.Value, C.Value, D.Value, E.Value, F.Value), Error> where Value == A.Value, Error == A.Error, A : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, B : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, C : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, D : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, E : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, F : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error, D.Error == E.Error, E.Error == F.Error
  public static func zip<A, B, C, D, E, F, G>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F, _ g: G) -> GliaCoreDependency.ReactiveSwift.SignalProducer<(Value, B.Value, C.Value, D.Value, E.Value, F.Value, G.Value), Error> where Value == A.Value, Error == A.Error, A : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, B : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, C : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, D : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, E : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, F : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, G : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error, D.Error == E.Error, E.Error == F.Error, F.Error == G.Error
  public static func zip<A, B, C, D, E, F, G, H>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F, _ g: G, _ h: H) -> GliaCoreDependency.ReactiveSwift.SignalProducer<(Value, B.Value, C.Value, D.Value, E.Value, F.Value, G.Value, H.Value), Error> where Value == A.Value, Error == A.Error, A : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, B : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, C : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, D : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, E : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, F : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, G : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, H : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error, D.Error == E.Error, E.Error == F.Error, F.Error == G.Error, G.Error == H.Error
  public static func zip<A, B, C, D, E, F, G, H, I>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F, _ g: G, _ h: H, _ i: I) -> GliaCoreDependency.ReactiveSwift.SignalProducer<(Value, B.Value, C.Value, D.Value, E.Value, F.Value, G.Value, H.Value, I.Value), Error> where Value == A.Value, Error == A.Error, A : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, B : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, C : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, D : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, E : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, F : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, G : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, H : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, I : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error, D.Error == E.Error, E.Error == F.Error, F.Error == G.Error, G.Error == H.Error, H.Error == I.Error
  public static func zip<A, B, C, D, E, F, G, H, I, J>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F, _ g: G, _ h: H, _ i: I, _ j: J) -> GliaCoreDependency.ReactiveSwift.SignalProducer<(Value, B.Value, C.Value, D.Value, E.Value, F.Value, G.Value, H.Value, I.Value, J.Value), Error> where Value == A.Value, Error == A.Error, A : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, B : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, C : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, D : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, E : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, F : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, G : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, H : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, I : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, J : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, A.Error == B.Error, B.Error == C.Error, C.Error == D.Error, D.Error == E.Error, E.Error == F.Error, F.Error == G.Error, G.Error == H.Error, H.Error == I.Error, I.Error == J.Error
  public static func zip<S>(_ producers: S) -> GliaCoreDependency.ReactiveSwift.SignalProducer<[Value], Error> where Value == S.Element.Value, Error == S.Element.Error, S : Swift.Sequence, S.Element : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible
  public static func zip<S>(_ producers: S, emptySentinel: [S.Iterator.Element.Value]) -> GliaCoreDependency.ReactiveSwift.SignalProducer<[Value], Error> where Value == S.Element.Value, Error == S.Element.Error, S : Swift.Sequence, S.Element : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible
}
extension GliaCoreDependency.ReactiveSwift.SignalProducer {
  public func `repeat`(_ count: Swift.Int) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>
  public func retry(upTo count: Swift.Int) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>
  public func retry(upTo count: Swift.Int, interval: Foundation.TimeInterval, on scheduler: any GliaCoreDependency.ReactiveSwiftDateScheduler) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>
  public func then<U>(_ replacement: GliaCoreDependency.ReactiveSwift.SignalProducer<U, Swift.Never>) -> GliaCoreDependency.ReactiveSwift.SignalProducer<U, Error>
  public func then<Replacement>(_ replacement: Replacement) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Replacement.Value, Error> where Replacement : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, Replacement.Error == Swift.Never
  public func then<U>(_ replacement: GliaCoreDependency.ReactiveSwift.SignalProducer<U, Error>) -> GliaCoreDependency.ReactiveSwift.SignalProducer<U, Error>
  public func then<Replacement>(_ replacement: Replacement) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Replacement.Value, Error> where Error == Replacement.Error, Replacement : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible
  public func then(_ replacement: GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>
  public func then<Replacement>(_ replacement: Replacement) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error> where Value == Replacement.Value, Error == Replacement.Error, Replacement : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible
}
extension GliaCoreDependency.ReactiveSwift.SignalProducer where Error == Swift.Never {
  public func then<U, F>(_ replacement: GliaCoreDependency.ReactiveSwift.SignalProducer<U, F>) -> GliaCoreDependency.ReactiveSwift.SignalProducer<U, F> where F : Swift.Error
  public func then<Replacement>(_ replacement: Replacement) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Replacement.Value, Replacement.Error> where Replacement : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible
  public func then<U>(_ replacement: GliaCoreDependency.ReactiveSwift.SignalProducer<U, Swift.Never>) -> GliaCoreDependency.ReactiveSwift.SignalProducer<U, Swift.Never>
  public func then<Replacement>(_ replacement: Replacement) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Replacement.Value, Swift.Never> where Replacement : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, Replacement.Error == Swift.Never
  public func then(_ replacement: GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Swift.Never>) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Swift.Never>
  public func then<Replacement>(_ replacement: Replacement) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Swift.Never> where Value == Replacement.Value, Replacement : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, Replacement.Error == Swift.Never
}
extension GliaCoreDependency.ReactiveSwift.SignalProducer {
  public func first() -> Swift.Result<Value, Error>?
  public func single() -> Swift.Result<Value, Error>?
  public func last() -> Swift.Result<Value, Error>?
  public func wait() -> Swift.Result<(), Error>
  public func replayLazily(upTo capacity: Swift.Int) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>
}
extension GliaCoreDependency.ReactiveSwift.SignalProducer where Value == Swift.Bool {
  public func negate() -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>
  public func and(_ booleans: GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>
  public func and<Booleans>(_ booleans: Booleans) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error> where Error == Booleans.Error, Booleans : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, Booleans.Value == Swift.Bool
  public static func all<BooleansCollection>(_ booleans: BooleansCollection) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error> where BooleansCollection : Swift.Collection, BooleansCollection.Element == GliaCoreDependency.ReactiveSwift.SignalProducer<Swift.Bool, Error>
  public static func all(_ booleans: GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>...) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>
  public static func all<Booleans, BooleansCollection>(_ booleans: BooleansCollection) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error> where Error == Booleans.Error, Booleans : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, Booleans == BooleansCollection.Element, BooleansCollection : Swift.Collection, Booleans.Value == Swift.Bool
  public func or(_ booleans: GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>
  public func or<Booleans>(_ booleans: Booleans) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error> where Error == Booleans.Error, Booleans : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, Booleans.Value == Swift.Bool
  public static func any<BooleansCollection>(_ booleans: BooleansCollection) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error> where BooleansCollection : Swift.Collection, BooleansCollection.Element == GliaCoreDependency.ReactiveSwift.SignalProducer<Swift.Bool, Error>
  public static func any(_ booleans: GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>...) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>
  public static func any<Booleans, BooleansCollection>(_ booleans: BooleansCollection) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error> where Error == Booleans.Error, Booleans : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, Booleans == BooleansCollection.Element, BooleansCollection : Swift.Collection, Booleans.Value == Swift.Bool
}
extension GliaCoreDependency.ReactiveSwift.SignalProducer where Value == Foundation.Date, Error == Swift.Never {
  public static func timer(interval: Dispatch.DispatchTimeInterval, on scheduler: any GliaCoreDependency.ReactiveSwiftDateScheduler) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>
  public static func timer(interval: Dispatch.DispatchTimeInterval, on scheduler: any GliaCoreDependency.ReactiveSwiftDateScheduler, leeway: Dispatch.DispatchTimeInterval) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>
}
extension GliaCoreDependency.ReactiveSwiftSignal {
  @available(*, unavailable, message: "Use the `Signal.init` that accepts a two-argument generator.")
  convenience public init(_ generator: (GliaCoreDependency.ReactiveSwiftSignal<Value, Error>.Observer) -> (any GliaCoreDependency.ReactiveSwiftDisposable)?)
}
extension GliaCoreDependency.ReactiveSwift.Lifetime {
  @discardableResult
  @available(*, unavailable, message: "Use `observeEnded(_:)` with a method reference to `dispose()` instead.")
  final public func add(_ d: (any GliaCoreDependency.ReactiveSwiftDisposable)?) -> (any GliaCoreDependency.ReactiveSwiftDisposable)?
}
public protocol PhoenixTransportProtocol {
  var readyState: GliaCoreDependency.SwiftPhoenixClient.PhoenixTransportReadyState { get }
  var delegate: (any GliaCoreDependency.PhoenixTransportDelegateProtocol)? { get set }
  func connect(with headers: [Swift.String : Any])
  func disconnect(code: Swift.Int, reason: Swift.String?)
  func send(data: Foundation.Data)
}
public protocol PhoenixTransportDelegateProtocol {
  func onOpen(response: Foundation.URLResponse?)
  func onError(error: any Swift.Error, response: Foundation.URLResponse?)
  func onMessage(message: Swift.String)
  func onClose(code: Swift.Int, reason: Swift.String?)
}
extension GliaCoreDependency.SwiftPhoenixClient {
  public typealias PhoenixTransport = GliaCoreDependency.PhoenixTransportProtocol
  public typealias PhoenixTransportDelegate = GliaCoreDependency.PhoenixTransportDelegateProtocol
}
extension GliaCoreDependency.SwiftPhoenixClient {
  public enum PhoenixTransportReadyState {
    case connecting
    case open
    case closing
    case closed
    public static func == (a: GliaCoreDependency.SwiftPhoenixClient.PhoenixTransportReadyState, b: GliaCoreDependency.SwiftPhoenixClient.PhoenixTransportReadyState) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
}
extension GliaCoreDependency.SwiftPhoenixClient {
  @objc @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
  open class URLSessionTransport : ObjectiveC.NSObject, GliaCoreDependency.SwiftPhoenixClient.PhoenixTransport, Foundation.URLSessionWebSocketDelegate {
    public init(url: Foundation.URL, configuration: Foundation.URLSessionConfiguration = .default)
    public var readyState: GliaCoreDependency.SwiftPhoenixClient.PhoenixTransportReadyState
    public var delegate: (any GliaCoreDependency.PhoenixTransportDelegateProtocol)?
    public func connect(with headers: [Swift.String : Any])
    open func disconnect(code: Swift.Int, reason: Swift.String?)
    open func send(data: Foundation.Data)
    @objc open func urlSession(_ session: Foundation.URLSession, webSocketTask: Foundation.URLSessionWebSocketTask, didOpenWithProtocol protocol: Swift.String?)
    @objc open func urlSession(_ session: Foundation.URLSession, webSocketTask: Foundation.URLSessionWebSocketTask, didCloseWith closeCode: Foundation.URLSessionWebSocketTask.CloseCode, reason: Foundation.Data?)
    @objc open func urlSession(_ session: Foundation.URLSession, task: Foundation.URLSessionTask, didCompleteWithError error: (any Swift.Error)?)
    @objc deinit
  }
}
public protocol ReactiveSwiftScheduler : AnyObject {
  @discardableResult
  func schedule(_ action: @escaping () -> Swift.Void) -> (any GliaCoreDependency.ReactiveSwiftDisposable)?
}
public protocol ReactiveSwiftDateScheduler : GliaCoreDependency.ReactiveSwiftScheduler {
  var currentDate: Foundation.Date { get }
  @discardableResult
  func schedule(after date: Foundation.Date, action: @escaping () -> Swift.Void) -> (any GliaCoreDependency.ReactiveSwiftDisposable)?
  @discardableResult
  func schedule(after date: Foundation.Date, interval: Dispatch.DispatchTimeInterval, leeway: Dispatch.DispatchTimeInterval, action: @escaping () -> Swift.Void) -> (any GliaCoreDependency.ReactiveSwiftDisposable)?
}
extension GliaCoreDependency.ReactiveSwift {
  final public class ImmediateScheduler : GliaCoreDependency.ReactiveSwiftScheduler {
    public init()
    @discardableResult
    final public func schedule(_ action: @escaping () -> Swift.Void) -> (any GliaCoreDependency.ReactiveSwiftDisposable)?
    @objc deinit
  }
  final public class UIScheduler : GliaCoreDependency.ReactiveSwiftScheduler {
    @objc deinit
    public init()
    @discardableResult
    final public func schedule(_ action: @escaping () -> Swift.Void) -> (any GliaCoreDependency.ReactiveSwiftDisposable)?
  }
  @_hasMissingDesignatedInitializers final public class QueueScheduler : GliaCoreDependency.ReactiveSwiftDateScheduler {
    public static let main: GliaCoreDependency.ReactiveSwift.QueueScheduler
    final public var currentDate: Foundation.Date {
      get
    }
    final public let queue: Dispatch.DispatchQueue
    @available(macOS, deprecated: 10.10, obsoleted: 10.11, message: "Use init(qos:name:targeting:) instead")
    @available(iOS, deprecated: 8.0, obsoleted: 9.0, message: "Use init(qos:name:targeting:) instead.")
    convenience public init(queue: Dispatch.DispatchQueue, name: Swift.String = "org.reactivecocoa.ReactiveSwift.QueueScheduler")
    @available(macOS 10.10, *)
    convenience public init(qos: Dispatch.DispatchQoS = .default, name: Swift.String = "org.reactivecocoa.ReactiveSwift.QueueScheduler", targeting targetQueue: Dispatch.DispatchQueue? = nil)
    @discardableResult
    final public func schedule(_ action: @escaping () -> Swift.Void) -> (any GliaCoreDependency.ReactiveSwiftDisposable)?
    @discardableResult
    final public func schedule(after date: Foundation.Date, action: @escaping () -> Swift.Void) -> (any GliaCoreDependency.ReactiveSwiftDisposable)?
    @discardableResult
    final public func schedule(after date: Foundation.Date, interval: Dispatch.DispatchTimeInterval, action: @escaping () -> Swift.Void) -> (any GliaCoreDependency.ReactiveSwiftDisposable)?
    @discardableResult
    final public func schedule(after date: Foundation.Date, interval: Dispatch.DispatchTimeInterval, leeway: Dispatch.DispatchTimeInterval, action: @escaping () -> Swift.Void) -> (any GliaCoreDependency.ReactiveSwiftDisposable)?
    @objc deinit
  }
  final public class TestScheduler : GliaCoreDependency.ReactiveSwiftDateScheduler {
    final public var currentDate: Foundation.Date {
      get
    }
    public init(startDate: Foundation.Date = Date(timeIntervalSinceReferenceDate: 0))
    @discardableResult
    final public func schedule(_ action: @escaping () -> Swift.Void) -> (any GliaCoreDependency.ReactiveSwiftDisposable)?
    @discardableResult
    final public func schedule(after delay: Dispatch.DispatchTimeInterval, action: @escaping () -> Swift.Void) -> (any GliaCoreDependency.ReactiveSwiftDisposable)?
    @discardableResult
    final public func schedule(after date: Foundation.Date, action: @escaping () -> Swift.Void) -> (any GliaCoreDependency.ReactiveSwiftDisposable)?
    @discardableResult
    final public func schedule(after delay: Dispatch.DispatchTimeInterval, interval: Dispatch.DispatchTimeInterval, leeway: Dispatch.DispatchTimeInterval = .seconds(0), action: @escaping () -> Swift.Void) -> (any GliaCoreDependency.ReactiveSwiftDisposable)?
    final public func schedule(after date: Foundation.Date, interval: Dispatch.DispatchTimeInterval, leeway: Dispatch.DispatchTimeInterval = .seconds(0), action: @escaping () -> Swift.Void) -> (any GliaCoreDependency.ReactiveSwiftDisposable)?
    final public func advance()
    final public func advance(by interval: Dispatch.DispatchTimeInterval)
    final public func advance(to newDate: Foundation.Date)
    final public func run()
    final public func rewind(by interval: Dispatch.DispatchTimeInterval)
    @objc deinit
  }
}
extension GliaCoreDependency.SwiftPhoenixClient {
  @_hasMissingDesignatedInitializers public class Message {
    final public let ref: Swift.String
    final public let topic: Swift.String
    final public let event: Swift.String
    public var payload: GliaCoreDependency.SwiftPhoenixClient.Payload {
      get
    }
    public var status: Swift.String? {
      get
    }
    @objc deinit
  }
}
public protocol ReactiveSwiftOptionalProtocol : Swift.ExpressibleByNilLiteral {
  associatedtype Wrapped
  init(reconstructing value: Self.Wrapped?)
  var optional: Self.Wrapped? { get }
}
extension Swift.Optional : GliaCoreDependency.ReactiveSwiftOptionalProtocol {
  public var optional: Wrapped? {
    get
  }
  public init(reconstructing value: Wrapped?)
}
public protocol ReactiveSwiftPropertyProtocol : AnyObject, GliaCoreDependency.ReactiveSwiftBindingSource {
  var value: Self.Value { get }
  var producer: GliaCoreDependency.ReactiveSwift.SignalProducer<Self.Value, Swift.Never> { get }
  var signal: GliaCoreDependency.ReactiveSwiftSignal<Self.Value, Swift.Never> { get }
}
public protocol ReactiveSwiftMutablePropertyProtocol : GliaCoreDependency.ReactiveSwiftBindingTargetProvider, GliaCoreDependency.ReactiveSwiftPropertyProtocol {
  var value: Self.Value { get set }
  var lifetime: GliaCoreDependency.ReactiveSwift.Lifetime { get }
}
extension GliaCoreDependency.ReactiveSwiftMutablePropertyProtocol {
  public var bindingTarget: GliaCoreDependency.ReactiveSwift.BindingTarget<Self.Value> {
    get
  }
}
public protocol ReactiveSwiftComposableMutablePropertyProtocol : GliaCoreDependency.ReactiveSwiftMutablePropertyProtocol {
  func withValue<Result>(_ action: (Self.Value) throws -> Result) rethrows -> Result
  func modify<Result>(_ action: (inout Self.Value) throws -> Result) rethrows -> Result
}
extension GliaCoreDependency.ReactiveSwiftPropertyProtocol {
  public func map<U>(_ transform: @escaping (Self.Value) -> U) -> GliaCoreDependency.ReactiveSwift.Property<U>
  public func map<U>(value: U) -> GliaCoreDependency.ReactiveSwift.Property<U>
  public func map<U>(_ keyPath: Swift.KeyPath<Self.Value, U>) -> GliaCoreDependency.ReactiveSwift.Property<U>
  public func filter(initial: Self.Value, _ predicate: @escaping (Self.Value) -> Swift.Bool) -> GliaCoreDependency.ReactiveSwift.Property<Self.Value>
  public func combineLatest<P>(with other: P) -> GliaCoreDependency.ReactiveSwift.Property<(Self.Value, P.Value)> where P : GliaCoreDependency.ReactiveSwiftPropertyProtocol
  public func zip<P>(with other: P) -> GliaCoreDependency.ReactiveSwift.Property<(Self.Value, P.Value)> where P : GliaCoreDependency.ReactiveSwiftPropertyProtocol
  public func combinePrevious(_ initial: Self.Value) -> GliaCoreDependency.ReactiveSwift.Property<(Self.Value, Self.Value)>
  public func skipRepeats(_ isEquivalent: @escaping (Self.Value, Self.Value) -> Swift.Bool) -> GliaCoreDependency.ReactiveSwift.Property<Self.Value>
}
extension GliaCoreDependency.ReactiveSwiftPropertyProtocol where Self.Value : Swift.Equatable {
  public func skipRepeats() -> GliaCoreDependency.ReactiveSwift.Property<Self.Value>
}
extension GliaCoreDependency.ReactiveSwiftPropertyProtocol where Self.Value : GliaCoreDependency.ReactiveSwiftPropertyProtocol {
  public func flatten(_ strategy: GliaCoreDependency.ReactiveSwift.FlattenStrategy) -> GliaCoreDependency.ReactiveSwift.Property<Self.Value.Value>
}
extension GliaCoreDependency.ReactiveSwiftPropertyProtocol {
  public func flatMap<P>(_ strategy: GliaCoreDependency.ReactiveSwift.FlattenStrategy, _ transform: @escaping (Self.Value) -> P) -> GliaCoreDependency.ReactiveSwift.Property<P.Value> where P : GliaCoreDependency.ReactiveSwiftPropertyProtocol
  public func uniqueValues<Identity>(_ transform: @escaping (Self.Value) -> Identity) -> GliaCoreDependency.ReactiveSwift.Property<Self.Value> where Identity : Swift.Hashable
}
extension GliaCoreDependency.ReactiveSwiftPropertyProtocol where Self.Value : Swift.Hashable {
  public func uniqueValues() -> GliaCoreDependency.ReactiveSwift.Property<Self.Value>
}
extension GliaCoreDependency.ReactiveSwiftPropertyProtocol {
  public static func combineLatest<A, B>(_ a: A, _ b: B) -> GliaCoreDependency.ReactiveSwift.Property<(A.Value, B.Value)> where A : GliaCoreDependency.ReactiveSwiftPropertyProtocol, B : GliaCoreDependency.ReactiveSwiftPropertyProtocol, Self.Value == A.Value
  public static func combineLatest<A, B, C>(_ a: A, _ b: B, _ c: C) -> GliaCoreDependency.ReactiveSwift.Property<(Self.Value, B.Value, C.Value)> where A : GliaCoreDependency.ReactiveSwiftPropertyProtocol, B : GliaCoreDependency.ReactiveSwiftPropertyProtocol, C : GliaCoreDependency.ReactiveSwiftPropertyProtocol, Self.Value == A.Value
  public static func combineLatest<A, B, C, D>(_ a: A, _ b: B, _ c: C, _ d: D) -> GliaCoreDependency.ReactiveSwift.Property<(Self.Value, B.Value, C.Value, D.Value)> where A : GliaCoreDependency.ReactiveSwiftPropertyProtocol, B : GliaCoreDependency.ReactiveSwiftPropertyProtocol, C : GliaCoreDependency.ReactiveSwiftPropertyProtocol, D : GliaCoreDependency.ReactiveSwiftPropertyProtocol, Self.Value == A.Value
  public static func combineLatest<A, B, C, D, E>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E) -> GliaCoreDependency.ReactiveSwift.Property<(Self.Value, B.Value, C.Value, D.Value, E.Value)> where A : GliaCoreDependency.ReactiveSwiftPropertyProtocol, B : GliaCoreDependency.ReactiveSwiftPropertyProtocol, C : GliaCoreDependency.ReactiveSwiftPropertyProtocol, D : GliaCoreDependency.ReactiveSwiftPropertyProtocol, E : GliaCoreDependency.ReactiveSwiftPropertyProtocol, Self.Value == A.Value
  public static func combineLatest<A, B, C, D, E, F>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F) -> GliaCoreDependency.ReactiveSwift.Property<(Self.Value, B.Value, C.Value, D.Value, E.Value, F.Value)> where A : GliaCoreDependency.ReactiveSwiftPropertyProtocol, B : GliaCoreDependency.ReactiveSwiftPropertyProtocol, C : GliaCoreDependency.ReactiveSwiftPropertyProtocol, D : GliaCoreDependency.ReactiveSwiftPropertyProtocol, E : GliaCoreDependency.ReactiveSwiftPropertyProtocol, F : GliaCoreDependency.ReactiveSwiftPropertyProtocol, Self.Value == A.Value
  public static func combineLatest<A, B, C, D, E, F, G>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F, _ g: G) -> GliaCoreDependency.ReactiveSwift.Property<(Self.Value, B.Value, C.Value, D.Value, E.Value, F.Value, G.Value)> where A : GliaCoreDependency.ReactiveSwiftPropertyProtocol, B : GliaCoreDependency.ReactiveSwiftPropertyProtocol, C : GliaCoreDependency.ReactiveSwiftPropertyProtocol, D : GliaCoreDependency.ReactiveSwiftPropertyProtocol, E : GliaCoreDependency.ReactiveSwiftPropertyProtocol, F : GliaCoreDependency.ReactiveSwiftPropertyProtocol, G : GliaCoreDependency.ReactiveSwiftPropertyProtocol, Self.Value == A.Value
  public static func combineLatest<A, B, C, D, E, F, G, H>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F, _ g: G, _ h: H) -> GliaCoreDependency.ReactiveSwift.Property<(Self.Value, B.Value, C.Value, D.Value, E.Value, F.Value, G.Value, H.Value)> where A : GliaCoreDependency.ReactiveSwiftPropertyProtocol, B : GliaCoreDependency.ReactiveSwiftPropertyProtocol, C : GliaCoreDependency.ReactiveSwiftPropertyProtocol, D : GliaCoreDependency.ReactiveSwiftPropertyProtocol, E : GliaCoreDependency.ReactiveSwiftPropertyProtocol, F : GliaCoreDependency.ReactiveSwiftPropertyProtocol, G : GliaCoreDependency.ReactiveSwiftPropertyProtocol, H : GliaCoreDependency.ReactiveSwiftPropertyProtocol, Self.Value == A.Value
  public static func combineLatest<A, B, C, D, E, F, G, H, I>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F, _ g: G, _ h: H, _ i: I) -> GliaCoreDependency.ReactiveSwift.Property<(Self.Value, B.Value, C.Value, D.Value, E.Value, F.Value, G.Value, H.Value, I.Value)> where A : GliaCoreDependency.ReactiveSwiftPropertyProtocol, B : GliaCoreDependency.ReactiveSwiftPropertyProtocol, C : GliaCoreDependency.ReactiveSwiftPropertyProtocol, D : GliaCoreDependency.ReactiveSwiftPropertyProtocol, E : GliaCoreDependency.ReactiveSwiftPropertyProtocol, F : GliaCoreDependency.ReactiveSwiftPropertyProtocol, G : GliaCoreDependency.ReactiveSwiftPropertyProtocol, H : GliaCoreDependency.ReactiveSwiftPropertyProtocol, I : GliaCoreDependency.ReactiveSwiftPropertyProtocol, Self.Value == A.Value
  public static func combineLatest<A, B, C, D, E, F, G, H, I, J>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F, _ g: G, _ h: H, _ i: I, _ j: J) -> GliaCoreDependency.ReactiveSwift.Property<(Self.Value, B.Value, C.Value, D.Value, E.Value, F.Value, G.Value, H.Value, I.Value, J.Value)> where A : GliaCoreDependency.ReactiveSwiftPropertyProtocol, B : GliaCoreDependency.ReactiveSwiftPropertyProtocol, C : GliaCoreDependency.ReactiveSwiftPropertyProtocol, D : GliaCoreDependency.ReactiveSwiftPropertyProtocol, E : GliaCoreDependency.ReactiveSwiftPropertyProtocol, F : GliaCoreDependency.ReactiveSwiftPropertyProtocol, G : GliaCoreDependency.ReactiveSwiftPropertyProtocol, H : GliaCoreDependency.ReactiveSwiftPropertyProtocol, I : GliaCoreDependency.ReactiveSwiftPropertyProtocol, J : GliaCoreDependency.ReactiveSwiftPropertyProtocol, Self.Value == A.Value
  public static func combineLatest<S>(_ properties: S) -> GliaCoreDependency.ReactiveSwift.Property<[S.Iterator.Element.Value]>? where S : Swift.Sequence, S.Element : GliaCoreDependency.ReactiveSwiftPropertyProtocol
  public static func combineLatest<S>(_ properties: S, emptySentinel: [S.Iterator.Element.Value]) -> GliaCoreDependency.ReactiveSwift.Property<[S.Iterator.Element.Value]> where S : Swift.Sequence, S.Element : GliaCoreDependency.ReactiveSwiftPropertyProtocol
  public static func zip<A, B>(_ a: A, _ b: B) -> GliaCoreDependency.ReactiveSwift.Property<(Self.Value, B.Value)> where A : GliaCoreDependency.ReactiveSwiftPropertyProtocol, B : GliaCoreDependency.ReactiveSwiftPropertyProtocol, Self.Value == A.Value
  public static func zip<A, B, C>(_ a: A, _ b: B, _ c: C) -> GliaCoreDependency.ReactiveSwift.Property<(Self.Value, B.Value, C.Value)> where A : GliaCoreDependency.ReactiveSwiftPropertyProtocol, B : GliaCoreDependency.ReactiveSwiftPropertyProtocol, C : GliaCoreDependency.ReactiveSwiftPropertyProtocol, Self.Value == A.Value
  public static func zip<A, B, C, D>(_ a: A, _ b: B, _ c: C, _ d: D) -> GliaCoreDependency.ReactiveSwift.Property<(Self.Value, B.Value, C.Value, D.Value)> where A : GliaCoreDependency.ReactiveSwiftPropertyProtocol, B : GliaCoreDependency.ReactiveSwiftPropertyProtocol, C : GliaCoreDependency.ReactiveSwiftPropertyProtocol, D : GliaCoreDependency.ReactiveSwiftPropertyProtocol, Self.Value == A.Value
  public static func zip<A, B, C, D, E>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E) -> GliaCoreDependency.ReactiveSwift.Property<(Self.Value, B.Value, C.Value, D.Value, E.Value)> where A : GliaCoreDependency.ReactiveSwiftPropertyProtocol, B : GliaCoreDependency.ReactiveSwiftPropertyProtocol, C : GliaCoreDependency.ReactiveSwiftPropertyProtocol, D : GliaCoreDependency.ReactiveSwiftPropertyProtocol, E : GliaCoreDependency.ReactiveSwiftPropertyProtocol, Self.Value == A.Value
  public static func zip<A, B, C, D, E, F>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F) -> GliaCoreDependency.ReactiveSwift.Property<(Self.Value, B.Value, C.Value, D.Value, E.Value, F.Value)> where A : GliaCoreDependency.ReactiveSwiftPropertyProtocol, B : GliaCoreDependency.ReactiveSwiftPropertyProtocol, C : GliaCoreDependency.ReactiveSwiftPropertyProtocol, D : GliaCoreDependency.ReactiveSwiftPropertyProtocol, E : GliaCoreDependency.ReactiveSwiftPropertyProtocol, F : GliaCoreDependency.ReactiveSwiftPropertyProtocol, Self.Value == A.Value
  public static func zip<A, B, C, D, E, F, G>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F, _ g: G) -> GliaCoreDependency.ReactiveSwift.Property<(Self.Value, B.Value, C.Value, D.Value, E.Value, F.Value, G.Value)> where A : GliaCoreDependency.ReactiveSwiftPropertyProtocol, B : GliaCoreDependency.ReactiveSwiftPropertyProtocol, C : GliaCoreDependency.ReactiveSwiftPropertyProtocol, D : GliaCoreDependency.ReactiveSwiftPropertyProtocol, E : GliaCoreDependency.ReactiveSwiftPropertyProtocol, F : GliaCoreDependency.ReactiveSwiftPropertyProtocol, G : GliaCoreDependency.ReactiveSwiftPropertyProtocol, Self.Value == A.Value
  public static func zip<A, B, C, D, E, F, G, H>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F, _ g: G, _ h: H) -> GliaCoreDependency.ReactiveSwift.Property<(Self.Value, B.Value, C.Value, D.Value, E.Value, F.Value, G.Value, H.Value)> where A : GliaCoreDependency.ReactiveSwiftPropertyProtocol, B : GliaCoreDependency.ReactiveSwiftPropertyProtocol, C : GliaCoreDependency.ReactiveSwiftPropertyProtocol, D : GliaCoreDependency.ReactiveSwiftPropertyProtocol, E : GliaCoreDependency.ReactiveSwiftPropertyProtocol, F : GliaCoreDependency.ReactiveSwiftPropertyProtocol, G : GliaCoreDependency.ReactiveSwiftPropertyProtocol, H : GliaCoreDependency.ReactiveSwiftPropertyProtocol, Self.Value == A.Value
  public static func zip<A, B, C, D, E, F, G, H, I>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F, _ g: G, _ h: H, _ i: I) -> GliaCoreDependency.ReactiveSwift.Property<(Self.Value, B.Value, C.Value, D.Value, E.Value, F.Value, G.Value, H.Value, I.Value)> where A : GliaCoreDependency.ReactiveSwiftPropertyProtocol, B : GliaCoreDependency.ReactiveSwiftPropertyProtocol, C : GliaCoreDependency.ReactiveSwiftPropertyProtocol, D : GliaCoreDependency.ReactiveSwiftPropertyProtocol, E : GliaCoreDependency.ReactiveSwiftPropertyProtocol, F : GliaCoreDependency.ReactiveSwiftPropertyProtocol, G : GliaCoreDependency.ReactiveSwiftPropertyProtocol, H : GliaCoreDependency.ReactiveSwiftPropertyProtocol, I : GliaCoreDependency.ReactiveSwiftPropertyProtocol, Self.Value == A.Value
  public static func zip<A, B, C, D, E, F, G, H, I, J>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F, _ g: G, _ h: H, _ i: I, _ j: J) -> GliaCoreDependency.ReactiveSwift.Property<(Self.Value, B.Value, C.Value, D.Value, E.Value, F.Value, G.Value, H.Value, I.Value, J.Value)> where A : GliaCoreDependency.ReactiveSwiftPropertyProtocol, B : GliaCoreDependency.ReactiveSwiftPropertyProtocol, C : GliaCoreDependency.ReactiveSwiftPropertyProtocol, D : GliaCoreDependency.ReactiveSwiftPropertyProtocol, E : GliaCoreDependency.ReactiveSwiftPropertyProtocol, F : GliaCoreDependency.ReactiveSwiftPropertyProtocol, G : GliaCoreDependency.ReactiveSwiftPropertyProtocol, H : GliaCoreDependency.ReactiveSwiftPropertyProtocol, I : GliaCoreDependency.ReactiveSwiftPropertyProtocol, J : GliaCoreDependency.ReactiveSwiftPropertyProtocol, Self.Value == A.Value
  public static func zip<S>(_ properties: S) -> GliaCoreDependency.ReactiveSwift.Property<[S.Iterator.Element.Value]>? where S : Swift.Sequence, S.Element : GliaCoreDependency.ReactiveSwiftPropertyProtocol
  public static func zip<S>(_ properties: S, emptySentinel: [S.Iterator.Element.Value]) -> GliaCoreDependency.ReactiveSwift.Property<[S.Iterator.Element.Value]> where S : Swift.Sequence, S.Element : GliaCoreDependency.ReactiveSwiftPropertyProtocol
}
extension GliaCoreDependency.ReactiveSwiftPropertyProtocol where Self.Value == Swift.Bool {
  public func negate() -> GliaCoreDependency.ReactiveSwift.Property<Self.Value>
  public func and<P>(_ property: P) -> GliaCoreDependency.ReactiveSwift.Property<Self.Value> where P : GliaCoreDependency.ReactiveSwiftPropertyProtocol, P.Value == Swift.Bool
  public static func all<P, Properties>(_ properties: Properties) -> GliaCoreDependency.ReactiveSwift.Property<Self.Value> where P : GliaCoreDependency.ReactiveSwiftPropertyProtocol, P == Properties.Element, Properties : Swift.Collection, P.Value == Swift.Bool
  public static func all<P>(_ properties: P...) -> GliaCoreDependency.ReactiveSwift.Property<Self.Value> where P : GliaCoreDependency.ReactiveSwiftPropertyProtocol, P.Value == Swift.Bool
  public func or<P>(_ property: P) -> GliaCoreDependency.ReactiveSwift.Property<Self.Value> where P : GliaCoreDependency.ReactiveSwiftPropertyProtocol, P.Value == Swift.Bool
  public static func any<P, Properties>(_ properties: Properties) -> GliaCoreDependency.ReactiveSwift.Property<Self.Value> where P : GliaCoreDependency.ReactiveSwiftPropertyProtocol, P == Properties.Element, Properties : Swift.Collection, P.Value == Swift.Bool
  public static func any<P>(_ properties: P...) -> GliaCoreDependency.ReactiveSwift.Property<Self.Value> where P : GliaCoreDependency.ReactiveSwiftPropertyProtocol, P.Value == Swift.Bool
}
extension GliaCoreDependency.ReactiveSwift {
  @_hasMissingDesignatedInitializers @propertyWrapper final public class Property<Value> : GliaCoreDependency.ReactiveSwiftPropertyProtocol {
    final public var value: Value {
      get
    }
    @inlinable final public var wrappedValue: Value {
      get {
            return value
        }
    }
    @inlinable final public var projectedValue: GliaCoreDependency.ReactiveSwift.Property<Value> {
      get {
            return self
        }
    }
    final public let producer: GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Swift.Never>
    final public let signal: GliaCoreDependency.ReactiveSwiftSignal<Value, Swift.Never>
    public init(value: Value)
    public init<P>(capturing property: P) where Value == P.Value, P : GliaCoreDependency.ReactiveSwiftPropertyProtocol
    convenience public init<P>(_ property: P) where Value == P.Value, P : GliaCoreDependency.ReactiveSwiftPropertyProtocol
    convenience public init(initial: Value, then values: GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Swift.Never>)
    convenience public init<Values>(initial: Value, then values: Values) where Value == Values.Value, Values : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, Values.Error == Swift.Never
    public typealias Error = Swift.Never
    @objc deinit
  }
}
extension GliaCoreDependency.ReactiveSwift.Property where Value : GliaCoreDependency.ReactiveSwiftOptionalProtocol {
  convenience public init(initial: Value, then values: GliaCoreDependency.ReactiveSwift.SignalProducer<Value.Wrapped, Swift.Never>)
  convenience public init<Values>(initial: Value, then values: Values) where Values : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, Value.Wrapped == Values.Value, Values.Error == Swift.Never
}
extension GliaCoreDependency.ReactiveSwift {
  @propertyWrapper final public class MutableProperty<Value> : GliaCoreDependency.ReactiveSwiftComposableMutablePropertyProtocol {
    final public var value: Value {
      get
      set
    }
    @inlinable final public var wrappedValue: Value {
      get { value }
      set { value = newValue }
    }
    @inlinable final public var projectedValue: GliaCoreDependency.ReactiveSwift.MutableProperty<Value> {
      get {
            return self
        }
    }
    final public let lifetime: GliaCoreDependency.ReactiveSwift.Lifetime
    final public let signal: GliaCoreDependency.ReactiveSwiftSignal<Value, Swift.Never>
    final public var producer: GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Swift.Never> {
      get
    }
    public init(_ initialValue: Value)
    convenience public init(wrappedValue: Value)
    @discardableResult
    final public func modify<Result>(_ action: (inout Value) throws -> Result) rethrows -> Result
    @discardableResult
    final public func withValue<Result>(_ action: (Value) throws -> Result) rethrows -> Result
    @objc deinit
    public typealias Error = Swift.Never
  }
}
extension GliaCoreDependency.ReactiveSwift {
  public struct Bag<Element> {
    public struct Token {
    }
    public init()
    public init<S>(_ elements: S) where Element == S.Element, S : Swift.Sequence
    @discardableResult
    public mutating func insert(_ value: Element) -> GliaCoreDependency.ReactiveSwift.Bag<Element>.Token
    @discardableResult
    public mutating func remove(using token: GliaCoreDependency.ReactiveSwift.Bag<Element>.Token) -> Element?
  }
}
extension GliaCoreDependency.ReactiveSwift.Bag : Swift.RandomAccessCollection {
  public var startIndex: Swift.Int {
    get
  }
  public var endIndex: Swift.Int {
    get
  }
  public subscript(index: Swift.Int) -> Element {
    get
  }
  public func makeIterator() -> GliaCoreDependency.ReactiveSwift.Bag<Element>.Iterator
  public struct Iterator : Swift.IteratorProtocol {
    public mutating func next() -> Element?
  }
  public typealias Index = Swift.Int
  public typealias Indices = Swift.Range<Swift.Int>
  public typealias SubSequence = Swift.Slice<GliaCoreDependency.ReactiveSwift.Bag<Element>>
}
precedencegroup BindingPrecedence {
  associativity: right
  higherThan: AssignmentPrecedence
}
infix operator <~ : BindingPrecedence
public protocol ReactiveSwiftBindingSource : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible where Self.Error == Swift.Never {
}
extension GliaCoreDependency.ReactiveSwiftSignal : GliaCoreDependency.ReactiveSwiftBindingSource where Error == Swift.Never {
}
extension GliaCoreDependency.ReactiveSwift.SignalProducer : GliaCoreDependency.ReactiveSwiftBindingSource where Error == Swift.Never {
}
public protocol ReactiveSwiftBindingTargetProvider {
  associatedtype Value
  var bindingTarget: GliaCoreDependency.ReactiveSwift.BindingTarget<Self.Value> { get }
}
extension GliaCoreDependency.ReactiveSwiftBindingTargetProvider {
  @discardableResult
  public static func <~ <Source>(provider: Self, source: Source) -> (any GliaCoreDependency.ReactiveSwiftDisposable)? where Source : GliaCoreDependency.ReactiveSwiftBindingSource, Self.Value == Source.Value
  @discardableResult
  public static func <~ <Source>(provider: Self, source: Source) -> (any GliaCoreDependency.ReactiveSwiftDisposable)? where Source : GliaCoreDependency.ReactiveSwiftBindingSource, Self.Value == Source.Value?
}
extension GliaCoreDependency.ReactiveSwiftSignal.Observer {
  @discardableResult
  public static func <~ <Source>(observer: GliaCoreDependency.ReactiveSwiftSignal<Value, Error>.Observer, source: Source) -> (any GliaCoreDependency.ReactiveSwiftDisposable)? where Value == Source.Value, Source : GliaCoreDependency.ReactiveSwiftBindingSource
}
extension GliaCoreDependency.ReactiveSwift {
  public struct BindingTarget<Value> : GliaCoreDependency.ReactiveSwiftBindingTargetProvider {
    public let lifetime: GliaCoreDependency.ReactiveSwift.Lifetime
    public let action: (Value) -> Swift.Void
    public var bindingTarget: GliaCoreDependency.ReactiveSwift.BindingTarget<Value> {
      get
    }
    public init(on scheduler: any GliaCoreDependency.ReactiveSwiftScheduler = ReactiveSwift.ImmediateScheduler(), lifetime: GliaCoreDependency.ReactiveSwift.Lifetime, action: @escaping (Value) -> Swift.Void)
    public init<Object>(on scheduler: any GliaCoreDependency.ReactiveSwiftScheduler = ReactiveSwift.ImmediateScheduler(), lifetime: GliaCoreDependency.ReactiveSwift.Lifetime, object: Object, keyPath: Swift.WritableKeyPath<Object, Value>) where Object : AnyObject
  }
}
extension Swift.Optional : GliaCoreDependency.ReactiveSwiftBindingTargetProvider where Wrapped : GliaCoreDependency.ReactiveSwiftBindingTargetProvider {
  public typealias Value = Wrapped.Value
  public var bindingTarget: GliaCoreDependency.ReactiveSwift.BindingTarget<Wrapped.Value> {
    get
  }
}
extension GliaCoreDependency.ReactiveSwiftSignal {
  @_hasMissingDesignatedInitializers final public class Observer {
    public typealias Event = GliaCoreDependency.ReactiveSwiftSignal<Value, Error>.Event
    public typealias Action = (GliaCoreDependency.ReactiveSwiftSignal<Value, Error>.Observer.Event) -> Swift.Void
    public init(_ action: @escaping GliaCoreDependency.ReactiveSwiftSignal<Value, Error>.Observer.Action)
    convenience public init(value: ((Value) -> Swift.Void)? = nil, failed: ((Error) -> Swift.Void)? = nil, completed: (() -> Swift.Void)? = nil, interrupted: (() -> Swift.Void)? = nil)
    @objc deinit
    final public func send(_ event: GliaCoreDependency.ReactiveSwiftSignal<Value, Error>.Observer.Event)
    final public func send(value: Value)
    final public func send(error: Error)
    final public func sendCompleted()
    final public func sendInterrupted()
  }
}
extension GliaCoreDependency.ReactiveSwiftSignal.Observer {
  @available(*, unavailable, renamed: "send(_:)")
  final public var action: GliaCoreDependency.ReactiveSwiftSignal<Value, Error>.Observer.Action {
    get
  }
}
extension GliaCoreDependency.SwiftPhoenixClient {
  public enum SocketError : Swift.Error {
    case abnormalClosureError
    public static func == (a: GliaCoreDependency.SwiftPhoenixClient.SocketError, b: GliaCoreDependency.SwiftPhoenixClient.SocketError) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public typealias Payload = [Swift.String : Any]
  public typealias PayloadClosure = () -> GliaCoreDependency.SwiftPhoenixClient.Payload?
  public class Socket : GliaCoreDependency.SwiftPhoenixClient.PhoenixTransportDelegate {
    final public let endPoint: Swift.String
    public var endPointUrl: Foundation.URL {
      get
    }
    public var params: GliaCoreDependency.SwiftPhoenixClient.Payload? {
      get
    }
    final public let paramsClosure: GliaCoreDependency.SwiftPhoenixClient.PayloadClosure?
    final public let vsn: Swift.String
    public var encode: (Any) -> Foundation.Data
    public var decode: (Foundation.Data) -> Any?
    public var timeout: Foundation.TimeInterval
    public var headers: [Swift.String : Any]
    public var heartbeatInterval: Foundation.TimeInterval
    public var heartbeatLeeway: Dispatch.DispatchTimeInterval
    public var reconnectAfter: (Swift.Int) -> Foundation.TimeInterval
    public var rejoinAfter: (Swift.Int) -> Foundation.TimeInterval
    public var logger: ((Swift.String) -> Swift.Void)?
    public var skipHeartbeat: Swift.Bool
    public var disableSSLCertValidation: Swift.Bool
    public var enabledSSLCipherSuites: [Security.SSLCipherSuite]?
    public var channels: [GliaCoreDependency.SwiftPhoenixClient.Channel] {
      get
    }
    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
    convenience public init(_ endPoint: Swift.String, params: GliaCoreDependency.SwiftPhoenixClient.Payload? = nil, vsn: Swift.String = Defaults.vsn)
    @available(macOS 10.15, iOS 13, watchOS 6, tvOS 13, *)
    convenience public init(_ endPoint: Swift.String, paramsClosure: GliaCoreDependency.SwiftPhoenixClient.PayloadClosure?, vsn: Swift.String = Defaults.vsn)
    public init(endPoint: Swift.String, transport: @escaping ((Foundation.URL) -> any GliaCoreDependency.PhoenixTransportProtocol), paramsClosure: GliaCoreDependency.SwiftPhoenixClient.PayloadClosure? = nil, vsn: Swift.String = Defaults.vsn)
    @objc deinit
    public var websocketProtocol: Swift.String {
      get
    }
    public var isConnected: Swift.Bool {
      get
    }
    public var connectionState: GliaCoreDependency.SwiftPhoenixClient.PhoenixTransportReadyState {
      get
    }
    public func connect()
    public func disconnect(code: GliaCoreDependency.SwiftPhoenixClient.Socket.CloseCode = CloseCode.normal, reason: Swift.String? = nil, callback: (() -> Swift.Void)? = nil)
    @discardableResult
    public func onOpen(callback: @escaping () -> Swift.Void) -> Swift.String
    @discardableResult
    public func onOpen(callback: @escaping (Foundation.URLResponse?) -> Swift.Void) -> Swift.String
    @discardableResult
    public func delegateOnOpen<T>(to owner: T, callback: @escaping ((T) -> Swift.Void)) -> Swift.String where T : AnyObject
    @discardableResult
    public func delegateOnOpen<T>(to owner: T, callback: @escaping ((T, Foundation.URLResponse?) -> Swift.Void)) -> Swift.String where T : AnyObject
    @discardableResult
    public func onClose(callback: @escaping () -> Swift.Void) -> Swift.String
    @discardableResult
    public func onClose(callback: @escaping (Swift.Int, Swift.String?) -> Swift.Void) -> Swift.String
    @discardableResult
    public func delegateOnClose<T>(to owner: T, callback: @escaping ((T) -> Swift.Void)) -> Swift.String where T : AnyObject
    @discardableResult
    public func delegateOnClose<T>(to owner: T, callback: @escaping ((T, (Swift.Int, Swift.String?)) -> Swift.Void)) -> Swift.String where T : AnyObject
    @discardableResult
    public func onError(callback: @escaping ((any Swift.Error, Foundation.URLResponse?)) -> Swift.Void) -> Swift.String
    @discardableResult
    public func delegateOnError<T>(to owner: T, callback: @escaping ((T, (any Swift.Error, Foundation.URLResponse?)) -> Swift.Void)) -> Swift.String where T : AnyObject
    @discardableResult
    public func onMessage(callback: @escaping (GliaCoreDependency.SwiftPhoenixClient.Message) -> Swift.Void) -> Swift.String
    @discardableResult
    public func delegateOnMessage<T>(to owner: T, callback: @escaping ((T, GliaCoreDependency.SwiftPhoenixClient.Message) -> Swift.Void)) -> Swift.String where T : AnyObject
    public func releaseCallbacks()
    public func channel(_ topic: Swift.String, params: [Swift.String : Any] = [:]) -> GliaCoreDependency.SwiftPhoenixClient.Channel
    public func remove(_ channel: GliaCoreDependency.SwiftPhoenixClient.Channel)
    public func off(_ refs: [Swift.String])
    public func makeRef() -> Swift.String
    public func onOpen(response: Foundation.URLResponse?)
    public func onError(error: any Swift.Error, response: Foundation.URLResponse?)
    public func onMessage(message: Swift.String)
    public func onClose(code: Swift.Int, reason: Swift.String? = nil)
  }
}
extension GliaCoreDependency.SwiftPhoenixClient.Socket {
  public enum CloseCode : Swift.Int {
    case abnormal
    case normal
    case goingAway
    public init?(rawValue: Swift.Int)
    public typealias RawValue = Swift.Int
    public var rawValue: Swift.Int {
      get
    }
  }
}
extension GliaCoreDependency.ReactiveSwift {
  public class ValidatingProperty<Value, ValidationError> : GliaCoreDependency.ReactiveSwiftMutablePropertyProtocol where ValidationError : Swift.Error {
    final public let result: GliaCoreDependency.ReactiveSwift.Property<GliaCoreDependency.ReactiveSwift.ValidatingProperty<Value, ValidationError>.Result>
    public var value: Value {
      get
      set
    }
    final public let producer: GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Swift.Never>
    final public let signal: GliaCoreDependency.ReactiveSwiftSignal<Value, Swift.Never>
    final public let lifetime: GliaCoreDependency.ReactiveSwift.Lifetime
    public init<Inner>(_ inner: Inner, _ validator: @escaping (Value) -> GliaCoreDependency.ReactiveSwift.ValidatingProperty<Value, ValidationError>.Decision) where Value == Inner.Value, Inner : GliaCoreDependency.ReactiveSwiftComposableMutablePropertyProtocol
    convenience public init(_ initial: Value, _ validator: @escaping (Value) -> GliaCoreDependency.ReactiveSwift.ValidatingProperty<Value, ValidationError>.Decision)
    convenience public init<Other>(_ inner: GliaCoreDependency.ReactiveSwift.MutableProperty<Value>, with other: Other, _ validator: @escaping (Value, Other.Value) -> GliaCoreDependency.ReactiveSwift.ValidatingProperty<Value, ValidationError>.Decision) where Other : GliaCoreDependency.ReactiveSwiftPropertyProtocol
    convenience public init<Other>(_ initial: Value, with other: Other, _ validator: @escaping (Value, Other.Value) -> GliaCoreDependency.ReactiveSwift.ValidatingProperty<Value, ValidationError>.Decision) where Other : GliaCoreDependency.ReactiveSwiftPropertyProtocol
    convenience public init<U, E>(_ initial: Value, with other: GliaCoreDependency.ReactiveSwift.ValidatingProperty<U, E>, _ validator: @escaping (Value, U) -> GliaCoreDependency.ReactiveSwift.ValidatingProperty<Value, ValidationError>.Decision) where E : Swift.Error
    convenience public init<U, E>(_ inner: GliaCoreDependency.ReactiveSwift.MutableProperty<Value>, with other: GliaCoreDependency.ReactiveSwift.ValidatingProperty<U, E>, _ validator: @escaping (Value, U) -> GliaCoreDependency.ReactiveSwift.ValidatingProperty<Value, ValidationError>.Decision) where E : Swift.Error
    public enum Decision {
      case valid
      case coerced(Value, ValidationError?)
      case invalid(ValidationError)
    }
    public enum Result {
      case valid(Value)
      case coerced(replacement: Value, proposed: Value, error: ValidationError?)
      case invalid(Value, ValidationError)
      public var isInvalid: Swift.Bool {
        get
      }
      public var value: Value? {
        get
      }
      public var error: ValidationError? {
        get
      }
    }
    public typealias Error = Swift.Never
    @objc deinit
  }
}
public protocol ReactiveSwiftReactiveExtensionsProvider {
}
extension GliaCoreDependency.ReactiveSwiftReactiveExtensionsProvider {
  public var reactive: GliaCoreDependency.ReactiveSwift.Reactive<Self> {
    get
  }
  public static var reactive: GliaCoreDependency.ReactiveSwift.Reactive<Self>.Type {
    get
  }
}
extension GliaCoreDependency.ReactiveSwift {
  public struct Reactive<Base> {
    public let base: Base
  }
}
extension GliaCoreDependency.ReactiveSwiftSignal {
  public enum Event {
    case value(Value)
    case failed(Error)
    case completed
    case interrupted
    public var isCompleted: Swift.Bool {
      get
    }
    public var isTerminating: Swift.Bool {
      get
    }
    public func map<U>(_ f: (Value) -> U) -> GliaCoreDependency.ReactiveSwiftSignal<U, Error>.Event
    public func mapError<F>(_ f: (Error) -> F) -> GliaCoreDependency.ReactiveSwiftSignal<Value, F>.Event where F : Swift.Error
    public var value: Value? {
      get
    }
    public var error: Error? {
      get
    }
  }
}
extension GliaCoreDependency.ReactiveSwiftSignal.Event where Value : Swift.Equatable, Error : Swift.Equatable {
  public static func == (lhs: GliaCoreDependency.ReactiveSwiftSignal<Value, Error>.Event, rhs: GliaCoreDependency.ReactiveSwiftSignal<Value, Error>.Event) -> Swift.Bool
}
extension GliaCoreDependency.ReactiveSwiftSignal.Event : Swift.Equatable where Value : Swift.Equatable, Error : Swift.Equatable {
}
extension GliaCoreDependency.ReactiveSwiftSignal.Event : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
public protocol ReactiveSwiftEventProtocol {
  associatedtype Value
  associatedtype Error : Swift.Error
  var event: GliaCoreDependency.ReactiveSwiftSignal<Self.Value, Self.Error>.Event { get }
}
extension GliaCoreDependency.ReactiveSwiftSignal.Event : GliaCoreDependency.ReactiveSwiftEventProtocol {
  public var event: GliaCoreDependency.ReactiveSwiftSignal<Value, Error>.Event {
    get
  }
}
extension GliaCoreDependency.SwiftPhoenixClient {
  public class SynchronizedArray<Element> {
    public init(_ array: [Element] = [])
    @objc deinit
  }
}
extension GliaCoreDependency.ReactiveSwift {
  public struct FlattenStrategy {
    public static let merge: GliaCoreDependency.ReactiveSwift.FlattenStrategy
    public static let concat: GliaCoreDependency.ReactiveSwift.FlattenStrategy
    public static let latest: GliaCoreDependency.ReactiveSwift.FlattenStrategy
    public static let race: GliaCoreDependency.ReactiveSwift.FlattenStrategy
    public static let throttle: GliaCoreDependency.ReactiveSwift.FlattenStrategy
  }
}
extension GliaCoreDependency.ReactiveSwiftSignal where Value : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, Error == Value.Error {
  final public func flatten(_ strategy: GliaCoreDependency.ReactiveSwift.FlattenStrategy) -> GliaCoreDependency.ReactiveSwiftSignal<Value.Value, Error>
}
extension GliaCoreDependency.ReactiveSwiftSignal where Value : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, Error == Swift.Never {
  final public func flatten(_ strategy: GliaCoreDependency.ReactiveSwift.FlattenStrategy) -> GliaCoreDependency.ReactiveSwiftSignal<Value.Value, Value.Error>
}
extension GliaCoreDependency.ReactiveSwiftSignal where Value : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, Error == Swift.Never, Value.Error == Swift.Never {
  final public func flatten(_ strategy: GliaCoreDependency.ReactiveSwift.FlattenStrategy) -> GliaCoreDependency.ReactiveSwiftSignal<Value.Value, Value.Error>
}
extension GliaCoreDependency.ReactiveSwiftSignal where Value : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, Value.Error == Swift.Never {
  final public func flatten(_ strategy: GliaCoreDependency.ReactiveSwift.FlattenStrategy) -> GliaCoreDependency.ReactiveSwiftSignal<Value.Value, Error>
}
extension GliaCoreDependency.ReactiveSwift.SignalProducer where Value : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, Error == Value.Error {
  public func flatten(_ strategy: GliaCoreDependency.ReactiveSwift.FlattenStrategy) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value.Value, Error>
}
extension GliaCoreDependency.ReactiveSwift.SignalProducer where Value : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, Error == Swift.Never {
  public func flatten(_ strategy: GliaCoreDependency.ReactiveSwift.FlattenStrategy) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value.Value, Value.Error>
}
extension GliaCoreDependency.ReactiveSwift.SignalProducer where Value : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, Error == Swift.Never, Value.Error == Swift.Never {
  public func flatten(_ strategy: GliaCoreDependency.ReactiveSwift.FlattenStrategy) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value.Value, Value.Error>
}
extension GliaCoreDependency.ReactiveSwift.SignalProducer where Value : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, Value.Error == Swift.Never {
  public func flatten(_ strategy: GliaCoreDependency.ReactiveSwift.FlattenStrategy) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value.Value, Error>
}
extension GliaCoreDependency.ReactiveSwiftSignal where Value : Swift.Sequence {
  final public func flatten() -> GliaCoreDependency.ReactiveSwiftSignal<Value.Iterator.Element, Error>
}
extension GliaCoreDependency.ReactiveSwift.SignalProducer where Value : Swift.Sequence {
  public func flatten() -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value.Iterator.Element, Error>
}
extension GliaCoreDependency.ReactiveSwift.SignalProducer {
  public func concat(_ next: GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>
  public func concat<Next>(_ next: Next) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error> where Value == Next.Value, Error == Next.Error, Next : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible
  public func concat(value: Value) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>
  public func concat(error: Error) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>
  public func prefix(_ previous: GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>
  public func prefix<Previous>(_ previous: Previous) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error> where Value == Previous.Value, Error == Previous.Error, Previous : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible
  public func prefix(value: Value) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>
}
extension GliaCoreDependency.ReactiveSwiftSignal {
  public static func merge<Seq>(_ signals: Seq) -> GliaCoreDependency.ReactiveSwiftSignal<Value, Error> where Seq : Swift.Sequence, Seq.Element == GliaCoreDependency.ReactiveSwiftSignal<Value, Error>
  public static func merge(_ signals: GliaCoreDependency.ReactiveSwiftSignal<Value, Error>...) -> GliaCoreDependency.ReactiveSwiftSignal<Value, Error>
}
extension GliaCoreDependency.ReactiveSwift.SignalProducer {
  public static func merge<Seq>(_ producers: Seq) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error> where Seq : Swift.Sequence, Seq.Element == GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>
  public static func merge<A, B>(_ a: A, _ b: B) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error> where Value == A.Value, Error == A.Error, A : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, B : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, A.Error == B.Error, A.Value == B.Value
  public static func merge<A, B, C>(_ a: A, _ b: B, _ c: C) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error> where Value == A.Value, Error == A.Error, A : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, B : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, C : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, A.Error == B.Error, A.Value == B.Value, B.Error == C.Error, B.Value == C.Value
  public static func merge<A, B, C, D>(_ a: A, _ b: B, _ c: C, _ d: D) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error> where Value == A.Value, Error == A.Error, A : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, B : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, C : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, D : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, A.Error == B.Error, A.Value == B.Value, B.Error == C.Error, B.Value == C.Value, C.Error == D.Error, C.Value == D.Value
  public static func merge<A, B, C, D, E>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error> where Value == A.Value, Error == A.Error, A : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, B : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, C : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, D : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, E : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, A.Error == B.Error, A.Value == B.Value, B.Error == C.Error, B.Value == C.Value, C.Error == D.Error, C.Value == D.Value, D.Error == E.Error, D.Value == E.Value
  public static func merge<A, B, C, D, E, F>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error> where Value == A.Value, Error == A.Error, A : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, B : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, C : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, D : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, E : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, F : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, A.Error == B.Error, A.Value == B.Value, B.Error == C.Error, B.Value == C.Value, C.Error == D.Error, C.Value == D.Value, D.Error == E.Error, D.Value == E.Value, E.Error == F.Error, E.Value == F.Value
  public static func merge<A, B, C, D, E, F, G>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F, _ g: G) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error> where Value == A.Value, Error == A.Error, A : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, B : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, C : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, D : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, E : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, F : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, G : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, A.Error == B.Error, A.Value == B.Value, B.Error == C.Error, B.Value == C.Value, C.Error == D.Error, C.Value == D.Value, D.Error == E.Error, D.Value == E.Value, E.Error == F.Error, E.Value == F.Value, F.Error == G.Error, F.Value == G.Value
  public static func merge<A, B, C, D, E, F, G, H>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F, _ g: G, _ h: H) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error> where Value == A.Value, Error == A.Error, A : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, B : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, C : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, D : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, E : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, F : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, G : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, H : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, A.Error == B.Error, A.Value == B.Value, B.Error == C.Error, B.Value == C.Value, C.Error == D.Error, C.Value == D.Value, D.Error == E.Error, D.Value == E.Value, E.Error == F.Error, E.Value == F.Value, F.Error == G.Error, F.Value == G.Value, G.Error == H.Error, G.Value == H.Value
  public static func merge<A, B, C, D, E, F, G, H, I>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F, _ g: G, _ h: H, _ i: I) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error> where Value == A.Value, Error == A.Error, A : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, B : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, C : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, D : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, E : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, F : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, G : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, H : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, I : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, A.Error == B.Error, A.Value == B.Value, B.Error == C.Error, B.Value == C.Value, C.Error == D.Error, C.Value == D.Value, D.Error == E.Error, D.Value == E.Value, E.Error == F.Error, E.Value == F.Value, F.Error == G.Error, F.Value == G.Value, G.Error == H.Error, G.Value == H.Value, H.Error == I.Error, H.Value == I.Value
  public static func merge<A, B, C, D, E, F, G, H, I, J>(_ a: A, _ b: B, _ c: C, _ d: D, _ e: E, _ f: F, _ g: G, _ h: H, _ i: I, _ j: J) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error> where Value == A.Value, Error == A.Error, A : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, B : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, C : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, D : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, E : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, F : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, G : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, H : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, I : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, J : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, A.Error == B.Error, A.Value == B.Value, B.Error == C.Error, B.Value == C.Value, C.Error == D.Error, C.Value == D.Value, D.Error == E.Error, D.Value == E.Value, E.Error == F.Error, E.Value == F.Value, F.Error == G.Error, F.Value == G.Value, G.Error == H.Error, G.Value == H.Value, H.Error == I.Error, H.Value == I.Value, I.Error == J.Error, I.Value == J.Value
}
extension GliaCoreDependency.ReactiveSwiftSignal {
  final public func flatMap<U>(_ strategy: GliaCoreDependency.ReactiveSwift.FlattenStrategy, _ transform: @escaping (Value) -> GliaCoreDependency.ReactiveSwift.SignalProducer<U, Error>) -> GliaCoreDependency.ReactiveSwiftSignal<U, Error>
  final public func flatMap<Inner>(_ strategy: GliaCoreDependency.ReactiveSwift.FlattenStrategy, _ transform: @escaping (Value) -> Inner) -> GliaCoreDependency.ReactiveSwiftSignal<Inner.Value, Error> where Error == Inner.Error, Inner : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible
  final public func flatMap<U>(_ strategy: GliaCoreDependency.ReactiveSwift.FlattenStrategy, _ transform: @escaping (Value) -> GliaCoreDependency.ReactiveSwift.SignalProducer<U, Swift.Never>) -> GliaCoreDependency.ReactiveSwiftSignal<U, Error>
  final public func flatMap<Inner>(_ strategy: GliaCoreDependency.ReactiveSwift.FlattenStrategy, _ transform: @escaping (Value) -> Inner) -> GliaCoreDependency.ReactiveSwiftSignal<Inner.Value, Error> where Inner : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, Inner.Error == Swift.Never
}
extension GliaCoreDependency.ReactiveSwiftSignal where Error == Swift.Never {
  final public func flatMap<U, F>(_ strategy: GliaCoreDependency.ReactiveSwift.FlattenStrategy, _ transform: @escaping (Value) -> GliaCoreDependency.ReactiveSwift.SignalProducer<U, F>) -> GliaCoreDependency.ReactiveSwiftSignal<U, F> where F : Swift.Error
  final public func flatMap<Inner>(_ strategy: GliaCoreDependency.ReactiveSwift.FlattenStrategy, _ transform: @escaping (Value) -> Inner) -> GliaCoreDependency.ReactiveSwiftSignal<Inner.Value, Inner.Error> where Inner : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible
  final public func flatMap<U>(_ strategy: GliaCoreDependency.ReactiveSwift.FlattenStrategy, _ transform: @escaping (Value) -> GliaCoreDependency.ReactiveSwift.SignalProducer<U, Swift.Never>) -> GliaCoreDependency.ReactiveSwiftSignal<U, Swift.Never>
  final public func flatMap<Inner>(_ strategy: GliaCoreDependency.ReactiveSwift.FlattenStrategy, _ transform: @escaping (Value) -> Inner) -> GliaCoreDependency.ReactiveSwiftSignal<Inner.Value, Swift.Never> where Inner : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, Inner.Error == Swift.Never
}
extension GliaCoreDependency.ReactiveSwift.SignalProducer {
  public func flatMap<U>(_ strategy: GliaCoreDependency.ReactiveSwift.FlattenStrategy, _ transform: @escaping (Value) -> GliaCoreDependency.ReactiveSwift.SignalProducer<U, Error>) -> GliaCoreDependency.ReactiveSwift.SignalProducer<U, Error>
  public func flatMap<Inner>(_ strategy: GliaCoreDependency.ReactiveSwift.FlattenStrategy, _ transform: @escaping (Value) -> Inner) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Inner.Value, Error> where Error == Inner.Error, Inner : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible
  public func flatMap<U>(_ strategy: GliaCoreDependency.ReactiveSwift.FlattenStrategy, _ transform: @escaping (Value) -> GliaCoreDependency.ReactiveSwift.SignalProducer<U, Swift.Never>) -> GliaCoreDependency.ReactiveSwift.SignalProducer<U, Error>
  public func flatMap<Inner>(_ strategy: GliaCoreDependency.ReactiveSwift.FlattenStrategy, _ transform: @escaping (Value) -> Inner) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Inner.Value, Error> where Inner : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, Inner.Error == Swift.Never
}
extension GliaCoreDependency.ReactiveSwift.SignalProducer where Error == Swift.Never {
  public func flatMap<U>(_ strategy: GliaCoreDependency.ReactiveSwift.FlattenStrategy, _ transform: @escaping (Value) -> GliaCoreDependency.ReactiveSwift.SignalProducer<U, Error>) -> GliaCoreDependency.ReactiveSwift.SignalProducer<U, Error>
  public func flatMap<Inner>(_ strategy: GliaCoreDependency.ReactiveSwift.FlattenStrategy, _ transform: @escaping (Value) -> Inner) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Inner.Value, Error> where Inner : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, Inner.Error == Swift.Never
  public func flatMap<U, F>(_ strategy: GliaCoreDependency.ReactiveSwift.FlattenStrategy, _ transform: @escaping (Value) -> GliaCoreDependency.ReactiveSwift.SignalProducer<U, F>) -> GliaCoreDependency.ReactiveSwift.SignalProducer<U, F> where F : Swift.Error
  public func flatMap<Inner>(_ strategy: GliaCoreDependency.ReactiveSwift.FlattenStrategy, _ transform: @escaping (Value) -> Inner) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Inner.Value, Inner.Error> where Inner : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible
}
extension GliaCoreDependency.ReactiveSwiftSignal {
  final public func flatMapError<F>(_ transform: @escaping (Error) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, F>) -> GliaCoreDependency.ReactiveSwiftSignal<Value, F> where F : Swift.Error
  final public func flatMapError<Inner>(_ transform: @escaping (Error) -> Inner) -> GliaCoreDependency.ReactiveSwiftSignal<Value, Inner.Error> where Value == Inner.Value, Inner : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible
}
extension GliaCoreDependency.ReactiveSwift.SignalProducer {
  public func flatMapError<F>(_ transform: @escaping (Error) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, F>) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, F> where F : Swift.Error
  public func flatMapError<Inner>(_ transform: @escaping (Error) -> Inner) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Inner.Error> where Value == Inner.Value, Inner : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible
}
extension GliaCoreDependency.ReactiveSwift {
  final public class Atomic<Value> {
    final public var value: Value {
      get
      set(newValue)
    }
    public init(_ value: Value)
    @discardableResult
    final public func modify<Result>(_ action: (inout Value) throws -> Result) rethrows -> Result
    @discardableResult
    final public func withValue<Result>(_ action: (Value) throws -> Result) rethrows -> Result
    @discardableResult
    final public func swap(_ newValue: Value) -> Value
    @objc deinit
  }
}
extension GliaCoreDependency.ReactiveSwift.SignalProducer {
  @available(*, unavailable, message: "Transform the error to `Never` beforehand, or use `startWithResult` instead")
  @discardableResult
  public func startWithValues(_ action: @escaping (Value) -> Swift.Void) -> any GliaCoreDependency.ReactiveSwiftDisposable
}
extension GliaCoreDependency.ReactiveSwiftSignal {
  @available(*, unavailable, message: "Transform the error to `Never` beforehand, or use `observeResult` instead")
  @discardableResult
  final public func observeValues(_ action: @escaping (Value) -> Swift.Void) -> (any GliaCoreDependency.ReactiveSwiftDisposable)?
}
extension GliaCoreDependency.ReactiveSwift.SignalProducer where Value == Swift.Never {
  @discardableResult
  @available(*, deprecated, message: "`Result.success` is never delivered - value type `Never` is uninstantiable (Use at runtime would trap)")
  public func startWithResult(_ action: @escaping (Swift.Result<Value, Error>) -> Swift.Void) -> any GliaCoreDependency.ReactiveSwiftDisposable
}
extension GliaCoreDependency.ReactiveSwift.SignalProducer where Value == Swift.Never, Error == Swift.Never {
  @discardableResult
  @available(*, deprecated, message: "Observer is never called - value type `Never` and error type `Never` are uninstantiable (Use at runtime would trap)")
  public func startWithResult(_ action: @escaping (Swift.Result<Value, Error>) -> Swift.Void) -> any GliaCoreDependency.ReactiveSwiftDisposable
  @discardableResult
  @available(*, deprecated, message: "Observer is never called - value type `Never` is uninstantiable (Use at runtime would trap)")
  public func startWithValues(_ action: @escaping (Value) -> Swift.Void) -> any GliaCoreDependency.ReactiveSwiftDisposable
}
extension GliaCoreDependency.ReactiveSwift.SignalProducer where Error == Swift.Never {
  @discardableResult
  @available(*, deprecated, message: "Observer is never called - error type `Never` is uninstantiable (Use at runtime would trap)")
  public func startWithFailed(_ action: @escaping (Error) -> Swift.Void) -> any GliaCoreDependency.ReactiveSwiftDisposable
}
extension GliaCoreDependency.ReactiveSwiftSignal where Value == Swift.Never {
  @discardableResult
  @available(*, deprecated, message: "`Result.success` is never delivered - value type `Never` is uninstantiable (Use at runtime would trap)")
  final public func observeResult(_ action: @escaping (Swift.Result<Value, Error>) -> Swift.Void) -> (any GliaCoreDependency.ReactiveSwiftDisposable)?
}
extension GliaCoreDependency.ReactiveSwiftSignal where Value == Swift.Never, Error == Swift.Never {
  @discardableResult
  @available(*, deprecated, message: "Observer is never called - value type `Never` and error type `Never` are uninstantiable (Use at runtime would trap)")
  final public func observeResult(_ action: @escaping (Swift.Result<Value, Error>) -> Swift.Void) -> (any GliaCoreDependency.ReactiveSwiftDisposable)?
  @discardableResult
  @available(*, deprecated, message: "Observer is never called - value type `Never` is uninstantiable (Use at runtime would trap)")
  final public func observeValues(_ action: @escaping (Value) -> Swift.Void) -> (any GliaCoreDependency.ReactiveSwiftDisposable)?
}
extension GliaCoreDependency.ReactiveSwiftSignal where Error == Swift.Never {
  @discardableResult
  @available(*, deprecated, message: "Observer is never invoked - error type `Never` is uninstantiable (Use at runtime would trap)")
  final public func observeFailed(_ action: @escaping (Error) -> Swift.Void) -> (any GliaCoreDependency.ReactiveSwiftDisposable)?
}
extension GliaCoreDependency.ReactiveSwift.SignalProducer where Value == Swift.Never {
  @discardableResult
  @available(*, deprecated, message: "Use `promoteValue` instead - value type `Never` is uninstantiable (Use at runtime would trap)")
  public func flatMap<Inner>(_ strategy: GliaCoreDependency.ReactiveSwift.FlattenStrategy, _ transform: @escaping (Value) -> Inner) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Inner.Value, Error> where Error == Inner.Error, Inner : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible
  @discardableResult
  @available(*, deprecated, message: "Use `promoteValue` instead - value type `Never` is uninstantiable (Use at runtime would trap)")
  public func flatMap<Inner>(_ strategy: GliaCoreDependency.ReactiveSwift.FlattenStrategy, _ transform: @escaping (Value) -> Inner) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Inner.Value, Error> where Inner : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, Inner.Error == Swift.Never
}
extension GliaCoreDependency.ReactiveSwift.SignalProducer where Value == Swift.Never, Error == Swift.Never {
  @discardableResult
  @available(*, deprecated, message: "Use `promoteValue` instead - value type `Never` and error type `Never` are uninstantiable (Use at runtime would trap)")
  public func flatMap<Inner>(_ strategy: GliaCoreDependency.ReactiveSwift.FlattenStrategy, _ transform: @escaping (Value) -> Inner) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Inner.Value, Inner.Error> where Inner : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible
  @discardableResult
  @available(*, deprecated, message: "Use `promoteValue` instead - value type `Never` and error type `Never` are uninstantiable (Use at runtime would trap)")
  public func flatMap<Inner>(_ strategy: GliaCoreDependency.ReactiveSwift.FlattenStrategy, _ transform: @escaping (Value) -> Inner) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Inner.Value, Inner.Error> where Inner : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, Inner.Error == Swift.Never
}
extension GliaCoreDependency.ReactiveSwift.SignalProducer where Error == Swift.Never {
  @discardableResult
  @available(*, deprecated, message: "Use `promoteError` instead - error type `Never` is uninstantiable (Use at runtime would trap)")
  public func flatMapError<NewError>(_ transform: @escaping (Error) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, NewError>) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, NewError> where NewError : Swift.Error
}
extension GliaCoreDependency.ReactiveSwiftSignal where Value == Swift.Never {
  @discardableResult
  @available(*, deprecated, message: "Use `promoteValue` instead - value type `Never` is uninstantiable (Use at runtime would trap)")
  final public func flatMap<Inner>(_ strategy: GliaCoreDependency.ReactiveSwift.FlattenStrategy, _ transform: @escaping (Value) -> Inner) -> GliaCoreDependency.ReactiveSwiftSignal<Inner.Value, Error> where Error == Inner.Error, Inner : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible
  @discardableResult
  @available(*, deprecated, message: "Use `promoteValue` instead - value type `Never` is uninstantiable (Use at runtime would trap)")
  final public func flatMap<Inner>(_ strategy: GliaCoreDependency.ReactiveSwift.FlattenStrategy, _ transform: @escaping (Value) -> Inner) -> GliaCoreDependency.ReactiveSwiftSignal<Inner.Value, Error> where Inner : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, Inner.Error == Swift.Never
}
extension GliaCoreDependency.ReactiveSwiftSignal where Value == Swift.Never, Error == Swift.Never {
  @discardableResult
  @available(*, deprecated, message: "Use `promoteValue` instead - value type `Never` and error type `Never` are uninstantiable (Use at runtime would trap)")
  final public func flatMap<Inner>(_ strategy: GliaCoreDependency.ReactiveSwift.FlattenStrategy, _ transform: @escaping (Value) -> Inner) -> GliaCoreDependency.ReactiveSwiftSignal<Inner.Value, Inner.Error> where Inner : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible
  @discardableResult
  @available(*, deprecated, message: "Use `promoteValue` instead - value type `Never` and error type `Never` are uninstantiable (Use at runtime would trap)")
  final public func flatMap<Inner>(_ strategy: GliaCoreDependency.ReactiveSwift.FlattenStrategy, _ transform: @escaping (Value) -> Inner) -> GliaCoreDependency.ReactiveSwiftSignal<Inner.Value, Inner.Error> where Inner : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible, Inner.Error == Swift.Never
}
extension GliaCoreDependency.ReactiveSwiftSignal where Error == Swift.Never {
  @discardableResult
  @available(*, deprecated, message: "Use `promoteError` instead - error type `Never` is uninstantiable (Use at runtime would trap)")
  final public func flatMapError<NewError>(_ transform: @escaping (Error) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, NewError>) -> GliaCoreDependency.ReactiveSwiftSignal<Value, NewError> where NewError : Swift.Error
}
extension GliaCoreDependency.ReactiveSwift {
  public enum LoggingEvent {
    public enum Signal : Swift.String, Swift.CaseIterable {
      case value, completed, failed, terminated, disposed, interrupted
      @available(*, deprecated, message: "Use `allCases` instead.")
      public static var allEvents: Swift.Set<GliaCoreDependency.ReactiveSwift.LoggingEvent.Signal> {
        get
      }
      public init?(rawValue: Swift.String)
      public typealias AllCases = [GliaCoreDependency.ReactiveSwift.LoggingEvent.Signal]
      public typealias RawValue = Swift.String
      public static var allCases: [GliaCoreDependency.ReactiveSwift.LoggingEvent.Signal] {
        get
      }
      public var rawValue: Swift.String {
        get
      }
    }
    public enum SignalProducer : Swift.String, Swift.CaseIterable {
      case starting, started, value, completed, failed, terminated, disposed, interrupted
      @available(*, deprecated, message: "Use `allCases` instead.")
      public static var allEvents: Swift.Set<GliaCoreDependency.ReactiveSwift.LoggingEvent.SignalProducer> {
        get
      }
      public init?(rawValue: Swift.String)
      public typealias AllCases = [GliaCoreDependency.ReactiveSwift.LoggingEvent.SignalProducer]
      public typealias RawValue = Swift.String
      public static var allCases: [GliaCoreDependency.ReactiveSwift.LoggingEvent.SignalProducer] {
        get
      }
      public var rawValue: Swift.String {
        get
      }
    }
  }
  public static func defaultEventLog(identifier: Swift.String, event: Swift.String, fileName: Swift.String, functionName: Swift.String, lineNumber: Swift.Int)
  public typealias EventLogger = (_ identifier: Swift.String, _ event: Swift.String, _ fileName: Swift.String, _ functionName: Swift.String, _ lineNumber: Swift.Int) -> Swift.Void
}
extension GliaCoreDependency.ReactiveSwiftSignal {
  final public func logEvents(identifier: Swift.String = "", events: Swift.Set<GliaCoreDependency.ReactiveSwift.LoggingEvent.Signal> = Set(ReactiveSwift.LoggingEvent.Signal.allCases), fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line, logger: @escaping GliaCoreDependency.ReactiveSwift.EventLogger = ReactiveSwift.defaultEventLog) -> GliaCoreDependency.ReactiveSwiftSignal<Value, Error>
}
extension GliaCoreDependency.ReactiveSwift.SignalProducer {
  public func logEvents(identifier: Swift.String = "", events: Swift.Set<GliaCoreDependency.ReactiveSwift.LoggingEvent.SignalProducer> = Set(ReactiveSwift.LoggingEvent.SignalProducer.allCases), fileName: Swift.String = #file, functionName: Swift.String = #function, lineNumber: Swift.Int = #line, logger: @escaping GliaCoreDependency.ReactiveSwift.EventLogger = ReactiveSwift.defaultEventLog) -> GliaCoreDependency.ReactiveSwift.SignalProducer<Value, Error>
}
extension Foundation.NotificationCenter : GliaCoreDependency.ReactiveSwiftReactiveExtensionsProvider {
}
extension GliaCoreDependency.ReactiveSwift.Reactive where Base : Foundation.NotificationCenter {
  public func notifications(forName name: Foundation.Notification.Name?, object: Swift.AnyObject? = nil) -> GliaCoreDependency.ReactiveSwiftSignal<Foundation.Notification, Swift.Never>
}
extension Foundation.URLSession : GliaCoreDependency.ReactiveSwiftReactiveExtensionsProvider {
}
extension GliaCoreDependency.ReactiveSwift.Reactive where Base : Foundation.URLSession {
  public func data(with request: Foundation.URLRequest) -> GliaCoreDependency.ReactiveSwift.SignalProducer<(Foundation.Data, Foundation.URLResponse), any Swift.Error>
}
extension Swift.Result : GliaCoreDependency.ReactiveSwiftSignalProducerConvertible {
  public var producer: GliaCoreDependency.ReactiveSwift.SignalProducer<Success, Failure> {
    get
  }
  public typealias Error = Failure
  public typealias Value = Success
}
public enum SwiftPhoenixClient {
}
public enum ReactiveSwift {
  public typealias Scheduler = GliaCoreDependency.ReactiveSwiftScheduler
  public typealias OptionalProtocol = GliaCoreDependency.ReactiveSwiftOptionalProtocol
  public typealias DateScheduler = GliaCoreDependency.ReactiveSwiftDateScheduler
  public typealias ReactiveExtensionsProvider = GliaCoreDependency.ReactiveSwiftReactiveExtensionsProvider
  public typealias Disposable = GliaCoreDependency.ReactiveSwiftDisposable
  public typealias BindingSource = GliaCoreDependency.ReactiveSwiftBindingSource
  public typealias BindingTargetProvider = GliaCoreDependency.ReactiveSwiftBindingTargetProvider
  public typealias EventProtocol = GliaCoreDependency.ReactiveSwiftEventProtocol
  public typealias PropertyProtocol = GliaCoreDependency.ReactiveSwiftPropertyProtocol
  public typealias MutablePropertyProtocol = GliaCoreDependency.ReactiveSwiftMutablePropertyProtocol
  public typealias ComposableMutablePropertyProtocol = GliaCoreDependency.ReactiveSwiftComposableMutablePropertyProtocol
  public typealias SignalProducerProtocol = GliaCoreDependency.ReactiveSwiftSignalProducerProtocol
  public typealias SignalProducerConvertible = GliaCoreDependency.ReactiveSwiftSignalProducerConvertible
  public typealias SignalProtocol = GliaCoreDependency.ReactiveSwiftSignalProtocol
  public typealias Signal = GliaCoreDependency.ReactiveSwiftSignal
}
extension GliaCoreDependency.SwiftPhoenixClient {
  @_hasMissingDesignatedInitializers public class Push {
    weak public var channel: GliaCoreDependency.SwiftPhoenixClient.Channel?
    final public let event: Swift.String
    public var payload: GliaCoreDependency.SwiftPhoenixClient.Payload
    public var timeout: Foundation.TimeInterval
    public func resend(_ timeout: Foundation.TimeInterval = Defaults.timeoutInterval)
    public func send()
    @discardableResult
    public func receive(_ status: Swift.String, callback: @escaping ((GliaCoreDependency.SwiftPhoenixClient.Message) -> ())) -> GliaCoreDependency.SwiftPhoenixClient.Push
    @discardableResult
    public func delegateReceive<Target>(_ status: Swift.String, to owner: Target, callback: @escaping ((Target, GliaCoreDependency.SwiftPhoenixClient.Message) -> ())) -> GliaCoreDependency.SwiftPhoenixClient.Push where Target : AnyObject
    @objc deinit
  }
}
extension GliaCoreDependency.SwiftPhoenixClient {
  final public class Presence {
    public struct Options {
      public static let defaults: GliaCoreDependency.SwiftPhoenixClient.Presence.Options
      public init(events: [GliaCoreDependency.SwiftPhoenixClient.Presence.Events : Swift.String])
    }
    public enum Events : Swift.String {
      case state
      case diff
      public init?(rawValue: Swift.String)
      public typealias RawValue = Swift.String
      public var rawValue: Swift.String {
        get
      }
    }
    public typealias Meta = [Swift.String : Any]
    public typealias Map = [Swift.String : [GliaCoreDependency.SwiftPhoenixClient.Presence.Meta]]
    public typealias State = [Swift.String : GliaCoreDependency.SwiftPhoenixClient.Presence.Map]
    public typealias Diff = [Swift.String : GliaCoreDependency.SwiftPhoenixClient.Presence.State]
    public typealias OnJoin = (_ key: Swift.String, _ current: GliaCoreDependency.SwiftPhoenixClient.Presence.Map?, _ new: GliaCoreDependency.SwiftPhoenixClient.Presence.Map) -> Swift.Void
    public typealias OnLeave = (_ key: Swift.String, _ current: GliaCoreDependency.SwiftPhoenixClient.Presence.Map, _ left: GliaCoreDependency.SwiftPhoenixClient.Presence.Map) -> Swift.Void
    public typealias OnSync = () -> Swift.Void
    final public var state: GliaCoreDependency.SwiftPhoenixClient.Presence.State {
      get
    }
    final public var pendingDiffs: [GliaCoreDependency.SwiftPhoenixClient.Presence.Diff] {
      get
    }
    final public var joinRef: Swift.String? {
      get
    }
    final public var isPendingSyncState: Swift.Bool {
      get
    }
    final public var onJoin: GliaCoreDependency.SwiftPhoenixClient.Presence.OnJoin {
      get
      set
    }
    final public func onJoin(_ callback: @escaping GliaCoreDependency.SwiftPhoenixClient.Presence.OnJoin)
    final public var onLeave: GliaCoreDependency.SwiftPhoenixClient.Presence.OnLeave {
      get
      set
    }
    final public func onLeave(_ callback: @escaping GliaCoreDependency.SwiftPhoenixClient.Presence.OnLeave)
    final public var onSync: GliaCoreDependency.SwiftPhoenixClient.Presence.OnSync {
      get
      set
    }
    final public func onSync(_ callback: @escaping GliaCoreDependency.SwiftPhoenixClient.Presence.OnSync)
    public init(channel: GliaCoreDependency.SwiftPhoenixClient.Channel, opts: GliaCoreDependency.SwiftPhoenixClient.Presence.Options = Options.defaults)
    final public func list() -> [GliaCoreDependency.SwiftPhoenixClient.Presence.Map]
    final public func list<T>(by transformer: (Swift.String, GliaCoreDependency.SwiftPhoenixClient.Presence.Map) -> T) -> [T]
    final public func filter(by filter: ((Swift.String, GliaCoreDependency.SwiftPhoenixClient.Presence.Map) -> Swift.Bool)?) -> GliaCoreDependency.SwiftPhoenixClient.Presence.State
    @discardableResult
    public static func syncState(_ currentState: GliaCoreDependency.SwiftPhoenixClient.Presence.State, newState: GliaCoreDependency.SwiftPhoenixClient.Presence.State, onJoin: (_ key: Swift.String, _ current: GliaCoreDependency.SwiftPhoenixClient.Presence.Map?, _ new: GliaCoreDependency.SwiftPhoenixClient.Presence.Map) -> Swift.Void = {_,_,_ in }, onLeave: (_ key: Swift.String, _ current: GliaCoreDependency.SwiftPhoenixClient.Presence.Map, _ left: GliaCoreDependency.SwiftPhoenixClient.Presence.Map) -> Swift.Void = {_,_,_ in }) -> GliaCoreDependency.SwiftPhoenixClient.Presence.State
    @discardableResult
    public static func syncDiff(_ currentState: GliaCoreDependency.SwiftPhoenixClient.Presence.State, diff: GliaCoreDependency.SwiftPhoenixClient.Presence.Diff, onJoin: (_ key: Swift.String, _ current: GliaCoreDependency.SwiftPhoenixClient.Presence.Map?, _ new: GliaCoreDependency.SwiftPhoenixClient.Presence.Map) -> Swift.Void = {_,_,_ in }, onLeave: (_ key: Swift.String, _ current: GliaCoreDependency.SwiftPhoenixClient.Presence.Map, _ left: GliaCoreDependency.SwiftPhoenixClient.Presence.Map) -> Swift.Void = {_,_,_ in }) -> GliaCoreDependency.SwiftPhoenixClient.Presence.State
    public static func filter(_ presences: GliaCoreDependency.SwiftPhoenixClient.Presence.State, by filter: ((Swift.String, GliaCoreDependency.SwiftPhoenixClient.Presence.Map) -> Swift.Bool)?) -> GliaCoreDependency.SwiftPhoenixClient.Presence.State
    public static func listBy<T>(_ presences: GliaCoreDependency.SwiftPhoenixClient.Presence.State, transformer: (Swift.String, GliaCoreDependency.SwiftPhoenixClient.Presence.Map) -> T) -> [T]
    @objc deinit
  }
}
extension GliaCoreDependency.SwiftPhoenixClient {
  public struct Delegated<Input, Output> {
    public init()
    public mutating func delegate<Target>(to target: Target, with callback: @escaping (Target, Input) -> Output) where Target : AnyObject
    public func call(_ input: Input) -> Output?
    public var isDelegateSet: Swift.Bool {
      get
    }
  }
}
extension GliaCoreDependency.SwiftPhoenixClient.Delegated {
  public mutating func stronglyDelegate<Target>(to target: Target, with callback: @escaping (Target, Input) -> Output) where Target : AnyObject
  public mutating func manuallyDelegate(with callback: @escaping (Input) -> Output)
  public mutating func removeDelegate()
}
extension GliaCoreDependency.SwiftPhoenixClient.Delegated where Input == () {
  public mutating func delegate<Target>(to target: Target, with callback: @escaping (Target) -> Output) where Target : AnyObject
  public mutating func stronglyDelegate<Target>(to target: Target, with callback: @escaping (Target) -> Output) where Target : AnyObject
}
extension GliaCoreDependency.SwiftPhoenixClient.Delegated where Input == () {
  public func call() -> Output?
}
extension GliaCoreDependency.SwiftPhoenixClient.Delegated where Output == () {
  public func call(_ input: Input)
}
extension GliaCoreDependency.SwiftPhoenixClient.Delegated where Input == (), Output == () {
  public func call()
}
extension GliaCoreDependency.SwiftPhoenixClient.ChannelState : Swift.Equatable {}
extension GliaCoreDependency.SwiftPhoenixClient.ChannelState : Swift.Hashable {}
extension GliaCoreDependency.SwiftPhoenixClient.ChannelState : Swift.RawRepresentable {}
extension GliaCoreDependency.SwiftPhoenixClient.PhoenixTransportReadyState : Swift.Equatable {}
extension GliaCoreDependency.SwiftPhoenixClient.PhoenixTransportReadyState : Swift.Hashable {}
extension GliaCoreDependency.SwiftPhoenixClient.SocketError : Swift.Equatable {}
extension GliaCoreDependency.SwiftPhoenixClient.SocketError : Swift.Hashable {}
extension GliaCoreDependency.SwiftPhoenixClient.Socket.CloseCode : Swift.Equatable {}
extension GliaCoreDependency.SwiftPhoenixClient.Socket.CloseCode : Swift.Hashable {}
extension GliaCoreDependency.SwiftPhoenixClient.Socket.CloseCode : Swift.RawRepresentable {}
extension GliaCoreDependency.ReactiveSwift.LoggingEvent.Signal : Swift.Equatable {}
extension GliaCoreDependency.ReactiveSwift.LoggingEvent.Signal : Swift.Hashable {}
extension GliaCoreDependency.ReactiveSwift.LoggingEvent.Signal : Swift.RawRepresentable {}
extension GliaCoreDependency.ReactiveSwift.LoggingEvent.SignalProducer : Swift.Equatable {}
extension GliaCoreDependency.ReactiveSwift.LoggingEvent.SignalProducer : Swift.Hashable {}
extension GliaCoreDependency.ReactiveSwift.LoggingEvent.SignalProducer : Swift.RawRepresentable {}
extension GliaCoreDependency.SwiftPhoenixClient.Presence.Events : Swift.Equatable {}
extension GliaCoreDependency.SwiftPhoenixClient.Presence.Events : Swift.Hashable {}
extension GliaCoreDependency.SwiftPhoenixClient.Presence.Events : Swift.RawRepresentable {}
